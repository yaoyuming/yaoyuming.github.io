<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yahya"><meta name="keywords" content=""><meta name="description" content="Redis线程模型Redis基于Reactor模式开发了自己的网络事件处理器，被称为文件事件处理器，由套接字、I&#x2F;O多路复用程序、文件事件分派器（dispatcher），事件处理器四部分组成。   redis为什么那么快 redis是纯内存操作：数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。 非阻塞I&#x2F;O：Redis采用epoll做"><meta property="og:type" content="article"><meta property="og:title" content="Redis 三种集群架构"><meta property="og:url" content="https://blog.yahyav2rayssr.top/posts/17835f44/index.html"><meta property="og:site_name" content="yahya的博客"><meta property="og:description" content="Redis线程模型Redis基于Reactor模式开发了自己的网络事件处理器，被称为文件事件处理器，由套接字、I&#x2F;O多路复用程序、文件事件分派器（dispatcher），事件处理器四部分组成。   redis为什么那么快 redis是纯内存操作：数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。 非阻塞I&#x2F;O：Redis采用epoll做"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/17835f44/1733c64202a74236.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/17835f44/format,png.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/17835f44/format,png-16815647991305.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/17835f44/format,png-16815648179018.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/17835f44/format,png-168156483733411.png"><meta property="article:published_time" content="2023-04-18T15:31:30.122Z"><meta property="article:modified_time" content="2023-04-18T15:31:30.123Z"><meta property="article:author" content="Yahya"><meta property="article:tag" content="Redis"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog.yahyav2rayssr.top/posts/17835f44/1733c64202a74236.jpg"><title>Redis 三种集群架构 - yahya的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"blog.yahyav2rayssr.top",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!1,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!1,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:6},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="yahya的博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yahya的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Redis 三种集群架构</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-18 23:31" pubdate>2023年4月18日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 83 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="中间件" id="heading-3cbfec336978067fe5295fb69a0ca202" role="tab" data-toggle="collapse" href="#collapse-3cbfec336978067fe5295fb69a0ca202" aria-expanded="true">中间件 <span class="list-group-count">(11)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-3cbfec336978067fe5295fb69a0ca202" role="tabpanel" aria-labelledby="heading-3cbfec336978067fe5295fb69a0ca202"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="MySQL" id="heading-62a004b95946bb97541afa471dcca73a" role="tab" data-toggle="collapse" href="#collapse-62a004b95946bb97541afa471dcca73a" aria-expanded="false">MySQL <span class="list-group-count">(7)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-62a004b95946bb97541afa471dcca73a" role="tabpanel" aria-labelledby="heading-62a004b95946bb97541afa471dcca73a"><div class="category-post-list"><a href="/posts/47eac6e4/" title="MySQL 基础" class="list-group-item list-group-item-action"><span class="category-post">MySQL 基础</span> </a><a href="/posts/b2e36861/" title="MySQL 常用 SQL" class="list-group-item list-group-item-action"><span class="category-post">MySQL 常用 SQL</span> </a><a href="/posts/31eec5f6/" title="MySQL 常用命令" class="list-group-item list-group-item-action"><span class="category-post">MySQL 常用命令</span> </a><a href="/posts/3aad583d/" title="MySQL 时区问题" class="list-group-item list-group-item-action"><span class="category-post">MySQL 时区问题</span> </a><a href="/posts/8c2abb3e/" title="MySQL 时间基本概念" class="list-group-item list-group-item-action"><span class="category-post">MySQL 时间基本概念</span> </a><a href="/posts/18ea587c/" title="MySQL 时间数据类型对照表" class="list-group-item list-group-item-action"><span class="category-post">MySQL 时间数据类型对照表</span> </a><a href="/posts/c24675b4/" title="MySQL 索引" class="list-group-item list-group-item-action"><span class="category-post">MySQL 索引</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Redis" id="heading-e111446745a1825b862f8727ae63bce4" role="tab" data-toggle="collapse" href="#collapse-e111446745a1825b862f8727ae63bce4" aria-expanded="true">Redis <span class="list-group-count">(2)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-e111446745a1825b862f8727ae63bce4" role="tabpanel" aria-labelledby="heading-e111446745a1825b862f8727ae63bce4"><div class="category-post-list"><a href="/posts/17835f44/" title="Redis 三种集群架构" class="list-group-item list-group-item-action active"><span class="category-post">Redis 三种集群架构</span> </a><a href="/posts/99f6ec28/" title="Redis 常用命令" class="list-group-item list-group-item-action"><span class="category-post">Redis 常用命令</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="容器" id="heading-22c799040acdb2601b437ed5449de076" role="tab" data-toggle="collapse" href="#collapse-22c799040acdb2601b437ed5449de076" aria-expanded="false">容器 <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-22c799040acdb2601b437ed5449de076" role="tabpanel" aria-labelledby="heading-22c799040acdb2601b437ed5449de076"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Jetty" id="heading-95dd2e7e150f2e8a04c35a78cb15b3e5" role="tab" data-toggle="collapse" href="#collapse-95dd2e7e150f2e8a04c35a78cb15b3e5" aria-expanded="false">Jetty <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-95dd2e7e150f2e8a04c35a78cb15b3e5" role="tabpanel" aria-labelledby="heading-95dd2e7e150f2e8a04c35a78cb15b3e5"><div class="category-post-list"><a href="/posts/849606ff/" title="Jetty 基础概念" class="list-group-item list-group-item-action"><span class="category-post">Jetty 基础概念</span></a></div></div></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="消息队列" id="heading-8bedb7aae7ae74964d0363a1556c7a59" role="tab" data-toggle="collapse" href="#collapse-8bedb7aae7ae74964d0363a1556c7a59" aria-expanded="false">消息队列 <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-8bedb7aae7ae74964d0363a1556c7a59" role="tabpanel" aria-labelledby="heading-8bedb7aae7ae74964d0363a1556c7a59"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="RabbitMQ" id="heading-7eaa993723e57b3bfc99923c196e2e17" role="tab" data-toggle="collapse" href="#collapse-7eaa993723e57b3bfc99923c196e2e17" aria-expanded="false">RabbitMQ <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-7eaa993723e57b3bfc99923c196e2e17" role="tabpanel" aria-labelledby="heading-7eaa993723e57b3bfc99923c196e2e17"><div class="category-post-list"><a href="/posts/8e078847/" title="RabbitMQ 详解" class="list-group-item list-group-item-action"><span class="category-post">RabbitMQ 详解</span></a></div></div></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Redis 三种集群架构</h1><p class="note note-info">本文最后更新于：2023年4月18日 晚上</p><div class="markdown-body"><h1 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h1><p>Redis基于Reactor模式开发了自己的网络事件处理器，被称为文件事件处理器，由套接字、I&#x2F;O多路复用程序、文件事件分派器（dispatcher），事件处理器四部分组成。</p><img src="/posts/17835f44/1733c64202a74236.jpg" srcset="/img/loading.gif" lazyload alt="img"><h2 id="redis为什么那么快"><a href="#redis为什么那么快" class="headerlink" title="redis为什么那么快"></a>redis为什么那么快</h2><ul><li>redis是纯内存操作：数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。</li><li>非阻塞I&#x2F;O：Redis采用epoll做为I&#x2F;O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I&#x2F;O上浪费过多的时间。</li><li>单线程避免了线程切换和竞态产生的消耗。</li></ul><h1 id="redis-三种集群模式"><a href="#redis-三种集群模式" class="headerlink" title="redis 三种集群模式"></a>redis 三种集群模式</h1><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6847902223913992200">redis系列之——分布式锁</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6847902224144662542">redis系列之——缓存穿透、缓存击穿、缓存雪崩</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6850418109493444621">redis系列之——Redis为什么这么快？</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6854573210080378888">redis系列之——数据持久化（RDB和AOF）</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6850418113830846471">redis系列之——一致性hash算法</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6850418111846449165">redis系列之——高可用（主从、哨兵、集群）</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6854573210927644679">redis系列之——事物及乐观锁</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6847902224148856845">redis系列之——数据类型geospatial：你隔壁有没有老王？</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6850418111049367560">redis系列之——数据类型bitmaps：今天你签到了吗？</a></p><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6850418111070339085">布隆过滤器是个啥！</a></p><p>所谓的高可用，也叫HA（High Availability），是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p><p>如果在实际生产中，如果redis只部署一个节点，当机器故障时，整改服务都不能提供服务了。这就是我们常说的单点故障。</p><p>如果redis部署了多台，当一台或几台故障时，整个系统依然可以对外提供服务，这样就提高了服务的可用性。</p><p>今天我们就聊聊redis高可用的三种模式：<strong>主从模式</strong>，<strong>哨兵模式</strong>，<strong>集群模式</strong>。</p><h2 id="一、主从模式"><a href="#一、主从模式" class="headerlink" title="一、主从模式"></a>一、主从模式</h2><p>一般，系统的高可用都是通过部署多台机器实现的。redis为了避免单点故障，也需要部署多台机器。</p><p>因为部署了多台机器，所以就会涉及到不同机器的的数据同步问题。</p><p>为此，redis提供了Redis提供了复制(replication)功能，当一台redis数据库中的数据发生了变化，这个变化会被自动的同步到其他的redis机器上去。</p><p>redis多机器部署时，这些机器节点会被分成两类，一类是主节点（master节点），一类是从节点（slave节点）。一般主节点可以进行读、写操作，而从节点只能进行读操作。同时由于主节点可以写，数据会发生变化，当主节点的数据发生变化时，会将变化的数据同步给从节点，这样从节点的数据就可以和主节点的数据保持一致了。一个主节点可以有多个从节点，但是一个从节点会只会有一个主节点，也就是所谓的一主多从结构。</p><img src="/posts/17835f44/format,png.png" srcset="/img/loading.gif" lazyload alt="一主多从"><h3 id="1-1-机器规划"><a href="#1-1-机器规划" class="headerlink" title="1.1.机器规划"></a>1.1.机器规划</h3><table><thead><tr><th>机器名称</th><th>IP</th><th>端口</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.10</td><td>6379</td></tr><tr><td>slave1</td><td>192.168.1.11</td><td>6379</td></tr><tr><td>slave2</td><td>192.168.1.12</td><td>6379</td></tr><tr><td>slave3</td><td>192.168.1.13</td><td>6379</td></tr></tbody></table><h3 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2.配置"></a>1.2.配置</h3><p><strong>主节点配置</strong></p><p>主节点按照正常的配置配好即可。</p><p><strong>从节点配置</strong></p><p>使用默认的配置启动机器，机器都是主节点。如果想要让机器变成从节点，需要在conf服务器上配置主从复制的相关参数。</p><ul><li>在从节点的配置文件redis.conf中指定主节点的信息（如果需要的话，可以配置主节点的登录密码，主从复制相关的参数）。三台从节点的配置是一样的。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置主节点的ip和端口</span><br>slaveof 192.168.1.10 6379<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从redis2.6开始，从节点默认是只读的</span><br>slave-read-only yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">假设主节点有登录密码，是123456</span><br>masterauth 123456<br></code></pre></td></tr></table></figure><ul><li>也可以不配置上面的文件，使用redis-server命令，在启动从节点时，通过参数–slaveof指定主节点是谁。。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./redis-server --slaveof 192.168.1.10 6379<br></code></pre></td></tr></table></figure><ul><li>也可以不配上面的文件，正常启动redis机器，然后通过<code>redis-cli</code>的命令行执行<code>slaveof 192.168.1.10 6379</code>指定主节点是谁。</li></ul><p>系统运行时，如果master挂掉了，可以在一个从库（如slave1）上手动执行命令<code>slaveof no one</code>，将slave1变成新的master；在slave2和slave3上分别执行<code>slaveof 192.168.1.11 6379</code> 将这两个机器的主节点指向的这个新的master；同时，挂掉的原master启动后作为新的slave也指向新的master上。</p><p>执行命令<code>slaveof no one</code>命令，可以关闭从服务器的复制功能。同时原来同步的所得的数据集都不会被丢弃。</p><h3 id="1-3-机器启动"><a href="#1-3-机器启动" class="headerlink" title="1.3.机器启动"></a>1.3.机器启动</h3><p>首先启动主节点，然后一台一台启动从节点。</p><h3 id="1-4-主从复制的机制"><a href="#1-4-主从复制的机制" class="headerlink" title="1.4.主从复制的机制"></a>1.4.主从复制的机制</h3><img src="/posts/17835f44/format,png-16815647991305.png" srcset="/img/loading.gif" lazyload alt="复制机制" style="zoom:67%"><ul><li>从数据库连接主数据库，发送SYNC命令;</li><li>主数据库接收到SYNC命令后，可以执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令;</li><li>主数据库BGSAVE执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令;</li><li>从数据库收到快照文件后丢弃所有旧数据，载入收到的快照;</li><li>主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令;</li><li>从数据库完成对快照的载入，开始接受命令请求，并执行来自主数据库缓冲区的写命令;(<strong>从数据库初始化完成</strong>)</li><li>主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令(<strong>从数据库初始化完成后的操作</strong>)</li><li>出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库，增量复制。</li><li><strong>主从刚刚连接的时候，进行全量同步;全同步结束后，进行增量同步</strong>。当然，如果有需要，slave在任何时候都可以发起全量同步。Redis的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li></ul><h3 id="1-5-主从模式的优缺点"><a href="#1-5-主从模式的优缺点" class="headerlink" title="1.5.主从模式的优缺点"></a>1.5.主从模式的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离;</li><li>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务依然必须由Master来完成;</li><li>Slave同样可以接受其他Slaves的连接和同步请求，这样可以有效地分载Master的同步压力;</li><li>Master是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求;</li><li>Slave同样是以阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复;</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性;</li><li>如果多个Slave断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要Slave启动，就会发送sync请求和主机全量同步，当多个Slave重启的时候，可能会导致Master IO剧增从而宕机。</li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂;</li><li>redis的主节点和从节点中的数据是一样的，降低的内存的可用性</li></ul><h2 id="二、哨兵模式"><a href="#二、哨兵模式" class="headerlink" title="二、哨兵模式"></a>二、哨兵模式</h2><p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master宕机，哨兵会自动选举master并将其他的slave指向新的master。</p><p>在主从模式下，redis同时提供了哨兵命令<code>redis-sentinel</code>，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵进程向所有的redis机器发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p>哨兵可以有多个，一般为了便于决策选举，使用奇数个哨兵。哨兵可以和redis机器部署在一起，也可以部署在其他的机器上。多个哨兵构成一个哨兵集群，哨兵直接也会相互通信，检查哨兵是否正常运行，同时发现master宕机哨兵之间会进行决策选举新的master</p><img src="/posts/17835f44/format,png-16815648179018.png" srcset="/img/loading.gif" lazyload alt="哨兵模式"><p>哨兵模式的作用:</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器;</li><li>当哨兵监测到master宕机，会自动将slave切换到master，然后通过<em>发布订阅模式</em>通过其他的从服务器，修改配置文件，让它们切换主机;</li><li>然而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</li></ul><p>哨兵很像kafka集群中的zookeeper的功能。</p><h3 id="2-1-机器规划"><a href="#2-1-机器规划" class="headerlink" title="2.1.机器规划"></a>2.1.机器规划</h3><table><thead><tr><th>机器名称</th><th>IP</th><th>端口</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.10</td><td>6379</td></tr><tr><td>slave 1</td><td>192.168.1.11</td><td>6379</td></tr><tr><td>slave 2</td><td>192.168.1.12</td><td>6379</td></tr><tr><td>slave 3</td><td>192.168.1.13</td><td>6379</td></tr><tr><td>sentinel 1</td><td>192.168.1.14</td><td>26379</td></tr><tr><td>sentinel 2</td><td>192.168.1.15</td><td>26379</td></tr><tr><td>sentinel 3</td><td>192.168.1.16</td><td>26379</td></tr></tbody></table><p>这里我们将哨兵进程和redis分别部署在不同的机器上，避免因为redis宕机导致sentinel进程不可用。</p><h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2.配置"></a>2.2.配置</h3><p>redis.conf的配置和上面主从模式一样，不用变。这里主要说一下哨兵的配置。</p><p>每台机器的哨兵进程都需要一个哨兵的配置文件<code>sentinel.conf</code>，三台机器的哨兵配置是一样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">禁止保护模式</span><br>protected-mode no<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">192.168.1.10代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span><br>sentinel monitor mymaster 192.168.1.10 6379 2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span><br>sentinel auth-pass mymaster 123456<br></code></pre></td></tr></table></figure><h3 id="2-3-机器启动"><a href="#2-3-机器启动" class="headerlink" title="2.3.机器启动"></a>2.3.机器启动</h3><p>首先启动主节点，然后一台一台启动从节点。</p><p>redis集群启动完成后，分别启动哨兵集群所在机器的三个哨兵，使用<code>redis-sentinel /path/to/sentinel.conf</code>命令。</p><h3 id="2-4-哨兵模式的工作"><a href="#2-4-哨兵模式的工作" class="headerlink" title="2.4.哨兵模式的工作"></a>2.4.哨兵模式的工作</h3><ul><li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）</li><li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态</li><li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）</li><li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li><li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li><li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li></ul><p>假设master宕机，sentinel 1先检测到这个结果，系统并不会马上进行 failover(故障转移)选出新的master，仅仅是sentinel 1主观的认为master不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由sentinel 1发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><h3 id="2-5-主从模式的优缺点"><a href="#2-5-主从模式的优缺点" class="headerlink" title="2.5.主从模式的优缺点"></a>2.5.主从模式的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。</li><li>主从可以自动切换，系统更健壮，可用性更高。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>具有主从模式的缺点，每台机器上的数据是一样的，内存的可用性较低。</li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li></ul><h2 id="三、集群模式"><a href="#三、集群模式" class="headerlink" title="三、集群模式"></a>三、集群模式</h2><p>先说一个误区：<strong>Redis的集群模式本身没有使用一致性hash算法，而是使用slots插槽</strong>。这是很多人的一个误区。这里先留个坑，后面我会出一期《 redis系列之——一致性hash算法》。</p><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容；</p><img src="/posts/17835f44/format,png-168156483733411.png" srcset="/img/loading.gif" lazyload alt="集群模式"><p>这里的6台redis两两之间并不是独立的，每个节点都会通过集群总线(cluster bus)，与其他的节点进行通信。通讯时使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是16379。nodes之间的通信采用特殊的二进制协议。</p><p>对客户端来说，整个cluster被看做是一个整体，客户端可以连接任意一个node进行操作，就像操作单一Redis实例一样，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node，这有点儿像浏览器页面的302 redirect跳转。</p><p>根据官方推荐，集群部署至少要 3 台以上的master节点，最好使用 3 主 3 从六个节点的模式。测试时，也可以在一台机器上部署这六个实例，通过端口区分出来。</p><h3 id="3-1-机器规划"><a href="#3-1-机器规划" class="headerlink" title="3.1.机器规划"></a>3.1.机器规划</h3><table><thead><tr><th>机器名称</th><th>IP</th><th>端口</th></tr></thead><tbody><tr><td>master 1</td><td>192.168.1.11</td><td>6379</td></tr><tr><td>master 2</td><td>192.168.1.12</td><td>6379</td></tr><tr><td>master 3</td><td>192.168.1.13</td><td>6379</td></tr><tr><td>slave 1</td><td>192.168.1.21</td><td>6379</td></tr><tr><td>slave 2</td><td>192.168.1.22</td><td>6379</td></tr><tr><td>slave 3</td><td>192.168.1.23</td><td>6379</td></tr></tbody></table><h3 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2.配置"></a>3.2.配置</h3><p>修改<code>redis.conf</code> 的配置文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启redis的集群模式</span><br>cluster-enabled yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置集群模式下的配置文件名称和位置,redis-cluster.conf这个文件是集群启动后自动生成的，不需要手动配置。</span><br>cluster-config-file redis-cluster.conf<br></code></pre></td></tr></table></figure><h3 id="3-3-机器启动"><a href="#3-3-机器启动" class="headerlink" title="3.3.机器启动"></a>3.3.机器启动</h3><p>6个 Redis 服务分别启动成功之后，这时虽然配置了集群开启，但是这六台机器还是独立的。使用集群管理命令将这6台机器添加到一个集群中。</p><p>借助 redis-tri.rb 工具可以快速的部署集群。</p><p>只需要执行<code>redis-trib.rb create --replicas 1 192.168.1.11:6379 192.168.1.21:6379 192.168.1.12:6379 192.168.1.22:6379 192.168.1.13:6379 192.168.1.23:6379</code>就可以成功创建集群。</p><p>该命令执行创建完成后会有响应的日志，通过相关的日志就可以看出集群中机器的关系(不一定和上图对应)，执行的日志如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing <span class="hljs-built_in">hash</span> slots allocation on 6 nodes...</span><br>Master[0] -&gt; Slots 0 - 5460<br>Master[1] -&gt; Slots 5461 - 10922<br>Master[2] -&gt; Slots 10923 - 16383<br>Adding replica 192.168.1.21:6379 to 192.168.1.11:6379<br>Adding replica 192.168.1.22:6379 to 192.168.1.12:6379<br>Adding replica 192.168.1.23:6379 to 192.168.1.13:6379<br>M: 80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.1.11:6379<br>   slots:[0-5460] (5461 slots) master<br>S: b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.1.21:6379<br>   replicates 6788453ee9a8d7f72b1d45a9093838efd0e501f1<br>M: 4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.1.12:6379<br>   slots:[5461-10922] (5462 slots) master<br>S: b6331cbc986794237c83ed2d5c30777c1551546e 192.168.1.22:6379<br>   replicates 80c80a3f3e33872c047a8328ad579b9bea001ad8<br>M: 6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.1.13:6379<br>   slots:[10923-16383] (5461 slots) master<br>S: 277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.1.23:6379<br>   replicates 4d74ec66e898bf09006dac86d4928f9fad81f373<br>Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes                  # 输入yes，接受上面配置<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Nodes configuration updated</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Assign a different config epoch to each node</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER MEET messages to <span class="hljs-built_in">join</span> the cluster</span><br></code></pre></td></tr></table></figure><p>执行完成后自动生成配置的redis-cluster.conf文件。</p><p>登录集群：<code>redis-cli -c -h 192.168.1.11 -p 6379 -a 123456 # -c，使用集群方式登录</code>。</p><p>查看集群信息：<code>192.168.1.11:6379&gt; CLUSTER INFO #集群状态</code>。</p><p>列出节点信息：<code>192.168.1.11:6379&gt; CLUSTER NODES #列出节点信息</code>。</p><p>添加数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.1.11:6379&gt; set name aaa<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [13680] located at 192.168.1.13:6379                <span class="hljs-comment"># 说明最终将数据写到了192.168.1.13:6379上</span></span><br>OK<br></code></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.1.11:6379&gt; get name<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [13680] located at 192.168.1.13:6379                <span class="hljs-comment"># 说明最终到192.168.1.13:6379上读数据</span></span><br>&quot;aaa&quot;<br></code></pre></td></tr></table></figure><h3 id="3-4-运行机制"><a href="#3-4-运行机制" class="headerlink" title="3.4.运行机制"></a>3.4.运行机制</h3><p>在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383，可以从上面<code>redis-trib.rb</code>执行的结果看到这16383个slot在三个master上的分布。还有一个就是cluster，可以理解为是一个集群管理的插件，类似的哨兵。</p><p>当我们的存取的 Key到达的时候，Redis 会根据 crc16的算法对计算后得出一个结果，然后把结果和16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p><p>当数据写入到对应的master节点后，这个数据会同步给这个master对应的所有slave节点。</p><p>为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点。当其它主节点ping主节点master 1时，如果半数以上的主节点与master 1通信超时，那么认为master 1宕机了，就会启用master 1的从节点slave 1，将slave 1变成主节点继续提供服务。</p><p>如果master 1和它的从节点slave 1都宕机了，整个集群就会进入fail状态，因为集群的slot映射不完整。如果集群超过半数以上的master挂掉，无论是否有slave，集群都会进入fail状态。</p><p>redis-cluster采用去中心化的思想，没有中心节点的说法，客户端与Redis节点直连，不需要中间代理层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</p><h3 id="3-5-集群扩缩容"><a href="#3-5-集群扩缩容" class="headerlink" title="3.5.集群扩缩容"></a>3.5.集群扩缩容</h3><p>对redis集群的扩容就是向集群中添加机器，缩容就是从集群中删除机器，并重新将16383个slots分配到集群中的节点上（数据迁移）。</p><p>扩缩容也是使用集群管理工具 redis-tri.rb。</p><p>扩容时，先使用<code>redis-tri.rb add-node</code>将新的机器加到集群中，这是新机器虽然已经在集群中了，但是没有分配slots，依然是不起做用的。在使用 <code>redis-tri.rb reshard</code>进行分片重哈希（数据迁移），将旧节点上的slots分配到新节点上后，新节点才能起作用。</p><p>缩容时，先要使用 <code>redis-tri.rb reshard</code>移除的机器上的slots，然后使用<code>redis-tri.rb add-del</code>移除机器。</p><h3 id="3-8-集群模式的优缺点"><a href="#3-8-集群模式的优缺点" class="headerlink" title="3.8.集群模式的优缺点"></a>3.8.集群模式的优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>采用去中心化思想，数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布;</p><p>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除;</p><p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升;</p><p>降低运维成本，提高系统的扩展性和可用性。</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>1.Redis Cluster是无中心节点的集群架构，依靠Goss协议(谣言传播)协同自动化修复集群的状态</p><p>但 GosSIp有消息延时和消息冗余的问题，在集群节点数量过多的时候，节点之间需要不断进行 PING&#x2F;PANG通讯，不必须要的流量占用了大量的网络资源。虽然Reds4.0对此进行了优化，但这个问题仍然存在。</p><p>2.数据迁移问题</p><p>Redis Cluster可以进行节点的动态扩容缩容，这一过程，在目前实现中，还处于半自动状态，需要人工介入。在扩缩容的时候，需要进行数据迁移。</p><p>而 Redis为了保证迁移的一致性，迁移所有操作都是同步操作，执行迁移时，两端的 Redis均会进入时长不等的阻塞状态，对于小Key，该时间可以忽略不计，但如果一旦Key的内存使用过大，严重的时候会接触发集群内的故障转移，造成不必要的切换。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>主从模式：master节点挂掉后，需要手动指定新的master，可用性不高，基本不用。</p><p>哨兵模式：master节点挂掉后，哨兵进程会主动选举新的master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。</p><p>集群模式：数据量比较大，QPS要求较高的时候使用。 <strong>Redis Cluster是Redis 3.0以后才正式推出，时间较晚，目前能证明在大规模生产环境下成功的案例还不是很多，需要时间检验。</strong></p><p>完成，收工！</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="category-chain-item">中间件</a> <span>></span> <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/" class="category-chain-item">Redis</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/Redis/">#Redis</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>