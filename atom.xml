<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yahya的博客</title>
  
  <subtitle>学习笔记</subtitle>
  <link href="https://blog.yahyav2rayssr.top/atom.xml" rel="self"/>
  
  <link href="https://blog.yahyav2rayssr.top/"/>
  <updated>2023-04-16T14:13:45.201Z</updated>
  <id>https://blog.yahyav2rayssr.top/</id>
  
  <author>
    <name>Yahya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 基础</title>
    <link href="https://blog.yahyav2rayssr.top/posts/a019e08c/"/>
    <id>https://blog.yahyav2rayssr.top/posts/a019e08c/</id>
    <published>2023-04-16T14:13:45.201Z</published>
    <updated>2023-04-16T14:13:45.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote><p>注：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的</p></blockquote><p>如果在静态方法的声明中加上final，则表示该方法不会被子类的方法隐藏。</p><p>final参数不可以赋值，因为在调用方法时，已经对其赋值了。</p><p><strong>用final修饰的字符串就是在编译期可知的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lan&quot;</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;tao&quot;</span>;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b + <span class="hljs-string">&quot;2019&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面即使是引用拼接，由于编译期可知，执行效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lantao2019&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static方法：</p><ol><li>不可被子类重写（如果子类含有相同静态方法则与父类的静态方法无关）；</li><li>直接以类名调用，也可以使用实例调用(避免)；</li><li>没有this，因为不依赖于任何实例对象；</li><li>不能访问非静态成员变量与非静态成员方法；</li><li>static方法必须实现，也就是说他不能是抽象方法abstract；</li></ol><blockquote><p>使用情景：方法不需要访问对象状态，其所需参数均显示参数提供；只需要访问静态域；</p></blockquote><h2 id="List线程安全化"><a href="#List线程安全化" class="headerlink" title="List线程安全化"></a>List线程安全化</h2><h3 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList"></a>Collections.synchronizedList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>      ...<br>  <span class="hljs-keyword">synchronized</span> (list) &#123;<br>      <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.iterator(); <span class="hljs-comment">// Must be in synchronized block</span><br>      <span class="hljs-keyword">while</span> (i.hasNext())<br>          foo(i.next());<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>既然封装类内部已经加了对象锁，为什么外部还要加一层对象锁？</strong></p><p>看源码可知，Collections.synchronizedList中很多方法，比如equals,hasCode,get,set,add,remove,indexOf,lastIndexOf……</p><p>都添加了锁，但是List中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CopyIterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>这个方法没有加锁，不是线程安全的，所以如果要遍历，还是必须要在外面加一层锁。</p><p><strong>SynchronizedList和Vector最主要的区别</strong></p><ol><li>Vector扩容为原来的2倍长度，ArrayList扩容为原来1.5倍</li><li>SynchronizedList有很好的扩展和兼容功能。他可以将所有的List的子类转成线程安全的类。</li><li><strong>使用SynchronizedList的时候，进行遍历时要手动进行同步处理 。</strong></li><li>SynchronizedList可以指定锁定的对象。</li></ol><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList是ArrayList的线程安全版本，从他的名字可以推测，CopyOnWriteArrayList是在有写操作的时候会copy一份数据，然后写完再设置成新的数据。CopyOnWriteArrayList适用于读多写少的并发场景。</p><blockquote><h5 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h5><p>所谓写时复制（copy-on-write），是在对集合进行“写”操作时，在内部将数据结构全部复制一份的机制。使用这种机制后，即使在多个线程发生读写冲突时ConcurrentModificationException异常也不会被抛出。</p></blockquote><h2 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列与栈是相对的一种数据结构。只允许在一端进行插入操作，而在另一端进行删除操作的线性表。栈的特点是后进先出，而队列的特点是先进先出。队列的用处很大，但大多都是在其他的数据结构中，比如，树的按层遍历，图的广度优先搜索等都需要使用队列做为辅助数据结构。</p><h4 id="单向队列"><a href="#单向队列" class="headerlink" title="单向队列"></a>单向队列</h4><p>  单向队列比较简单，只能向队尾添加元素，从队头删除元素。</p><h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><p>  如果一个队列的头和尾都支持元素入队，出队，那么这种队列就称为双向队列，英文是Deque。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//插入（抛出异常）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-comment">//插入（返回特殊值）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-comment">//移除（抛出异常）</span><br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//移除（返回特殊值）</span><br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//检查（抛出异常）</span><br>    E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//检查（返回特殊值）</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue又叫做优先级队列，保存队列元素的顺序不是按照及加入队列的顺序，而是按照队列元素的大小进行重新排序。一句话概括，PriorityQueue使用了一个高效的数据结构：堆。底层是使用数组保存数据。还会进行排序，优先将元素的最小值存到队头。</p><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p>Deque接口是Queue接口子接口。它代表一个双端队列。</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>ArrayDeque使用数组实现的Deque;底层是数组，也是可以指定它的capacity,当然也可以不指定，默认长度是16，根据添加的元素个数，动态扩容。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是一种队列，一种可以在多线程环境下使用，并且支持阻塞等待的队列。也就是说，阻塞队列和一般的队列的区别就在于：</p><ol><li>多线程环境支持，多个线程可以安全的访问队列</li><li>支持生产和消费等待，多个线程之间互相配合，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线程就会阻塞直到队列不满。</li></ol><p>根据插入和取出两种类型的操作，具体分为下面一些类型：</p><table><thead><tr><th>操作类型</th><th>Throws Exception</th><th>Special Value</th><th>Timed out</th><th>Blocked</th></tr></thead><tbody><tr><td>插入</td><td>add(o)</td><td>offer(o)</td><td>offer(o, timeout, unit)</td><td>put(o)</td></tr><tr><td>取出(删除)</td><td>remove(o)</td><td>poll()</td><td>poll(timeout, unit)</td><td>take()</td></tr></tbody></table><ul><li>Throws Exception 类型的插入和取出在不能立即被执行的时候就会抛出异常。</li><li>Special Value 类型的插入和取出在不能被立即执行的情况下会返回一个特殊的值（true 或者 false）。</li><li>Blocked 类型的插入和取出操作在不能被立即执行的时候会阻塞线程直到可以操作的时候会被其他线程唤醒。</li><li>Timed out 类型的插入和取出操作在不能立即执行的时候会被阻塞一定的时候，如果在指定的时间内没有被执行，那么会返回一个特殊值。</li></ul><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><img src="/posts/a019e08c/51.jpg" class><p>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p><p><strong>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行</strong>，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。</p><p><strong>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例</strong>，<strong>而后者则会生成一个额外的Node对象</strong>。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其 <strong>对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能</strong>。 作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue是一个优先阻塞队列。所谓优先队列，就是每次从队队列里面获取到的都是队列中优先级最高的，对于优先级，PriorityBlockingQueue需要你为插入其中的元素类型提供一个Comparator，PriorityBlockingQueue使用这个Comparator来确定元素之间的优先级关系。</p><p>但需要注意的是<strong>PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong>。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>SynchronousQueue和前面分析的阻塞队列都不同，因为SynchronousQueue不存在容量的说法，任何插入操作都需要等待其他线程来消费，否则就会阻塞等待，也就是说，生产线程生产出一条数据之后就要等待消费者线程来将其消费掉，才能继续生产数据，否则就会阻塞等待消费。</p><h5 id="TransferQueue（公平模式）"><a href="#TransferQueue（公平模式）" class="headerlink" title="TransferQueue（公平模式）"></a>TransferQueue（公平模式）</h5><p>该队列可以创建生产者和消费者程序并协调消息从生产者传输到消费者。</p><p>该实现类似于<a href="https://blog.csdn.net/neweastsun/article/details/87907890">BlockingQueue</a>类，但其可以实现反压形式传输，即当生产者利用transfer()方法发送消息给消费者时，生产者将一直被阻塞，直到消息被使用为止。</p><h5 id="TransferStack（非公平模式）"><a href="#TransferStack（非公平模式）" class="headerlink" title="TransferStack（非公平模式）"></a>TransferStack（非公平模式）</h5><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>并编程中，一般需要用到安全的队列，如果要自己实现安全队列，可以使用2种方式：</p><ul><li>加锁，这种实现方式就是我们常说的阻塞队列。</li><li>使用循环CAS算法实现，这种方式实现队列称之为非阻塞队列。</li></ul><p>ConcurrentLinkedQueue 是一个基于链接节点的<strong>无界线</strong>程安全的队列，按照先进先出原则对元素进行排序。新元素从队列尾部插入，而获取队列元素，则需要从队列头部获取；内部的数据结构是分开的，线程之间互不影响，所以也就无需执行互斥处理。</p><h5 id="ConcurrentLinkedQueue使用约定："><a href="#ConcurrentLinkedQueue使用约定：" class="headerlink" title="ConcurrentLinkedQueue使用约定："></a>ConcurrentLinkedQueue使用约定：</h5><ul><li>不允许null入列</li><li>在入队的最后一个元素的next为null</li><li>队列中所有未删除的节点的item都不能为null且都能从head节点遍历到</li><li>删除节点是将item设置为null, 队列迭代时跳过item为null节点</li><li>head节点跟tail不一定指向头节点或尾节点，可能存在滞后性</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>入列出列线程安全，遍历不安全</li><li>不允许添加null元素</li><li>底层使用列表与CAS算法保证入列出列安全</li></ol><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>java.util.concurrent.Exchanger 类用于让两个线程安全的交换对象。</p><h2 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h2><h3 id="Executors-newFixedThreadPool方法"><a href="#Executors-newFixedThreadPool方法" class="headerlink" title="Executors.newFixedThreadPool方法"></a>Executors.newFixedThreadPool方法</h3><p>Executors.newFixedThreadPool方法会创建一个线程池，该线程池会创建个数由参数指定的工人线程，而且创建出的线程会被重复利用。如果在这个方法的参数中加上ThreadFactory对象，则线程池会使用该ThreadFactory来创建新的工人线程。</p><h3 id="Executors-newCachedThreadPool方法"><a href="#Executors-newCachedThreadPool方法" class="headerlink" title="Executors.newCachedThreadPool方法"></a>Executors.newCachedThreadPool方法</h3><p>Executors.newCachedThreadPool方法会创建一个线城市，该线程池可以根据需要自动创建工人线程，而且创建的工人线程会被重复利用。没有工作的工人线程会在缓存约60秒后自动终止。如果像这个方法的参数中传入ThreadFactory对象，则线程池会使用这个ThreadFactory来创建新的工人线程。</p><h3 id="Executors-newScheduledThreadPool方法"><a href="#Executors-newScheduledThreadPool方法" class="headerlink" title="Executors.newScheduledThreadPool方法"></a>Executors.newScheduledThreadPool方法</h3><blockquote><p>推荐使用<code>newScheduledThreadPool</code>代替 <code>Timer</code>对象</p><p>因为不会收到异常中断的影响</p></blockquote><p>Executors.newScheduledThreadPool方法会创建一个线程池，该线程池可以在一定时间后执行请求或是反复执行请求。即使在没有请求时也需要保存的线程数量可以通过参数指定。此外，如果在这个方法的参数中加上ThreadFactory对象，则线程池会使用这个ThreadFactory来创建新的工人线程。</p><h2 id="5种创建对象的方法："><a href="#5种创建对象的方法：" class="headerlink" title="5种创建对象的方法："></a>5种创建对象的方法：</h2><ol><li>使用new关键字</li><li>Class对象的newInstance()方法</li><li>构造函数对象的newInstance()方法</li><li>对象反序列化</li><li>Object对象的clone()方法</li></ol><h3 id="1-使用new关键字"><a href="#1-使用new关键字" class="headerlink" title="1. 使用new关键字"></a><strong>1. 使用new关键字</strong></h3><p>这是最常用也最简单的方式，看看下面这个例子就知道了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_ invoke__">Test</span>() &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_ invoke__">Test</span>(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_ invoke__">getName</span>() &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">setName</span>(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">main</span>(String[] args) &#123;<br>        Test t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        Test t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Class对象的newInstance-方法"><a href="#2-Class对象的newInstance-方法" class="headerlink" title="2. Class对象的newInstance()方法"></a><strong>2. Class对象的newInstance()方法</strong></h3><p>还是上面的Test对象，首先我们通过Class.forName()动态的加载类的Class对象，然后通过newInstance()方法获得Test类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;org.b3log.solo.util.Test&quot;</span>;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">clasz</span> <span class="hljs-operator">=</span> Class.forName(className);<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (Test) clasz.newInstance();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-构造函数对象的newInstance-方法"><a href="#3-构造函数对象的newInstance-方法" class="headerlink" title="3. 构造函数对象的newInstance()方法"></a><strong>3. 构造函数对象的newInstance()方法</strong></h3><p>类Constructor也有newInstance方法，这一点和Class有点像。从它的名字可以看出它与Class的不同，Class是通过类来创建对象，而Constructor则是通过构造器。我们依然使用第一个例子中的Test类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Constructor&lt;Test&gt; constructor;<br>   <span class="hljs-keyword">try</span> &#123;<br>        constructor = Test.class.getConstructor();<br>       <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> constructor.newInstance();<br>   &#125; <span class="hljs-keyword">catch</span> (InstantiationException |<br>        IllegalAccessException |<br>        IllegalArgumentException |<br>        InvocationTargetException |<br>        NoSuchMethodException |<br>        SecurityException e) &#123;<br>        e.printStackTrace();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-对象反序列化"><a href="#4-对象反序列化" class="headerlink" title="4. 对象反序列化"></a><strong>4. 对象反序列化</strong></h3><p>使用反序列化来获得类的对象，那么这里必然要用到序列化Serializable接口，所以这里我们将第一个例子中的Test作出一点改变，那就是实现序列化接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sample.txt&quot;</span>;<br>     <span class="hljs-type">Test</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>     <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath);<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fileOutputStream);<br>        outputStream.writeObject(t1);<br>        outputStream.flush();<br>        outputStream.close();<br><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fileInputStream);<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> (Test) inputStream.readObject();<br>        inputStream.close();<br>        System.out.println(t2.getName());<br>     &#125; <span class="hljs-keyword">catch</span> (Exception ee) &#123;<br>           ee.printStackTrace();<br>     &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-Object对象的clone-方法"><a href="#5-Object对象的clone-方法" class="headerlink" title="5. Object对象的clone()方法"></a><strong>5. Object对象的clone()方法</strong></h3><p>Object对象中存在clone方法，它的作用是创建一个对象的副本。看下面的例子，这里我们依然使用第一个例子的Test类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> (Test) t1.clone();<br>    System.out.println(t2.getName());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a><strong>happens-before原则</strong></h2><p>　　Java内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>　　下面是Java内存模型下一些”天然的“happens-before关系，这些happens-before关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。</p><p>　　a. 程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。</p><p>　　b. 管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。</p><p>　　c. volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。</p><p>　　d. 线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。</p><p>　　e. 线程终止规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。</p><p>　　f. 线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。</p><p>　　g. 对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。</p><p>　　h. 传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>CAS，是 compare and swap 的缩写，即比较并交换。它是一种基于乐观锁的操作。它有三个操作数，内存值V，预期值A，更新值B。当且仅当A和V相同时，才会把V修改成B，否则什么都不做。之前说到AtomicInteger用到了CAS，那么先从这个类说起。看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">5</span>);<br>        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>,<span class="hljs-number">50</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>AtomicInteger有一个compareAndSet方法，有两个操作数，第一个是期望值，第二个是希望修改成的值。首先初始值是5，第一次调用compareAndSet方法的时候，将5拷贝回自己的工作空间，然后改成50，写回到主内存中的时候，它期望主内存中的值是5，而这时确实也是5，所以可以修改成功，主内存中的值也变成了50，输出true。第二次调用compareAndSet的时候，在自己的工作内存将值修改成100，写回去的时候，希望主内存中的值是5，但是此时是50，所以set失败，输出false。这就是比较并交换，也即CAS。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>简而言之，CAS工作原理就是<strong>UnSafe类</strong>和<strong>自旋锁</strong>。</p><p><strong>1、UnSafe类：</strong><br> UnSafe类在jdk的rt.jar下面的一个类，全包名是sun.misc.UnSafe。这个类大多数方法都是native方法。由于Java不能操作计算机系统，所以设计之初就留了一个UnSafe类。通过UnSafe类，Java就可以操作指定内存地址的数据。调用UnSafe类的CAS，JVM会帮我们实现出汇编指令，从而实现原子操作。现在就来分析一下AtomicInteger的getAndIncrement方法是怎么工作的。看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> U.getAndAddInt(<span class="hljs-built_in">this</span>, VALUE, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@HotSpotIntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(o, offset);<br>    &#125; <span class="hljs-keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的o就是当前对象，offset是内存地址，delta是1，也就是自增步伐。首先把当前对象主内存中的值赋给v，然后进入while循环。判断当前对象此刻主内存中的值是否等于v，如果是，就自增，否则继续循环，重新获取v的值。这里的compareAndSwapInt方法就是一个native方法，这个方法汇编之后是CPU原语指令，原语指令是连续执行不会被打断的，所以可以保证原子性。</p><p><strong>2、自旋锁：</strong><br>所谓的自旋，其实就是上面getAndAddInt方法中的do while循环操作。当预期值和主内存中的值不等时，就重新获取主内存中的值，这就是自旋。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>1、循环时间长，开销大。</strong><br> synchronized是加锁，同一时间只能一个线程访问，并发性不好。而CAS并发性提高了，但是由于CAS存在自旋操作，即do while循环，如果CAS失败，会一直进行尝试。如果CAS长时间不成功，会给CPU带来很大的开销。</p><p><strong>2、只能保证一个共享变量的原子性。</strong><br> 上面也看到了，getAndAddInt方法的o是代表当前对象，所以它也就是能保证这一个共享变量的原子性。如果要保证多个，那只能加锁了。</p><p><strong>3、引来的ABA问题。</strong></p><ul><li><strong>什么是ABA问题？</strong></li></ul><p>假设现在主内存中的值是A，现有t1和t2两个线程去对其进行操作。t1和t2先将A拷贝回自己的工作内存。这个时候t2线程将A改成B，刷回到主内存。此刻主内存和t2的工作内存中的值都是B。接下来还是t2线程抢到执行权，t2又把B改回A，并刷回到主内存。这时t1终于抢到执行权了，自己工作内存中的值的A，主内存也是A，因此它认为没人修改过，就在工作内存中把A改成了X，然后刷回主内存。也就是说，在t1线程执行前，t2将主内存中的值由A改成B再改回A。这便是ABA问题。看下面的代码演示(代码涉及到原子引用，请参考下面的原子引用的介绍)：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">ABADemo</span> &#123;<br>   <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>&#123;<br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>              atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>);<br>              atomicReference.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>);<br>              &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123; <br>                   TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace(); <br>              &#125;<br>              System.<span class="hljs-keyword">out</span>.println(atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>) <br>                                           + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.<span class="hljs-keyword">get</span>());<br>              &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码执行结果是”true C”，这就证明了ABA问题的存在。如果一个业务只管开头和结果，不管这个A中间是否变过，那么出现了ABA问题也没事。如果需要A还是最开始的那个A，中间不许别人动手脚，那么就要规避ABA问题。要解决ABA问题，先看下面的原子引用的介绍。</p><ul><li><strong>原子引用：</strong></li></ul><p>JUC包下给我们提供了原子包装类，像AtomicInteger。如果我不仅仅想要原子包装类，我自己定义的User类也想具有原子操作，怎么办呢？JUC为我们提供了AtomicReference<V>，即原子引用。看下面的代码：</V></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-built_in">int</span> age;<br>    <span class="hljs-built_in">String</span> name;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args)&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();<br>        atomicReference.<span class="hljs-keyword">set</span>(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像这样，就把User类变成了原子User类了。</p><ul><li><strong>解决ABA问题思路：</strong></li></ul><p>我们可以这个共享变量带上一个版本号。比如现在主内存中的是A，版本号是1，然后t1和t2线程拷贝一份到自己工作内存。t2将A改为B，刷回主内存。此时主内存中的是B，版本号为2。然后再t2再改回A，此时主内存中的是A，版本号为3。这个时候t1线程终于来了，自己工作内存是A，版本号是1，主内存中是A，但是版本号为3，它就知道已经有人动过手脚了。那么这个版本号从何而来，这就要说说AtomicStampedReference这个类了。</p><ul><li><strong>带时间戳的原子引用(AtomicStampedReference)：</strong><br>这个时间戳就理解为版本号就行了。看如下代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ABADemo</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// 睡一秒，让t1线程拿到最初的版本号</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, atomicReference.getStamp(), atomicReference.getStamp() + <span class="hljs-number">1</span>);<br>            atomicReference.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, atomicReference.getStamp(), atomicReference.getStamp() + <span class="hljs-number">1</span>);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicReference.getStamp(); <span class="hljs-comment">// 拿到最开始的版本号</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); <span class="hljs-comment">// 睡3秒，让t2线程的ABA操作执行完</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始版本号为1，t2线程每执行一次版本号加。等t1线程执行的时候，发现当前版本号不是自己一开始拿到的1了，所以set失败，输出false。这就解决了ABA问题。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>什么是CAS?  —— 比较并交换，主内存值和工作内存值相同，就set为更新值。</li><li>CAS原理是什么？ —— UnSafe类和自旋锁。理解那个do while循环。</li><li>CAS缺点是什么？ —— 循环时间长会消耗大量CPU资源；只能保证一个共享变量的原子性操作；造成ABA问题。</li><li>什么是ABA问题？ —— t2线程先将A改成B，再改回A，此时t1线程以为没人修改过。</li><li>如何解决ABA问题？—— 使用带时间戳的原子引用。</li></ol><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>所谓的重排序，英文记作Reorder，是指编译器和Java虚拟机通过改变程序的处理顺序来优化程序。虽然重排序被广泛用于提高性能，不过开发人员几乎不会意识到这一点。实际上，在运行单线程程序时我们无法判断是否进行了重排序。这是因为，虽然处理顺序改变了，但是规范上有很多限制可以避免程序出现运行错误。</p><blockquote><p>没有同步的状态为“存在数据竞争”。</p></blockquote><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><img src="/posts/a019e08c/81.png" alt="image-20200709205146965" style="zoom:50%;"><p>重排序可能导致x&lt;y</p><img src="/posts/a019e08c/82.png" alt="image-20200709205234341" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Something</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        x = <span class="hljs-number">100</span>;<br>        y = <span class="hljs-number">50</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; y) &#123;<br>            System.out.println(<span class="hljs-string">&quot;x &lt; y&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;x &gt; y&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Something</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Something</span>();<br><br>        <span class="hljs-comment">// 写数据的线程A</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                obj.write();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 读数据的线程B</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                obj.read();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>假设线程A将某个值写入了字段X中，而线程B读取到了该值。我们称其为“线程A向X的写值对线程B是可见的（visible）”。“是否是可见的”这个性质就成为可见性，英文记作visibility。</p><h2 id="共享内存（堆）"><a href="#共享内存（堆）" class="headerlink" title="共享内存（堆）"></a>共享内存（堆）</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>共享内存是所有线程共享的存储空间，也被称为堆内存（heap memory）。因为实例会被全部保存在共享内存中，所以实例中的字段也存在于共享内存中。此外，<strong>数据的元素</strong>也被保存在共享内存中。也就是说，可以使用new在共享内存中分配存储空间。</p><p>局部变量不会被保存在共享内存中。通常，除局部变量外，方法的形参，catch语句块中编写的异常处理器的参数等也不会被保存在共享内存中，而是被保存在各个线程特有的栈中。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized（lock&#x2F;unlock操作）并不仅仅进行线程的互斥处理。<strong>Java内存模型确保了某个线程在进行unlockM操作前进行的所有写入操作对进行lockM操作的线程都是可见的。</strong></p><img src="/posts/a019e08c/83.png" alt="image-20200709213538876" style="zoom:50%;"><ul><li>进行unlock操作后，写入缓存中的内容会被强制地写入共享内存中</li><li>进行lock操作后，缓存中的内容会先失效，然后共享内存中的最新内存会被强制重新读取到缓存中</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile write操作时是一种release，而volatile read操作是一种acquire。</p><table><thead><tr><th>release</th><th>acquire</th></tr></thead><tbody><tr><td>volatile write</td><td>volatile read</td></tr><tr><td>unlock</td><td>lock</td></tr><tr><td>线程的启动（start）</td><td>线程启动后的第一个操作</td></tr><tr><td>线程终止前的最后一个操作</td><td>检测线程的终止（join、isAlive）</td></tr><tr><td>中断（interrupt）</td><td>检测中断（isInterrupted、Thread.interrupted、InterruptException）</td></tr><tr><td>向字段写入默认值</td><td>线程的第一个操作</td></tr></tbody></table><ul><li><p>volatile字段的赋值语句的位置很重要</p><p>volatile字段放在最后才可以保证上面声明的变量的值能够被写入主内存。</p></li><li><p>volatile不会进行线程的互斥处理</p><p>访问volatile字段的线程不会进入等待队列。</p></li><li><p>访问volatile字段会产生性能开销</p><p>访问volatile字段与synchronized的处理耗费的时间几乎相同。</p></li></ul><blockquote><p>对long和double的原子操作</p><p>Java规范无法确保对long和double的赋值操作的原子性。但是，即使是long和double的字段，只要它是volatile字段，就可以确保赋值操作的原子性。</p></blockquote><h2 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h2><p>使用final关键字声明的字段（final字段）只能被初始化一次。</p><p>final字段的初始化只能在“字段声明时”或是“构造函数中”进行。那么，当final字段的初始化结束后，无论在任何时候，它的值对其他线程都是可见的（变成visible）。Java内存模型可以确保被初始化后的final字段在构造函数的处理结束后是可见的。</p><p>Java内存模型可以确保final字段在构造函数执行结束后可以正确的被看到。这样就不再需要通过synchronized和volatile进行同步了。</p><h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><table><thead><tr><th align="left">操作符</th><th align="left">补齐方式</th><th align="left">结果符号</th></tr></thead><tbody><tr><td align="left">&lt;&lt;</td><td align="left">右边用 0 补齐</td><td align="left">和原操作数没有绝对关系，取决于左移后符号位。</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">左边有原符号位补齐</td><td align="left">和原操作数有相同符号。</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">左边用 0 补齐</td><td align="left">和原操作数无关，一直为正数。</td></tr></tbody></table><h2 id="Java-常见的七大设计原则"><a href="#Java-常见的七大设计原则" class="headerlink" title="Java 常见的七大设计原则"></a>Java 常见的七大设计原则</h2><p>Java常见的设计开发原则，能够帮助我们更好的理解软件设计的方式方法，更方便进行代码的维护以及写出高质量的代码。</p><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1. 开闭原则"></a>1. 开闭原则</h3><p>对扩展开放，对修改关闭。尽量不要修改已有的能够稳定运行的代码，在原有的基础上进行拓展，增加新的功能，避免影响原有功能。</p><h3 id="2-单一职责原则"><a href="#2-单一职责原则" class="headerlink" title="2. 单一职责原则"></a>2. 单一职责原则</h3><p>一个类尽量实现一种功能或者提供一种服务。如果类里包含的功能特别多，在后面需要扩展或者修改的时候就要重新修改该类，容易影响代码的稳定性，维护起来也不方便。</p><h3 id="3-迪米特原则"><a href="#3-迪米特原则" class="headerlink" title="3. 迪米特原则"></a>3. 迪米特原则</h3><p>也叫最小知道原则，即如果某类A与类B可以没有直接的联系，尽量不要在A中出现B类。这样能够减少代码的耦合度，提高代码的健壮性。</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><p>客户端尽量不要依赖它不需要的接口，在设计接口的时候尽量方法少一些，不要建立非常臃肿的接口。接口功能越细化，系统的灵活性就越高，但是也不能越少越好，尽量细化接口及其方法即可。</p><h3 id="5-里氏替换原则"><a href="#5-里氏替换原则" class="headerlink" title="5. 里氏替换原则"></a>5. 里氏替换原则</h3><p>即在任何出现父类的地方，都可以用自子类替代。只有这样，基类才能够被复用，这也是开闭原则的补充。子类可以在父类的基础上扩展新的功能。反过来，在使用子类的地方不能使用父类，因为父类不一定具有子类的新功能。</p><h3 id="6-依赖倒置原则"><a href="#6-依赖倒置原则" class="headerlink" title="6. 依赖倒置原则"></a>6. 依赖倒置原则</h3><p>即程序要依赖抽象，而不是依赖实现。<br>这要去我们的在代码方法的参数或者对象关联时，尽量用高层次的抽象类，而不是具体的实现类。其本质就是面向接口编程。</p><h3 id="7-聚合-x2F-组合复用原则"><a href="#7-聚合-x2F-组合复用原则" class="headerlink" title="7. 聚合&#x2F;组合复用原则"></a>7. 聚合&#x2F;组合复用原则</h3><p>即尽量用聚合&#x2F;组合的方式去复用功能，尽量不要通过继承来达到复用的功能。因为继承关系中，如果基类的功能需要修改，那么子类的功能也可能受到影响。如果使用聚合&#x2F;组合的关系，类的关系不像继承那样耦合度那么高，而且聚合&#x2F;组合可以在运行时动态的进行，新对象可以动态的引用与原有类同样功能的其他对象。</p><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>对于一个类而言，按照如下顺序执行：</p><ol><li>执行静态代码块</li><li>执行构造代码块</li><li>执行构造函数</li></ol><p>对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt; 构造器</p><p>当涉及到继承时，按照如下顺序执行：</p><ol><li>执行父类的静态代码块，并初始化父类静态成员变量</li><li>执行子类的静态代码块，并初始化子类静态成员变量</li><li>执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量</li><li>执行子类的构造代码块， 执行子类的构造函数，并初始化子类普通成员变量</li></ol><img src="/posts/a019e08c/120.png" class><h2 id="生成实例的方法"><a href="#生成实例的方法" class="headerlink" title="生成实例的方法"></a>生成实例的方法</h2><ul><li>new</li><li>clone</li><li>newInstance</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&amp;（按位与）</td><td>1&amp;1&#x3D;1 , 1&amp;0&#x3D;0 , 0&amp;1&#x3D;0 , 0&amp;0&#x3D;0</td></tr><tr><td>|（按位或）</td><td>1|1&#x3D;1 , 1|0&#x3D;1 , 0|1&#x3D;1 , 0|0&#x3D;0</td></tr><tr><td>^（异或运算符）</td><td>1^0 &#x3D; 1 , 1^1 &#x3D; 0 , 0^1 &#x3D; 1 , 0^0 &#x3D; 0</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-基础&quot;&gt;&lt;a href=&quot;#Java-基础&quot; class=&quot;headerlink&quot; title=&quot;Java 基础&quot;&gt;&lt;/a&gt;Java 基础&lt;/h1&gt;&lt;h2 id=&quot;final&quot;&gt;&lt;a href=&quot;#final&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="Java 基础" scheme="https://blog.yahyav2rayssr.top/categories/Java/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://blog.yahyav2rayssr.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 状态码</title>
    <link href="https://blog.yahyav2rayssr.top/posts/e1434ae1/"/>
    <id>https://blog.yahyav2rayssr.top/posts/e1434ae1/</id>
    <published>2023-04-16T13:55:32.743Z</published>
    <updated>2023-04-16T13:55:32.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-状态码一览"><a href="#HTTP-状态码一览" class="headerlink" title="HTTP 状态码一览"></a>HTTP 状态码一览</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h3 id="信息：1xx"><a href="#信息：1xx" class="headerlink" title="信息：1xx"></a>信息：1xx</h3><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</p><table><thead><tr><th>消息：</th><th align="center">描述：</th></tr></thead><tbody><tr><td>100 Continue</td><td align="center">服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求</td></tr><tr><td>101 Switching Protocols</td><td align="center">服务器转换协议，服务器将遵从客户的请求转换到另外一种协议</td></tr><tr><td>102 Processing</td><td align="center">代表处理将被继续执行</td></tr></tbody></table><h3 id="成功：2xx"><a href="#成功：2xx" class="headerlink" title="成功：2xx"></a>成功：2xx</h3><p>代表请求已成功被服务器接收、理解、并接受。</p><table><thead><tr><th>消息：</th><th align="center">描述：</th></tr></thead><tbody><tr><td>200 OK</td><td align="center">请求成功，表示正常状态</td></tr><tr><td>201 Created</td><td align="center">请求被创建完成，同时新的资源被创建立</td></tr><tr><td>202 Accepted</td><td align="center">处理的请求已被接受，但处理未完成</td></tr><tr><td>203 Non-authoritative Information</td><td align="center">服务器已成功处理了请求，但一些应答头可能不正确，因为使用的是文档的拷贝</td></tr><tr><td>204 No Content</td><td align="center">服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息</td></tr><tr><td>205 Reset Content</td><td align="center">服务器成功处理了请求，且没有返回任何内容，返回此状态码的响应要求请求者重置文档视图</td></tr><tr><td>206 Partial Content</td><td align="center">服务器已经成功处理了部分 GET 请求</td></tr><tr><td>207 Multi-Status</td><td align="center">代表之后的消息体将是一个XML消息</td></tr></tbody></table><h3 id="重定向：3xx"><a href="#重定向：3xx" class="headerlink" title="重定向：3xx"></a>重定向：3xx</h3><p>代表需要客户端采取进一步的操作才能完成请求。</p><table><thead><tr><th>消息：</th><th align="center">描述：</th></tr></thead><tbody><tr><td>300 Multiple Choices</td><td align="center">被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向</td></tr><tr><td>301 Moved Permanently</td><td align="center">所请求的资源已经转移至新的url</td></tr><tr><td>302 Move temporarily</td><td align="center">请求的资源临时从不同的 URI响应请求</td></tr><tr><td>303 See Other</td><td align="center">所请求的页面可在别的url下被找到，客户端应当采用 GET 的方式访问那个资源</td></tr><tr><td>304 Not Modified</td><td align="center">服务器告诉客户，原来缓冲的文档还可以继续使用</td></tr><tr><td>305 Use Proxy</td><td align="center">被请求的资源必须通过指定的代理才能被访问</td></tr><tr><td>306 Switch Proxy</td><td align="center">目前已不再使用，但是代码依然被保留</td></tr><tr><td>307 Temporary Redirect</td><td align="center">请求的资源临时从不同的URI 响应请求</td></tr></tbody></table><h3 id="客户端错误：4xx"><a href="#客户端错误：4xx" class="headerlink" title="客户端错误：4xx"></a>客户端错误：4xx</h3><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</p><table><thead><tr><th>消息:</th><th align="center">描述:</th></tr></thead><tbody><tr><td>400 Bad Request</td><td align="center">语义有误，服务器未能理解请求。或请求参数有误</td></tr><tr><td>401 Unauthorized</td><td align="center">被请求的页面需要用户名和密码</td></tr><tr><td>402 Payment Required</td><td align="center">为了将来可能的需求而预留的</td></tr><tr><td>403 Forbidden</td><td align="center">对被请求资源的访问被禁止</td></tr><tr><td>404 Not Found</td><td align="center">服务器无法找到被请求的资源</td></tr><tr><td>405 Method Not Allowed</td><td align="center">请求中指定的方法不被允许</td></tr><tr><td>406 Not Acceptable</td><td align="center">服务器生成的响应无法被客户端所接受</td></tr><tr><td>407 Proxy Authentication Required</td><td align="center">用户必须首先使用代理服务器进行验证，这样请求才会被处理</td></tr><tr><td>408 Request Timeout</td><td align="center">请求超出了服务器的等待时间</td></tr><tr><td>409 Conflict</td><td align="center">和被请求的资源的当前状态之间存在冲突，请求无法完成</td></tr><tr><td>410 Gone</td><td align="center">被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址</td></tr><tr><td>411 Length Required</td><td align="center">“Content-Length” 未被定义。如果无此内容，服务器不会接受请求</td></tr><tr><td>412 Precondition Failed</td><td align="center">请求中的前提条件被服务器评估为失败</td></tr><tr><td>413 Request Entity Too Large</td><td align="center">由于所请求的实体数据太大，服务器不会接受请求</td></tr><tr><td>414 Request-url Too Long</td><td align="center">由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况</td></tr><tr><td>415 Unsupported Media Type</td><td align="center">由于请求中格式类型不被支持，服务器不会接受请求</td></tr><tr><td>416 Requested Range Not Satisfiable</td><td align="center">客户在请求中指定的Range头与当前资源的可用范围不重合</td></tr><tr><td>417 Expectation Failed</td><td align="center">在请求头 Expect 中指定的预期内容无法被服务器满足</td></tr><tr><td>421 too many connections</td><td align="center">当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围</td></tr><tr><td>422 Unprocessable Entity</td><td align="center">请求格式正确，但是由于含有语义错误，无法响应</td></tr><tr><td>423 Locked</td><td align="center">当前资源被锁定</td></tr><tr><td>424 Failed Dependency</td><td align="center">之前的某个请求发生的错误，导致当前请求失败</td></tr><tr><td>425 Unordered Collectiond</td><td align="center"></td></tr><tr><td>449 Retry With</td><td align="center">客户端应当切换到TLS&#x2F;1.0</td></tr><tr><td>425 Unordered Collectiond</td><td align="center">由微软扩展，代表请求应当在执行完适当的操作后进行重试</td></tr><tr><td>451 Unavailable For Legal Reasons</td><td align="center">该请求因法律原因不可用</td></tr></tbody></table><h3 id="服务器错误：5xx，-6xx"><a href="#服务器错误：5xx，-6xx" class="headerlink" title="服务器错误：5xx， 6xx"></a>服务器错误：5xx， 6xx</h3><p>代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理</p><table><thead><tr><th>消息:</th><th align="center">描述:</th></tr></thead><tbody><tr><td>500 Internal Server Error</td><td align="center">请求未完成，服务器遇到不可预知的情况。一般为服务器源码出现问题</td></tr><tr><td>501 Not Implemented</td><td align="center">请求未完成，服务器不支持所请求的功能</td></tr><tr><td>502 Bad Gateway</td><td align="center">请求未完成，网关或者代理工作的服务器尝试执行请求，从上游服务器收到一个无效的响应</td></tr><tr><td>503 Service Unavailable</td><td align="center">请求未完成，服务器临时过载或维护</td></tr><tr><td>504 Gateway Timeout</td><td align="center">网关或者代理工作的服务器尝试执行请求超时</td></tr><tr><td>505 HTTP Version Not Supported</td><td align="center">服务器不支持或拒绝请求中指明的HTTP协议版本</td></tr><tr><td>506 Variant Also Negotiates</td><td align="center">服务器存在内部配置错误</td></tr><tr><td>507 Insufficient Storage</td><td align="center">服务器无法存储完成请求所必须的内容</td></tr><tr><td>509 Bandwidth Limit Exceeded</td><td align="center">服务器达到带宽限制</td></tr><tr><td>510 Not Extended</td><td align="center">获取资源所需要的策略并没有被满足</td></tr><tr><td>600 Unparseable Response Headers</td><td align="center">没有返回响应头部，只返回实体内容</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-状态码一览&quot;&gt;&lt;a href=&quot;#HTTP-状态码一览&quot; class=&quot;headerlink&quot; title=&quot;HTTP 状态码一览&quot;&gt;&lt;/a&gt;HTTP 状态码一览&lt;/h1&gt;&lt;h2 id=&quot;状态&quot;&gt;&lt;a href=&quot;#状态&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="网络" scheme="https://blog.yahyav2rayssr.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="http" scheme="https://blog.yahyav2rayssr.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 基础知识</title>
    <link href="https://blog.yahyav2rayssr.top/posts/e5fda0b2/"/>
    <id>https://blog.yahyav2rayssr.top/posts/e5fda0b2/</id>
    <published>2023-04-16T13:55:16.952Z</published>
    <updated>2023-04-16T13:55:16.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-基础知识"><a href="#HTTP-基础知识" class="headerlink" title="HTTP 基础知识"></a>HTTP 基础知识</h1><h2 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h2><p><strong>TCP三次握手过程</strong></p><ol><li>主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,</li></ol><p>主机A告诉主机B两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.</p><ol start="2"><li>主机B收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:</li></ol><p>我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我</p><ol start="3"><li>主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B的数据段:”我已收到回复,我现在要开始传输实际数据了</li></ol><p>这样3次握手就完成了,主机A和主机B就可以传输数据了.</p><p><strong>3次握手的特点</strong></p><ul><li>没有应用层的数据</li><li>SYN这个标志位只有在TCP建立连接时才会被置1</li><li>握手完成后SYN标志位被置0</li></ul><img src="http 基础/201.png" style="zoom:80%;"><p><strong>TCP建立连接要进行3次握手,而断开连接要进行4次</strong></p><ol><li><p>当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求</p></li><li><p>主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1</p></li><li><p>由B端再提出反方向的关闭请求,将FIN置1</p></li><li><p>主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.</p></li></ol><p>由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础。</p><img src="http 基础/202.png" style="zoom:80%;"><p><strong>名词解释</strong></p><p>ACK：TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段</p><p>都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK&#x3D;1时,确认号才有效,当ACK&#x3D;0时,确认号无效,这时会要求重传数据,保证数据的完整性.</p><p>SYN：同步序列号,TCP建立连接时将这个位置1</p><p>FIN：发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1</p><h2 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h2><ul><li><p><strong>TCP（Transmission Control Protocol，传输控制协议）</strong>是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。</p></li><li><p><strong>UDP（User Data Protocol，用户数据报协议）</strong></p></li></ul><ol><li><p>UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</p></li><li><p>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。</p></li><li><p>UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。</p></li><li><p>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。</p></li><li><p>UDP使用<strong>尽最大努力交付，</strong>即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。</p></li><li><p>UDP是<strong>面向报文</strong>的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</p></li></ol><p>我们经常使用“ping”命令来测试两台主机之间TCP&#x2F;IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</p><p><strong>UDP的包头结构：</strong></p><p>源端口 16位</p><p>目的端口 16位</p><p>长度 16位</p><p>校验和 16位</p><p><strong>小结TCP与UDP的区别：</strong></p><p>1.基于连接与无连接；</p><p>2.对系统资源的要求（TCP较多，UDP少）；</p><p>3.UDP程序结构较简单；</p><p>4.流模式与数据报模式 ；</p><p>5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-基础知识&quot;&gt;&lt;a href=&quot;#HTTP-基础知识&quot; class=&quot;headerlink&quot; title=&quot;HTTP 基础知识&quot;&gt;&lt;/a&gt;HTTP 基础知识&lt;/h1&gt;&lt;h2 id=&quot;三次握手，四次挥手&quot;&gt;&lt;a href=&quot;#三次握手，四次挥手&quot; class</summary>
      
    
    
    
    <category term="网络" scheme="https://blog.yahyav2rayssr.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="http" scheme="https://blog.yahyav2rayssr.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 详解</title>
    <link href="https://blog.yahyav2rayssr.top/posts/e344884c/"/>
    <id>https://blog.yahyav2rayssr.top/posts/e344884c/</id>
    <published>2023-04-16T13:43:28.189Z</published>
    <updated>2023-04-16T13:43:28.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="HahsMap存值过程"><a href="#HahsMap存值过程" class="headerlink" title="HahsMap存值过程"></a>HahsMap存值过程</h2><ul><li>根据key计算一个hash值</li><li>在put的时候计算数组是否存在 如果不存在调用resize方法创建默认容量为16的数组</li><li>确定node在数组中的位置 根据hash值与数组最大索引值进行与运算得到索引位置</li><li>获取该位置是否有元素 如果没有元素 直接新建一个Node放在该位置</li><li>如果有元素 判断key是否完全相同 如果相同把原来的node赋值给一个变量</li><li>此时再去判断 该位置是红黑树还是链表</li><li>如果是红黑树 以红黑树的方式将node放在红黑树上</li><li>如果是链表 此时遍历链表 然后将node放在最后一位<br>放完以后需要去判断链表的长度 是否超过8 如果超过需要判断是否将链表转换为红黑树（当数组容量小于64的时候 只会进行数组的扩容 如果大于64才会进行链表转换红黑树）</li><li>返回被覆盖的值</li><li>判断整个数组是否需要扩容</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h2 id=&quot;HahsMap存值过程&quot;&gt;&lt;a href=&quot;#HahsMap存值过程&quot; class=&quot;headerlink&quot; title=&quot;Hah</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap 详解</title>
    <link href="https://blog.yahyav2rayssr.top/posts/39a12d12/"/>
    <id>https://blog.yahyav2rayssr.top/posts/39a12d12/</id>
    <published>2023-04-16T13:43:17.896Z</published>
    <updated>2023-04-16T13:43:17.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrentHashMap-详解"><a href="#concurrentHashMap-详解" class="headerlink" title="concurrentHashMap 详解"></a>concurrentHashMap 详解</h1><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSetInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分片统计总和"><a href="#分片统计总和" class="headerlink" title="分片统计总和"></a>分片统计总和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>    CounterCell[] cs = counterCells;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>    <span class="hljs-keyword">if</span> (cs != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (CounterCell c : cs)<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>)<br>                sum += c.value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程抢占CounterCell"><a href="#线程抢占CounterCell" class="headerlink" title="线程抢占CounterCell"></a>线程抢占CounterCell</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// cellsBusy == 1 代表有其他线程正在扩容 </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; counterCells == cs &amp;&amp;<br>         U.compareAndSetInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>        <span class="hljs-keyword">if</span> (counterCells == cs) &#123;<br>            CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[<span class="hljs-number">2</span>];<br>            rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x);<br>            counterCells = rs;<br>            init = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        cellsBusy = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (init)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化tab"><a href="#初始化tab" class="headerlink" title="初始化tab"></a>初始化tab</h2><blockquote><p>tab 代指 Node&lt;K,V&gt;[] 数组</p></blockquote><h2 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h2><ol><li>-1 表示一个占位符，如果sizeCtl &#x3D; -1，表示当前已经有线程抢到了初始化的权限</li><li>&gt; 0的数字 sizeCtl &#x3D; sc &#x3D; n*0.75 &#x3D; 12 表示下一次扩容的大小</li><li>负数（非 -1）代表有几个线程正在扩容 （-2）有一个线程正在扩容</li></ol><h2 id="binCount"><a href="#binCount" class="headerlink" title="binCount"></a>binCount</h2><blockquote><p>链表长度</p></blockquote><h2 id="CounterCell"><a href="#CounterCell" class="headerlink" title="CounterCell"></a>CounterCell</h2><blockquote><p>分片计数器数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; counterCells == cs &amp;&amp;<br>         U.compareAndSetInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>        <span class="hljs-keyword">if</span> (counterCells == cs) &#123;<br>            CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[<span class="hljs-number">2</span>];<br>            rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x);<br>            counterCells = rs;<br>            init = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        cellsBusy = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (init)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>CHM的扩容，是可以多个线程并行扩容的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">resizeStamp</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="hljs-number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>resizeStamp(16) &#x3D; 32795</p><p>0000 0000 0000 0000 1000 0000 0001 1011 左移16位</p><p>1000 0000 0001 1011 0000 0000 0000 0000 + 2</p><p>1000 0000 0001 1011 0000 0000 0000 0010 -&gt; 表示当前有一个线程在扩容</p><p>扩容的戳</p><p>高16位代表扩容的标记</p><p>低16位代表扩容的线程数 -&gt; 有一个线程参与扩容了</p><ol><li>需要保证每次扩容的扩容戳都是唯一的</li><li>可以支持并发扩容</li></ol><h2 id="占位节点"><a href="#占位节点" class="headerlink" title="占位节点"></a>占位节点</h2><blockquote><p>MOVED状态，即为 -1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br></code></pre></td></tr></table></figure><h2 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h2><blockquote><p>数组扩容</p></blockquote><img src="/posts/39a12d12/206.png" class alt="image-20200821213045324"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSetInt<br>         (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>          nextBound = (nextIndex &gt; stride ?<br>                       nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>    bound = nextBound;<br>    i = nextIndex - <span class="hljs-number">1</span>;<br>    advance = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链路拆分"><a href="#链路拆分" class="headerlink" title="链路拆分"></a>链路拆分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;<br>    Node&lt;K,V&gt; lastRun = f;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.hash &amp; n;<br>        <span class="hljs-keyword">if</span> (b != runBit) &#123;<br>            runBit = b;<br>            lastRun = p;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 低位链</span><br>    <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;<br>        ln = lastRun;<br>        hn = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 高位链</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        hn = lastRun;<br>        ln = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ph</span> <span class="hljs-operator">=</span> p.hash; <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key; <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> p.val;<br>        <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>)<br>            ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);<br>        <span class="hljs-keyword">else</span><br>            hn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);<br>    &#125;<br>    setTabAt(nextTab, i, ln); <span class="hljs-comment">// 低位链路，位置保持不动</span><br>    setTabAt(nextTab, i + n, hn); <span class="hljs-comment">// 高位链，需要增加n长度位置 14+16=30</span><br>    setTabAt(tab, i, fwd)<br>    advance = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/39a12d12/image-20200821220504563.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>通过数组的方式来实现并发增加元素的个数</li><li>并发扩容，可以通过多个线程来并行实现数据的迁移</li><li>采用高低链的方式来解决多次hash计算的问题，提升了效率</li><li>sizeCtl的设计，三种表示状态</li><li>resizeStamp的设计，高低位的设计来实现唯一性以及多个线程的协助扩容记录</li></ol><blockquote><p>如果连链表的长度大于8，并且node数组的长度 &gt; 64 的时候，如果再添加数据到当前链表中，会把当前链表转换为红黑树。</p><p>当出现扩容的时候，如果链表的长度小于8，把红黑树转换为链表</p></blockquote><blockquote><p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。</p><p>1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</p><p>2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。</p><p>3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</p><p>4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</p><p>5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concurrentHashMap-详解&quot;&gt;&lt;a href=&quot;#concurrentHashMap-详解&quot; class=&quot;headerlink&quot; title=&quot;concurrentHashMap 详解&quot;&gt;&lt;/a&gt;concurrentHashMap 详解&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 数据结构基础</title>
    <link href="https://blog.yahyav2rayssr.top/posts/c9844e82/"/>
    <id>https://blog.yahyav2rayssr.top/posts/c9844e82/</id>
    <published>2023-04-16T13:42:55.909Z</published>
    <updated>2023-04-16T13:42:55.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="1、什么是链表？"><a href="#1、什么是链表？" class="headerlink" title="1、什么是链表？"></a>1、什么是链表？</h2><p>链表 [Linked List]：链表是由一组不必相连【不必相连：可以连续也可以不连续】的内存结构 【节点】，按特定的顺序链接在一起的抽象数据类型。</p><blockquote><p>补充：<br>抽象数据类型（Abstract Data Type [ADT]）：表示数学中抽象出来的一些操作的集合。<br>内存结构：内存中的结构，如：struct、特殊内存块…等等之类；</p></blockquote><h2 id="2、链表共分几类？"><a href="#2、链表共分几类？" class="headerlink" title="2、链表共分几类？"></a>2、链表共分几类？</h2><p>链表常用的有 3 类： 单链表、双向链表、循环链表。</p><p>链表的核心操作集有 3 种：插入、删除、查找【遍历】</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表  [Linked List]：由各个内存结构通过一个 <code>Next</code> 指针链接在一起组成，每一个内存结构都存在后继内存结构【链尾除外】，内存结构由数据域和 Next 指针域组成。</p><p>单链表实现图示：</p><img src="/posts/c9844e82/98.jpg" class><p>文字解析：</p><ul><li>Data 数据 + Next 指针，组成一个单链表的内存结构 ；</li><li>第一个内存结构称为 链头，最后一个内存结构称为 链尾；</li><li>链尾的 Next 指针设置为 NULL [指向空]；</li><li>单链表的遍历方向单一【只能从链头一直遍历到链尾】</li></ul><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表 [Double Linked List]：由各个内存结构通过指针 <code>Next</code> 和指针 <code>Prev</code> 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构【链头没有前驱，链尾没有后继】，内存结构由数据域、Prev 指针域和 Next 指针域组成。</p><p>双向链表实现图示：</p><img src="/posts/c9844e82/99.jpg" class><p>文字解析：</p><ul><li>Data 数据 + Next 指针 + Prev 指针，组成一个双向链表的内存结构；</li><li>第一个内存结构称为 链头，最后一个内存结构称为 链尾；</li><li>链头的 Prev 指针设置为 NULL， 链尾的 Next 指针设置为 NULL；</li><li>Prev 指向的内存结构称为 前驱， Next 指向的内存结构称为 后继；</li><li>双向链表的遍历是双向的，即如果把从链头的 Next 一直到链尾的[NULL] 遍历方向定义为正向，那么从链尾的 Prev 一直到链头 [NULL ]遍历方向就是反向；</li></ul><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>单向循环链表 [Circular Linked List] : 由各个内存结构通过一个指针 <code>Next</code> 链接在一起组成，每一个内存结构都存在后继内存结构，内存结构由数据域和 Next 指针域组成。</p><p>双向循环链表 [Double Circular Linked List] : 由各个内存结构通过指针 <code>Next</code> 和指针 <code>Prev</code> 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构，内存结构由数据域、Prev 指针域和 Next 指针域组成。</p><p>循环链表的单向与双向实现图示：</p><img src="/posts/c9844e82/100.jpg" class><p>文字解析：</p><ul><li>循环链表分为单向、双向两种；</li><li>单向的实现就是在单链表的基础上，把链尾的 Next 指针直接指向链头，形成一个闭环；</li><li>双向的实现就是在双向链表的基础上，把链尾的 Next 指针指向链头，再把链头的 Prev 指针指向链尾，形成一个闭环；</li><li>循环链表没有链头和链尾的说法，因为是闭环的，所以每一个内存结构都可以充当链头和链尾；</li></ul><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="ArrayList实现原理"><a href="#ArrayList实现原理" class="headerlink" title="ArrayList实现原理"></a>ArrayList实现原理</h2><p>默认初始容量为10<br>数组数据和容量统计是分开的<br>是通过下标访问数组的<br>如果添加元素的时候超过数组本身的容量，则扩展为原来的1.5倍数<br>加减元素挪动原有数据通过<code>System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>来操作实现</p><h2 id="LinkedList实现原理"><a href="#LinkedList实现原理" class="headerlink" title="LinkedList实现原理"></a>LinkedList实现原理</h2><p>链表的数据不一定是连续存储的<br>LinkedList<br>通过分半的方式查找的<br>默认是添加到链表尾部</p><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><img src="/posts/c9844e82/image-20200908191149997.png" alt="image-20200908191149997" style="zoom:33%;"><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><blockquote><p>put  take 阻塞<br>add remove 异常<br>offer poll true&#x2F;false</p></blockquote><h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><img src="/posts/c9844e82/image-20200908174640627.png" alt="image-20200908174640627" style="zoom:33%;"><h3 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// assert takeLock.isHeldByCurrentThread();</span><br>    <span class="hljs-comment">// assert head.item == null;</span><br>    Node&lt;E&gt; h = head;<br>    Node&lt;E&gt; first = h.next;<br>    h.next = h; <span class="hljs-comment">// help GC</span><br>    head = first;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;<br>    first.item = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：</p><p><code>h = head</code></p><p><code>first = h.next</code></p><p><code>h.next = h (help gc)</code></p><p><code>head = first</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;<br>first.item = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><h2 id="ConcurrentLinkedQueue-1"><a href="#ConcurrentLinkedQueue-1" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><img src="/posts/c9844e82/image-20200908172446586.png" alt="image-20200908172446586" style="zoom:33%;"><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><blockquote><p>采用空间换取时间安全的做法</p><p>适合读多写少的场景</p></blockquote><h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;h2 id=&quot;1、什么是链表？&quot;&gt;&lt;a href=&quot;#1、什么是链表？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是链表？&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Vim 基本命令</title>
    <link href="https://blog.yahyav2rayssr.top/posts/154baef/"/>
    <id>https://blog.yahyav2rayssr.top/posts/154baef/</id>
    <published>2023-04-16T13:32:08.342Z</published>
    <updated>2023-04-16T13:32:08.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="跳至行首-x2F-行尾"><a href="#跳至行首-x2F-行尾" class="headerlink" title="跳至行首&#x2F;行尾"></a>跳至行首&#x2F;行尾</h2><p>跳至当前行行首</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">shift</span>+4命令可以敲出$字母</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"></span><br><span class="language-bash"></span><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者数字0</span><br>0<br></code></pre></td></tr></table></figure><p>跳至当前行行尾</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">大写的A</span><br>A<br></code></pre></td></tr></table></figure><p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h2 id=&quot;跳至行首-x2F-行尾&quot;&gt;&lt;a href=&quot;#跳至行首-x2F-行尾&quot; class=&quot;headerlink&quot; title=&quot;跳至行</summary>
      
    
    
    
    <category term="Vim" scheme="https://blog.yahyav2rayssr.top/categories/Vim/"/>
    
    
    <category term="vim" scheme="https://blog.yahyav2rayssr.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Spring 基础</title>
    <link href="https://blog.yahyav2rayssr.top/posts/4e9ceea/"/>
    <id>https://blog.yahyav2rayssr.top/posts/4e9ceea/</id>
    <published>2023-04-16T13:30:00.702Z</published>
    <updated>2023-04-16T13:30:00.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP-详解"><a href="#AOP-详解" class="headerlink" title="AOP 详解"></a>AOP 详解</h1><h2 id="一、AOP-简介"><a href="#一、AOP-简介" class="headerlink" title="一、AOP 简介"></a>一、AOP 简介</h2><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP只允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志，事务，安全等。这些功能都是横向应用在业务处理中，而与它们对应的方法与其他代码基本没有联系，如异常处理和透明的持续性也都是如此，不仅增加了大量的代码量，还为程序后期的维护增生很多困难。</p><p>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><h2 id="二、AOP-基本了解和通知方法"><a href="#二、AOP-基本了解和通知方法" class="headerlink" title="二、AOP 基本了解和通知方法"></a>二、AOP 基本了解和通知方法</h2><ol><li><strong>切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。</strong><br>事务管理是J2EE应用中一个关于横切关注点的很好的例子。在spring AOP中，切面可以使用基于模式）或者基于Aspect注解方式来实现。通俗点说就是我们加入的切面类（比如log类），可以这么理解。</li><li><strong>连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。</strong><br>在Spring AOP中，一个连接点总是表示一个方法的执行。通俗的说就是加入切点的那个点</li><li><strong>通知（Advice）：在切面的某个特定的连接点上执行的动作。</strong><br>其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</li><li><strong>切入点（Pointcut）：匹配连接点的断言。</strong><br>通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</li><li><strong>引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type declaration））。</strong><br>Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。</li><li><strong>目标对象（Target Object）： 被一个或者多个切面所通知的对象。</strong><br>也被称做被通知（advised）对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。</li><li><strong>AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。</strong><br>在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li><li><strong>织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。</strong><br>这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li></ol><h3 id="通知方法："><a href="#通知方法：" class="headerlink" title="通知方法："></a>通知方法：</h3><ol><li><p><strong>前置通知（Before advice）：</strong>在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</p></li><li><p><strong>后置通知（After returning advice）：</strong>在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p></li><li><p><strong>异常通知（After throwing advice）：</strong>在方法抛出异常退出时执行的通知。</p></li><li><p><strong>最终通知（After (finally) advice）：</strong>当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p></li><li><p><strong>环绕通知（Around Advice）：</strong>包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。</p><p>它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p></li></ol><h2 id="三、Spring对AOP的支持"><a href="#三、Spring对AOP的支持" class="headerlink" title="三、Spring对AOP的支持"></a>三、Spring对AOP的支持</h2><p>Spring中AOP代理由Spring的IOC容器负责生成，管理，它的依赖关系也有IOC容器负责。因此，AOP代理可以直接使用容器中的其他bean示例作为目标，这种关系可由IOC容器的依赖注入提供(不熟悉依赖注入的可以看看我之前的博文)。Spring创建代理规则为:</p><p>  1、默认使用JDK动态代理来创建AOP代理，这样可以为任何接口示例创建代理</p><p>  2、当需要代理的类不是代理接口时，Spring会切换为使用CGLIB代理，也可强制使用CGLIB代理。(强制方法：在XML配置中修改 AOP 属性spring.aop.proxy-target-class&#x3D;true或在注释中修改@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true)进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：代理对象的方法&#x3D;增强处理+被代理对象的方法。</p><p>exposeProxy：AOP生成对象时，绑定到ThreadLocal, 可以通过AopContext获取</p><h1 id="IOC（依赖注入）的基本实现方式"><a href="#IOC（依赖注入）的基本实现方式" class="headerlink" title="IOC（依赖注入）的基本实现方式"></a>IOC（依赖注入）的基本实现方式</h1><p>Java中创建一个对象分两步： </p><ol><li>通过关键字<strong>new创建一个对象</strong> </li><li>通过<strong>构造函数或setter函数为对象添加初始化参数 （参数可以是基本数据类型 也可以是引用数据类型（比如依赖的类））</strong></li></ol><p>当 Spring 出现后，<strong>对象的创建、成员变量的初始化、对象的销毁均由Spring完成。</strong> </p><p>那么，要让Spring帮助我们创建对象，我们首先需要将<strong>要创建的对象的类型</strong>、<strong>初始化的值</strong>告诉Spring，然后Spring会在程序启动的时候根据我们的要求创建对象。我们通过配置文件来告诉Spring要创建哪些对象，并告诉Spring如何创建这些对象。</p><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p><strong>在Spring中，默认情况下bean都是单例。也就是说，当我们向Spring请求一个bean对象时，Spring总给我们返回同一个bean对象。</strong><br><strong>注意：</strong>Spring 中所说的“单例”与Java中的单例稍有不同。Spring中的单例是指：在同一个ApplicationContext中相同名字的bean对象是同一个；而Java中的单例是指：整个JVM中单例的对象只有一个。<br>当然，我们可以通过改变bean标签的scope参数来设置bean的作用域。常用的scope对应的值有： </p><ul><li><p>singleton：在同一个Spring Context中，一个bean只有一个实例对象。(默认) </p></li><li><p>prototype：每次向Spring请求一个bean对象，Spring都会创建一个新的实例。</p></li><li><p><strong>会话（Session）</strong>：在web应用中，为每个会话创建一个bean实例。</p></li><li><p><strong>请求（Request）</strong>：在Web应用中，为每个请求创建一个bean实例。</p></li></ul><p><strong>依赖注入的方式分三种</strong></p><ol><li>构造函数注入</li><li>属性注入</li><li>set方法注入</li></ol><h2 id="自动装配与自动扫描"><a href="#自动装配与自动扫描" class="headerlink" title="自动装配与自动扫描"></a>自动装配与自动扫描</h2><p>简化Spring的配置主要分为两类： </p><ol><li>自动装配 </li><li>自动扫描</li></ol><h3 id="自动装配的种类"><a href="#自动装配的种类" class="headerlink" title="自动装配的种类"></a>自动装配的种类</h3><ol><li><p><strong>byName：根据属性的名字自动装配</strong></p><p>在bean标签中添加属性autowire&#x3D;”byName”。当Spring启动时，会寻找<strong>与person中成员变量名字相同的bean</strong>，并将该bean注给person的成员变量。</p></li><li><p><strong>byType：根据属性的类型自动装配</strong><br>在bean标签中添加属性autowire&#x3D;”byType”。当Spring启动时，会寻找<strong>与person中成员变量类型相同的bean</strong>，并将该bean注给person的成员变量。<br><strong>byType的缺点：</strong>如果某一类型的bean有多个，那Spring在通过byType为属性寻找同类型的bean时就会抛出异常。 </p></li><li><p><strong>constructor：根据构造器的参数类型自动装配</strong></p></li><li><p><strong>autodetect：最佳自动装配。首先采用constructor自动装配，若没有发现与构造器相匹配的Bean时，采用byType进行自动装配。</strong></p></li></ol><p><strong>@Autowired本质上采用byType进行自动装配，因此也存在与byType一样的问题：若同一类型的bean有多个时，或找不到该类型的bean，Spring就会抛出异常。</strong></p><h4 id="在注解中使用SpEL表达式"><a href="#在注解中使用SpEL表达式" class="headerlink" title="在注解中使用SpEL表达式"></a>在注解中使用SpEL表达式</h4><p>将名为father的bean注入给构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;#&#123;father&#125;&quot;)</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(Father father)</span>&#123;<br>      <span class="hljs-built_in">this</span>.father = father;<br>  &#125;<br></code></pre></td></tr></table></figure><p>将father对象中的id注入给id：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;#&#123;father.id&#125;&quot;)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>&#123;<br>       <span class="hljs-built_in">this</span>.id = id;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="自动检测"><a href="#自动检测" class="headerlink" title="自动检测"></a>自动检测</h2><p><strong>自动装配能够减少bean标签下property标签和constructor-arg标签的数量，而自动检测能降低bean标签的数量。</strong></p><h1 id="Spring-注解-Resource-和-Autowired-区别对比"><a href="#Spring-注解-Resource-和-Autowired-区别对比" class="headerlink" title="Spring 注解 @Resource 和 @Autowired 区别对比"></a>Spring 注解 @Resource 和 @Autowired 区别对比</h1><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@<strong>Autowired</strong></h2><p>​@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。(通过类型匹配找到多个candidate,在没有@Qualifier、@Primary注解的情况下，会使用对象名作为最后的fallback匹配)如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">private</span> UserDao userDao; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a><strong>@Resource</strong></h2><p>​@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><p>​@Resourced标签是按照bean的名字来进行注入的，如果我们没有在使用@Resource时指定bean的名字，同时Spring容器中又没有该名字的bean,这时候@Resource就会退化为@Autowired即按照类型注入，这样就有可能违背了使用@Resource的初衷。所以建议在使用@Resource时都显示指定一下bean的名字@Resource(name&#x3D;”xxx”) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br>    <span class="hljs-comment">// 下面两种@Resource只要使用一种即可</span><br>    <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">private</span> UserDao userDao; <span class="hljs-comment">// 用于字段上</span><br>    <br>    <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123; <span class="hljs-comment">// 用于属性的setter方法上</span><br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li><li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li><li>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</li><li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li></ul><h1 id="Spring-中-Bean-的生命周期"><a href="#Spring-中-Bean-的生命周期" class="headerlink" title="Spring 中 Bean 的生命周期"></a>Spring 中 Bean 的生命周期</h1><p>对于普通的 Java 对象，当我们使用<code>new</code>关键字创建对象的时候，如果它没有任何引用，则其会被垃圾回收机制回收。而由 Spring IoC 容器托管的对象，它们的生命周期则是完全由容器控制。在 Spring 中，每个 Bean 的生命周期大致如下：</p><img src="/posts/4e9ceea/109.jpg" class><h2 id="实例化-Bean"><a href="#实例化-Bean" class="headerlink" title="实例化 Bean"></a>实例化 Bean</h2><p>对于BeanFactory容器来说，当用户向容器请求一个尚未初始化的 Bean 或初始化 Bean 的时候，如果需要注入另一个尚未初始化的依赖，容器就会调用createBean进行实例化；对于ApplicationContext容器来说，当容器启动结束后，便实例化所有的 Bean。</p><p>容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。 实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h2 id="设置对象属性（依赖注入）"><a href="#设置对象属性（依赖注入）" class="headerlink" title="设置对象属性（依赖注入）"></a>设置对象属性（依赖注入）</h2><p>实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。 紧接着，Spring 根据BeanDefinition中的信息进行依赖注入，并且通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><h2 id="注入-Aware-接口"><a href="#注入-Aware-接口" class="headerlink" title="注入 Aware 接口"></a>注入 Aware 接口</h2><p>紧接着，Spring 会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给 Bean：</p><p>如果 Bean 实现了BeanNameAware接口，Spring 将 Bean 的 ID 传递给setBeanName()方法。实现BeanNameAware主要是为了通过 Bean 的引用来获得 Bean 的 ID，一般业务中是很少有用到 Bean 的 ID 的。<br>如果 Bean 实现了BeanFactoryAware接口，Spring 将调用setBeanDactory(BeanFactory bf)方法并把BeanFactory容器实例作为参数传入。实现BeanFactoryAware主要目的是为了获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等。<br>如果 Bean 实现了ApplicationContextAware接口，Spring 容器将调用setApplicationContext(ApplicationContext ctx)方法，把应用上下文作为参数传入，作用与BeanFactory类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用setApplicationContext方法时会把它自己作为setApplicationContext的参数传入，而 Spring 容器在调用setBeanDactory前需要程序员自己指定（注入）setBeanDactory里的参数BeanFactory。</p><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>当经过上述几个步骤后，Bean 对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。 该接口提供了两个函数：</p><p>postProcessBeforeInitialzation(Object bean, String beanName)当前正在初始化的 Bean 对象会被传递进来，我们就可以对这个 Bean 作任何处理。这个函数会先于InitialzationBean执行，因此称为前置处理。 所有Aware接口的注入就是在这一步完成的。<br>postProcessAfterInitialzation(Object bean, String beanName)当前正在初始化的 Bean 对象会被传递进来，我们就可以对这个 Bean 作任何处理。这个函数会在InitialzationBean完成后执行，因此称为后置处理。</p><h2 id="InitializingBean-与-init-method"><a href="#InitializingBean-与-init-method" class="headerlink" title="InitializingBean 与 init-method"></a>InitializingBean 与 init-method</h2><p>当BeanPostProcessor的前置处理完成后就会进入本阶段。 InitializingBean接口只有一个函数：</p><p>afterPropertiesSet()<br>这一阶段也可以在 Bean 正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前 Bean 对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 若要使用它，我们需要让 Bean 实现该接口，并把要增加的逻辑写在该函数中。然后，Spring 会在前置处理完成后检测当前 Bean 是否实现了该接口，并执行afterPropertiesSet函数。</p><p>当然，Spring 为了降低对客户代码的侵入性，给 Bean 的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring 便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。</p><h2 id="DisposableBean-和-destroy-method"><a href="#DisposableBean-和-destroy-method" class="headerlink" title="DisposableBean 和 destroy-method"></a>DisposableBean 和 destroy-method</h2><p>如果 Bean 实现了DispostbleBean接口，Spring 将调用它的destory方法，作用与在配置文件中对 Bean 使用destory-method属性的作用一样，都是在 Bean 实例销毁前执行的方法。</p><p>至此，Spring 中 Bean 的经历了从创建到消耗的整个生命周期的过程。</p><h1 id="Spring-事务传播行为"><a href="#Spring-事务传播行为" class="headerlink" title="Spring 事务传播行为"></a>Spring 事务传播行为</h1><h2 id="什么是事务传播行为？"><a href="#什么是事务传播行为？" class="headerlink" title="什么是事务传播行为？"></a>什么是事务传播行为？</h2><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p><h2 id="Spring中七种事务传播行为"><a href="#Spring中七种事务传播行为" class="headerlink" title="Spring中七种事务传播行为"></a>Spring中七种事务传播行为</h2><table><thead><tr><th><strong>事务传播行为类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><h2 id="REQUIRED-REQUIRES-NEW-NESTED-异同"><a href="#REQUIRED-REQUIRES-NEW-NESTED-异同" class="headerlink" title="REQUIRED, REQUIRES_NEW, NESTED 异同"></a>REQUIRED, REQUIRES_NEW, NESTED 异同</h2><ul><li><p>NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。</p><p>但是REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，</p><p>外围方法事务也将被回滚。而NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。</p></li><li><p>NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。</p><p>但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。</p><p>而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。</p></li></ul><h1 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h1><img src="/posts/4e9ceea/207.png" class alt="img"><ol><li>开始实例化 person </li><li>设置 name 属性</li><li>Person 实现了 BeanNameAware 接口，Spring 将 Person 的 ID&#x3D;person传递给 setBeanName 方法</li><li>Person 实现了 BeanFactoryAware 接口，Spring 调用 setBeanFactory()方法，将 BeanFactory 容器实例传入</li><li>Person 实现了 ApplicationContextAware 接口，Spring 调用 setApplicationContext()方法，将 person 所在的应用上下文的引用传入进来</li><li>初始化 Person 之前执行的方法（BeanPostProcessor 的 postProcessBeforeInitialization 方法）</li><li>@PostConstruct 调用自定义的初始化方法</li><li>Person 实现了 InitializingBean 接口，Spring 调用它的afterPropertiesSet()方法。类似地，如果 person 使用 init-method 声明了初始化方法，该方法也会被调用</li><li>xml 中声明的 init-method 方法</li><li>初始化 Person 完成之后执行的方法（BeanPostProcessor 的 postProcessAfterInitialization 方法）</li><li>实例化完成使用属性：Person name &#x3D; nasus（main结束方法）</li><li>@PreDestory 调用自定义销毁方法</li><li>Person 实现了 DisposableBean 接口，Spring 调用它的destroy() 接口方法。同样，如果 person 使用 destroy-method 声明了销毁方法，该方法也会被调用</li><li>xml 中声明的 destroy-method 方法</li></ol><h1 id="servlet-执行流程"><a href="#servlet-执行流程" class="headerlink" title="servlet 执行流程"></a>servlet 执行流程</h1><img src="/posts/4e9ceea/12546411-497191fff892d42b.jpg" class alt="img"><h1 id="Java-SPI-和-Spring-SPI"><a href="#Java-SPI-和-Spring-SPI" class="headerlink" title="Java SPI 和 Spring SPI"></a>Java SPI 和 Spring SPI</h1><p>service provider framework是一个系统， 实现了SPI， 在系统里多个服务提供者模块可以提供一个服务的实现， 系统让客户端可以使用这些实现， 从而实现解耦。</p><p>一个service provider framework有3个主要的组成部分:</p><ol><li>一个服务接口， 供服务提供者实现。</li><li>一个注册API， 系统使用这个API来注册服务接口的实现， 从而让客户端使用。</li><li>一个service access API， 客户端可以选择获取一个服务的实例。</li></ol><h2 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI:"></a>Java SPI:</h2><p>Service Provider Interface(SPI)是一个可以被第三方扩展或实现的API， 它可以用来实现框架扩展和可替换的模块。</p><p>使用步骤：</p><ol><li>服务调用方通过 <code>ServiceLoader.load</code> 加载服务接口的实现类实例</li><li>服务提供方实现服务接口后， 在自己Jar包的META-INF&#x2F;services目录下新建一个接口名全名的文件， 并将具体实现类全名写入。</li></ol><h2 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h2><p>很多开源库中都直接或间接地使用了Java的SPI机制， 如Spring中就有类似的SPI机制， 通过SpringFactoriesLoader代替JDK中的ServiceLoader， 通过META-INF&#x2F;spring.factories文件代替META-INF&#x2F;service目录下的描述文件, 原理都是使用了Java的反射机制。</p><p>Spring提供的SPI只需要且只有一个文件， 就是META-INF&#x2F;spring.factories</p><p>Spring的SPI也更加灵活， 不必要key是接口， 值是实现类， 例如Spring boot使用这种方式来处理自动配置的bean: key是注解(如org.springframework.boot.autoconfig.EnableAutoConfiguration)， 值是被标记@Configuration的类。</p><p>另外Spring中还有converter spi和formatter spi。</p><p>converter可以用做任意两个类型之间的转换， formatter spi用做string类型和其他类型之间的转换。</p><p>Converter和Formatter接口即服务接口</p><p>ConersionService实现了ConverterRegistry接口， 提供服务实现的注册， 同时也提供可访问功能。</p><p>而<code>FormattingConversionService</code> 则实现了FormatterRegistry接口， 实现了formatter实现类的注册和调用。 同时FormattingConversionService也实现了ConversionService接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AOP-详解&quot;&gt;&lt;a href=&quot;#AOP-详解&quot; class=&quot;headerlink&quot; title=&quot;AOP 详解&quot;&gt;&lt;/a&gt;AOP 详解&lt;/h1&gt;&lt;h2 id=&quot;一、AOP-简介&quot;&gt;&lt;a href=&quot;#一、AOP-简介&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="Spring" scheme="https://blog.yahyav2rayssr.top/categories/Java/Spring/"/>
    
    
    <category term="spring" scheme="https://blog.yahyav2rayssr.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud 组件概念</title>
    <link href="https://blog.yahyav2rayssr.top/posts/b27a891c/"/>
    <id>https://blog.yahyav2rayssr.top/posts/b27a891c/</id>
    <published>2023-04-16T13:28:04.657Z</published>
    <updated>2023-04-16T13:28:04.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>Spring Cloud是一系列框架的有序集合</strong>。它利用<strong>Spring Boot</strong>的开发便利性巧妙地简化了分布式系统基础设施的开发，如<strong>服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控</strong>等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 <strong>Spring Cloud正是对Netflix的多个开源组件进一步的封装而成</strong>，同时又实现了和云端平台，和Spring Boot开发框架很好的集成。 Spring Cloud是一个相对比较新的微服务框架，<strong>2016年才推出1.0的release版本</strong>. 虽然Spring Cloud时间最短, 但是相比Dubbo等RPC框架, <strong>Spring Cloud提供的全套的分布式系统解决方案</strong>。 Spring Cloud 为开发者提供了在分布式系统（<strong>配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全居琐，leader选举，分布式session，集群状态</strong>）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。</p><img src="/posts/b27a891c/155.jpg" style="zoom: 80%;"><p>从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。</p><ul><li>其中Eureka负责服务的注册与发现，很好将各服务连接起来</li><li>Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。</li><li>Hystrix dashboard,Turbine 负责监控 Hystrix的熔断情况，并给予图形化的展示</li><li>Spring Cloud Config 提供了统一的配置中心服务</li><li>当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息</li><li>所有对外的请求和服务，我们都通过Zuul来进行转发，起到API网关的作用</li><li>最后我们使用Sleuth+Zipkin将所有的请求数据记录下来，方便我们进行后续分析</li></ul><h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如<strong>Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色</strong>。对于我们想快速实践微服务的开发者来说，第一类子项目就已经足够使用，如：<strong>Spring Cloud Netflix</strong>，是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。 通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。</p><h2 id="Eureka-服务发现"><a href="#Eureka-服务发现" class="headerlink" title="Eureka 服务发现"></a>Eureka 服务发现</h2><p>涉及注解：@EnableEurekaServer、@EnableEurekaClient</p><img src="/posts/b27a891c/156.jpg" style="zoom:80%;"><img src="/posts/b27a891c/157.jpg" style="zoom:80%;"><p>Eureka两个组件组成：<strong>Eureka服务器和Eureka客户端</strong>。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</p><h2 id="Ribbon-客户端负载均衡"><a href="#Ribbon-客户端负载均衡" class="headerlink" title="Ribbon 客户端负载均衡"></a>Ribbon 客户端负载均衡</h2><p>涉及注解：@LoadBalanced、@RibbonClient(配置)</p><img src="/posts/b27a891c/158.jpg" style="zoom:80%;"><p>Ribbon，主要提供客户侧的软件负载均衡算法。 Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。下面是用到的一些<strong>负载均衡策略</strong>：</p><ul><li><p>轮询策略（RoundRobinRule）</p><p>轮询策略理解起来比较简单，就是拿到所有的server集合，然后根据id进行遍历。这里的id是ip+端口，Server实体类中定义的id属性如下：</p></li><li><p>随机策略（RandomRule）</p><p>随机策略：使用jdk自带的随机数生成工具，生成一个随机数，然后去可用服务列表中拉取服务节点Server。如果当前节点不可用，则进入下一轮随机策略，直到选到可用服务节点为止。</p></li><li><p>可用过滤策略（AvailabilityFilteringRule）</p><p>策略描述：过滤掉连接失败的服务节点，并且过滤掉高并发的服务节点，然后从健康的服务节点中，使用轮询策略选出一个节点返回。</p></li><li><p>响应时间权重策略（WeightedResponseTimeRule）</p><p>策略描述：根据响应时间，分配一个权重weight，响应时间越长，weight越小，被选中的可能性越低。</p></li><li><p>轮询失败重试策略（RetryRule）</p><p>轮询失败重试策略（RetryRule）是这样工作的，首先使用轮询策略进行负载均衡，如果轮询失败，则再使用轮询策略进行一次重试，相当于重试下一个节点，看下一个节点是否可用，如果再失败，则直接返回失败。</p></li><li><p>并发量最小可用策略（BestAvailableRule）</p><p>选择一个并发量最小的server返回。如何判断并发量最小呢？ServerStats有个属性activeRequestCount，这个属性记录的就是server的并发量。轮询所有的server，选择其中activeRequestCount最小的那个server，就是并发量最小的服务节点。</p></li><li><p>ZoneAvoidanceRule</p><p>复合判断server所在区域的性能和server的可用性，来选择server返回。</p></li></ul><p>综述负载均衡策略如下：</p><ol><li>轮询策略</li><li>随机策略</li><li>可用过滤策略</li><li>响应时间权重策略</li><li>轮询失败重试策略</li><li>并发量最小可用策略</li></ol><p>Ribbon中还包括以下功能：</p><ul><li>易于与服务发现组件（比如Netflix的Eureka）集成</li><li>使用Archaius完成运行时配置</li><li>使用JMX暴露运维指标，使用Servo发布</li><li>多种可插拔的序列化选择</li><li>异步和批处理操作（即将推出）</li><li>自动SLA框架（即将推出）</li><li>系统管理&#x2F;指标控制台（即将推出）</li></ul><p><strong>ribbon架构示例</strong></p><img src="/posts/b27a891c/159.jpg" style="zoom:80%;"><ul><li>一个服务注册中心，eureka server,端口为8761</li><li>service-hi工程跑了两个实例，端口分别为8762,8763，分别向服务注册中心注册</li><li>sercvice-ribbon端口为8764,向服务注册中心注册</li><li>当sercvice-ribbon通过restTemplate调用service-hi的hi接口时，因为用ribbon进行了负载均衡，会轮流的调用service-hi：8762和8763 两个端口的hi接口；</li></ul><h2 id="Config-Server"><a href="#Config-Server" class="headerlink" title="Config Server"></a>Config Server</h2><p>涉及注解：@EnableConfigServer</p><p>俗称的配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，<strong>目前支持本地存储、Git以及Subversion</strong>。</p><img src="/posts/b27a891c/160.jpg" style="zoom:80%;"><blockquote><p>将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件。这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p></blockquote><img src="/posts/b27a891c/161.jpg" style="zoom:80%;"><p>Spring Cloud Config就是我们通常意义上的配置中心。Spring Cloud Config-把应用原本放在本地文件的配置抽取出来放在<strong>中心服务器</strong>，本质是配置信息从本地迁移到云端。从而能够提供更好的管理、发布能力。 Spring Cloud Config分服务端和客户端，服务端负责将git（svn）中存储的配置文件发布成REST接口，客户端可以从服务端REST接口获取配置。但客户端并不能主动感知到配置的变化，从而主动去获取新的配置，这需要每个客户端通过POST方法触发各自的&#x2F;refresh。</p><h2 id="Hystrix-熔断器"><a href="#Hystrix-熔断器" class="headerlink" title="Hystrix 熔断器"></a>Hystrix 熔断器</h2><p>涉及注解：@HystrixCommad(fallback&#x3D;”方法名”)、结合@FeignClient(fallbackFactory&#x3D;xxx.class)</p><p>熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</p><img src="/posts/b27a891c/162.jpg" style="zoom:80%;"><p>断路器(Cricuit Breaker)是一种能够在远程服务不可用时自动熔断(打开开关)，并在远程服务恢复时自动恢复(闭合开关)的设施，Spring Cloud通过Netflix的<strong>Hystrix组件</strong>提供断路器、资源隔离与自我修复功能。</p><p>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p><img src="/posts/b27a891c/163.jpg" alt="img" style="zoom:80%;"><p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p><img src="/posts/b27a891c/164.jpg" alt="img" style="zoom:80%;"><img src="/posts/b27a891c/165.jpg" alt="img" style="zoom:80%;"><p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p><img src="/posts/b27a891c/166.jpg" alt="img" style="zoom:80%;"><p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p><img src="/posts/b27a891c/167.jpg" alt="img" style="zoom:80%;"><p><strong>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值</strong>。</p><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p><p>如下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成了。</p><img src="/posts/b27a891c/168.jpg" alt="img" style="zoom:80%;"><p>在这种情况下就需要整个服务机构具有故障隔离的功能，避免某一个服务挂掉影响全局。<strong>在Spring Cloud 中Hystrix组件就扮演这个角色</strong>。 Hystrix会在某个服务连续调用N次不响应的情况下，立即通知调用端调用失败，避免调用端持续等待而影响了整体服务。Hystrix间隔时间会再次检查此服务，如果服务恢复将继续提供服务。</p><p><strong>Hystrix Dashboard和Turbine</strong> 当熔断发生的时候需要迅速的响应来解决问题，避免故障进一步扩散，那么对熔断的监控就变得非常重要。熔断的监控现在有两款工具：<strong>Hystrix-dashboard</strong>和<strong>Turbine</strong></p><p>Hystrix-dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以直观地看到各Hystrix Command的请求响应时间, 请求成功率等数据。但是只使用Hystrix Dashboard的话, 你只能看到单个应用内的服务信息, 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到Hystrix Dashboard上, 这个工具就是<strong>Turbine</strong>. 监控的效果图如下：</p><img src="/posts/b27a891c/169.jpg" alt="img" style="zoom:80%;"><h2 id="Zuul-服务网关，智能路由"><a href="#Zuul-服务网关，智能路由" class="headerlink" title="Zuul 服务网关，智能路由"></a>Zuul 服务网关，智能路由</h2><p>涉及注解：@EnableZuulProxy</p><p>在微服务架构模式下，后端服务的实例数一般是动态的，对于客户端而言很难发现动态改变的服务实例的访问地址信息。因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。</p><img src="/posts/b27a891c/170.jpg" alt="img" style="zoom:80%;"><p>Spring Cloud体系中支持API Gateway落地的技术就是<strong>Zuul</strong>。Spring Cloud Zuul路由是微服务架构中不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p><p>它的具体作用<strong>就是服务转发，接收并转发所有内外部的客户端调用。使用Zuul可以作为资源的统一访问入口，同时也可以在网关做一些权限校验等类似的功能</strong>。</p><p>Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。</p><img src="/posts/b27a891c/171.jpg" alt="img" style="zoom:80%;"><img src="/posts/b27a891c/172.jpg" alt="img" style="zoom:80%;"><p>类似Nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p><h2 id="Netflix-Archaius"><a href="#Netflix-Archaius" class="headerlink" title="Netflix Archaius"></a>Netflix Archaius</h2><img src="/posts/b27a891c/173.jpg" alt="img" style="zoom:80%;"><p>配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置，原理是<strong>每隔60s（默认，可配置）从配置源读取一次内容</strong>，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用archaius的API来读取。</p><h2 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h2><img src="/posts/b27a891c/174.jpg" alt="img" style="zoom:80%;"><p>事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，<strong>可与Spring Cloud Config联合实现热部署</strong>。相当于水浒传中日行八百里的神行太保戴宗，确保各个小弟之间消息保持畅通。</p><p>分布式消息队列，是对Kafka, MQ的封装；事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现<strong>热部署</strong>。 Spring cloud bus通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其他的消息指令。<strong>Spring bus的一个核心思想是通过分布式的启动器对spring boot应用进行扩展，也可以用来建立一个多个应用之间的通信频道。</strong>目前唯一实现的方式是用AMQP消息代理作为通道，同样特性的设置（有些取决于通道的设置）在更多通道的文档中。 Spring cloud bus被国内很多都翻译为消息总线，也挺形象的。大家可以将它理解为管理和传播所有分布式项目中的消息既可，其实本质是利用了MQ的广播机制在分布式的系统中传播消息，目前常用的有Kafka和RabbitMQ。利用bus的机制可以做很多的事情，其中配置中心客户端刷新就是典型的应用场景之一，我们用一张图来描述bus在配置中心使用的机制。</p><img src="/posts/b27a891c/176.jpg" alt="img" style="zoom:80%;"><p>根据此图我们可以看出利用Spring Cloud Bus做配置更新的步骤:</p><ol><li>提交代码触发post给客户端A发送bus&#x2F;refresh</li><li>客户端A接收到请求从Server端更新配置并且发送给Spring Cloud Bus</li><li>Spring Cloud bus接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求Server端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ol><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><img src="/posts/b27a891c/175.jpg" alt="img" style="zoom:80%;"><p>对Spring Security的封装，并能配合Netflix使用，安全工具包，为你的应用程序添加安全控制，<strong>主要是指OAuth2</strong>。 基于spring security的安全工具包，为你的应用程序添加安全控制</p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><img src="/posts/b27a891c/177.jpg" alt="img" style="zoom:80%;"><p>对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用；操作Zookeeper的工具包，<strong>用于使用zookeeper方式的服务注册和发现</strong>。 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理，抱了Zookeeper的大腿。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><img src="/posts/b27a891c/178.jpg" alt="img" style="zoom:80%;"><p>数据流；数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。 Spring Cloud Stream是创建消息驱动微服务应用的框架。Spring Cloud Stream是基于spring boot创建，用来建立单独的／工业级spring应用，使用spring integration提供与消息代理之间的连接。数据流操作开发包，封装了与Redis、Rabbit、Kafka等发送接收消息。 一个业务会牵扯到多个任务，任务之间是通过事件触发的。</p><h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><img src="/posts/b27a891c/179.jpg" alt="img" style="zoom:80%;"><p>随着服务的越来越多，对调用链的分析会越来越复杂，如服务之间的调用关系、某个请求对应的调用链、调用之间消费的时间等，对这些信息进行监控就成为一个问题。在实际的使用中我们需要监控服务和服务之间通讯的各项指标，这些数据将是我们改进系统架构的主要依据。因此分布式的链路跟踪就变的非常重要，<strong>Spring Cloud也给出了具体的解决方案：Spring Cloud Sleuth和Zipkin</strong>。</p><p>服务跟踪；日志收集工具包，封装了Dapper,Zipkin和HTrace操作。 日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。</p><p><strong>简介</strong></p><p>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。</p><p><strong>服务追踪分析</strong></p><p>微服务架构上通过业务来划分服务的，通过<strong>REST调用</strong>，对外暴露的一个接口，<strong>可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败</strong>。随着业务的不断扩张，服务之间互相调用会越来越复杂。</p><img src="/posts/b27a891c/180.jpg" alt="img" style="zoom:80%;"><p>随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下：</p><img src="/posts/b27a891c/181.jpg" alt="img" style="zoom:80%;"><p><strong>术语</strong></p><ul><li>Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址) span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。</li><li>Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。</li><li>Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束 cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始 sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟 ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间 cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间 将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</li></ul><img src="/posts/b27a891c/182.jpg" alt="img" style="zoom:80%;"><h2 id="Feign-使用HTTP请求远程服务"><a href="#Feign-使用HTTP请求远程服务" class="headerlink" title="Feign 使用HTTP请求远程服务"></a>Feign 使用HTTP请求远程服务</h2><p>涉及注解：@FeignClient(“微服务名称”)　　注：此注解用于接口</p><img src="/posts/b27a891c/183.jpg" alt="img" style="zoom:80%;"><p>在Spring Cloud Netflix栈中，各个微服务都是以HTTP接口的形式暴露自身服务的，因此在调用远程服务时就必须使用HTTP客户端。我们可以使用JDK原生的URLConnection、Apache的Http Client、Netty的异步HTTP Client, Spring的RestTemplate。但是，用起来最方便、最优雅的还是要属Feign了。 <strong>Feign是一种声明式、模板化的HTTP客户端</strong>。在Spring Cloud中使用Feign, 我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。 通过Feign， 我们能把HTTP远程调用对开发者完全透明，得到与调用本地方法一致的编码体验。这一点与阿里Dubbo中暴露远程服务的方式类似，<strong>区别在于Dubbo是基于私有二进制协议，而Feign本质上还是个HTTP客户端</strong>。如果是在用Spring Cloud Netflix搭建微服务，那么Feign无疑是最佳选择。</p><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p><p>简而言之：</p><ul><li>Feign 采用的是基于接口的注解</li><li>Feign 整合了ribbon</li></ul><h2 id="Cloud-Foundry"><a href="#Cloud-Foundry" class="headerlink" title="Cloud Foundry"></a>Cloud Foundry</h2><img src="/posts/b27a891c/184.jpg" alt="img" style="zoom:80%;"><p>Cloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题 其实就是与CloudFoundry进行集成的一套解决方案，抱了<strong>Cloud Foundry</strong>的大腿。</p><h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><img src="/posts/b27a891c/185.jpg" alt="img" style="zoom:80%;"><p>Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：<strong>选举、集群的状态一致性、全局锁、tokens等</strong>常见状态模式的抽象和实现。 如果把不同的帮派组织成统一的整体，Spring Cloud Cluster已经帮你提供了很多方便组织成统一的工具。</p><h2 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h2><img src="/posts/b27a891c/186.jpg" alt="img" style="zoom:80%;"><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,<strong>由 HashiCorp 公司用 Go 语言开发</strong>, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对. Spring Cloud Consul 封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</p><h2 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h2><img src="/posts/b27a891c/187.jpg" alt="img" style="zoom:80%;"><p>Data flow 是一个用于开发和执行大范围数据处理其模式包括ETL，批量运算和持续运算的统一编程模型和托管服务。 对于在现代运行环境中可组合的微服务程序来说，Spring Cloud data flow是一个原生云可编配的服务。使用Spring Cloud data flow，开发者可以为像数据抽取，实时分析，和数据导入&#x2F;导出这种常见用例创建和编配数据通道 （data pipelines）。 Spring Cloud data flow 是基于原生云对 spring XD的重新设计，该项目目标是简化大数据应用的开发。Spring XD 的流处理和批处理模块的重构分别是基于 spring boot的stream 和 task&#x2F;batch 的微服务程序。这些程序现在都是自动部署单元而且他们原生的支持像 Cloud Foundry、Apache YARN、Apache Mesos和Kubernetes 等现代运行环境。 Spring Cloud data flow 为基于微服务的分布式流处理和批处理数据通道提供了一系列模型和最佳实践。</p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><img src="/posts/b27a891c/188.jpg" alt="img" style="zoom:80%;"><p>Spring Cloud Task 主要解决短命微服务的任务管理，任务调度的工作，比如说某些定时任务晚上就跑一次，或者某项数据分析临时就跑几次。</p><h2 id="Spring-Cloud-Connectors"><a href="#Spring-Cloud-Connectors" class="headerlink" title="Spring Cloud Connectors"></a>Spring Cloud Connectors</h2><img src="/posts/b27a891c/189.jpg" alt="img" style="zoom:80%;"><p>Spring Cloud Connectors 简化了连接到服务的过程和从云平台获取操作的过程，有很强的扩展性，可以利用Spring Cloud Connectors来构建你自己的云平台。 便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。</p><h2 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h2><img src="/posts/b27a891c/192.jpg" alt="img" style="zoom:80%;"><p>Spring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。</p><p><strong>3.20、Spring Cloud CLI</strong></p><img src="/posts/b27a891c/190.jpg" alt="img" style="zoom:80%;"><p>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</p><h2 id="Netflix-Turbine"><a href="#Netflix-Turbine" class="headerlink" title="Netflix Turbine"></a>Netflix Turbine</h2><img src="/posts/b27a891c/191.jpg" alt="img" style="zoom:80%;"><p>Turbine是聚合服务器发送事件流数据的一个工具，用来监控集群下hystrix的metrics情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Spring Cloud是一系列框架的有序集合&lt;/strong&gt;。它利用&lt;strong&gt;Spring Boot&lt;/stron</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="Spring" scheme="https://blog.yahyav2rayssr.top/categories/Java/Spring/"/>
    
    
    <category term="springcloud" scheme="https://blog.yahyav2rayssr.top/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring 启动流程</title>
    <link href="https://blog.yahyav2rayssr.top/posts/2547f24d/"/>
    <id>https://blog.yahyav2rayssr.top/posts/2547f24d/</id>
    <published>2023-04-16T13:27:33.944Z</published>
    <updated>2023-04-16T13:27:33.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="springboot-启动过程"><a href="#springboot-启动过程" class="headerlink" title="springboot 启动过程"></a>springboot 启动过程</h2><p>每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，该方法所在类需要使用@SpringBootApplication注解，以及@ImportResource注解(if need)，@SpringBootApplication包括三个注解，功能如下：@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置<br>@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境</p><p>@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下| <img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70.png" class alt="在这里插入图片描述"></p><p>SpringBoot启动类</p><p>首先进入run方法</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157186504864.png" class alt="在这里插入图片描述"><p>run方法中去创建了一个SpringApplication实例，在该构造方法内，我们可以发现其调用了一个初始化的initialize方法</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157187036467.png" class alt="在这里插入图片描述"><p>这里主要是为SpringApplication对象赋一些初值。构造函数执行完毕后，我们回到run方法</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157187444670.png" class alt="在这里插入图片描述"><p>该方法中实现了如下几个关键步骤：</p><p>1.创建了应用的监听器SpringApplicationRunListeners并开始监听</p><p>2.加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment，类图如下</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157188032073.png" class alt="在这里插入图片描述"><p>可以看出，*Environment最终都实现了PropertyResolver接口，我们平时通过environment对象获取配置文件中指定Key对应的value方法时，就是调用了propertyResolver接口的getProperty方法</p><p>3.配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</p><p>4.创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)，我们可以看一下创建方法：</p>，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回，ConfigurableApplicationContext类图如下：<img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157188495079.png" class alt="在这里插入图片描述">主要看其继承的两个方向：<p>LifeCycle：生命周期类，定义了start启动、stop结束、isRunning是否运行中等生命周期空值方法</p><p>ApplicationContext：应用上下文类，其主要继承了beanFactory(bean的工厂类)</p><p>5.回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联</p><p>6.接下来的refreshContext(context)方法(初始化方法如下)将是实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作。</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157188777782.png" class alt="在这里插入图片描述"><p>refresh方法</p><p>配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成，接下来我们来探讨自动化配置是如何实现。</p><h2 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h2><p>之前的启动结构图中，我们注意到无论是应用初始化还是具体的执行过程，都调用了SpringBoot自动配置模块</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157189094485.png" class alt="在这里插入图片描述">SpringBoot自动配置模块<p>该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157189311788.png" class alt="在这里插入图片描述"><p>工厂接口与其若干实现类接口名称</p><p>下图有助于我们形象理解自动配置流程</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157189576091.png" class alt="在这里插入图片描述">SpringBoot自动化配置关键组件关系图<p>mybatis-spring-boot-starter、spring-boot-starter-web等组件的META-INF文件下均含有spring.factories文件，自动配置模块中，SpringFactoriesLoader收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。</p><p>之前我们提到了EnableAutoConfiguration注解，其类图如下</p>，重点关注一下AutoConfigurationImportSelector的selectImports方法<img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157190157197.png" class alt="在这里插入图片描述"><p>该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-1681571903780100.png" class alt="在这里插入图片描述">该方法中的getCandidateConfigurations方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了loadFactoryNames方法，查看该方法到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类。我们就选取这个mybatis-spring-boot-autoconfigure下的spring.factories文件<img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-1681571911818109.png" class alt="在这里插入图片描述">进入org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration中，主要看一下类头<img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-1681571913850112.png" class alt="在这里插入图片描述"><p>发现@Spring的Configuration，俨然是一个通过注解标注的springBean，继续向下看，</p><p>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})这个注解的意思是：当存在SqlSessionFactory.class, SqlSessionFactoryBean.class这两个类时才解析MybatisAutoConfiguration配置类,否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类</p><p>@CondtionalOnBean(DataSource.class):只有处理已经被声明为bean的dataSource</p><p>@ConditionalOnMissingBean(MapperFactoryBean.class)这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）</p><p>以上配置可以保证sqlSessionFactory、sqlSessionTemplate、dataSource等mybatis所需的组件均可被自动配置，@Configuration注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过mybatis.xml文件进行配置起到一个效果。通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在SqlSessionFactory.class, SqlSessionFactoryBean.class，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：</p><img src="/posts/2547f24d/20190903091234532.png" class alt="在这里插入图片描述"><p>这里是截取的mybatis-spring-boot-starter的源码中pom.xml文件中所有依赖:</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-1681571923035117.png" class alt="在这里插入图片描述">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h2 id=&quot;springboot-启动过程&quot;&gt;&lt;a href=&quot;#springboot-启动过程&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="Spring" scheme="https://blog.yahyav2rayssr.top/categories/Java/Spring/"/>
    
    
    <category term="spring" scheme="https://blog.yahyav2rayssr.top/tags/spring/"/>
    
    <category term="springboot" scheme="https://blog.yahyav2rayssr.top/tags/springboot/"/>
    
  </entry>
  
  <entry>
    <title>JVM 指令大全</title>
    <link href="https://blog.yahyav2rayssr.top/posts/7c42c21b/"/>
    <id>https://blog.yahyav2rayssr.top/posts/7c42c21b/</id>
    <published>2023-04-16T12:24:49.993Z</published>
    <updated>2023-04-16T12:24:49.993Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-指令大全"><a href="#JVM-指令大全" class="headerlink" title="JVM 指令大全"></a>JVM 指令大全</h1><h2 id="栈和局部变量操作"><a href="#栈和局部变量操作" class="headerlink" title="栈和局部变量操作"></a>栈和局部变量操作</h2><h3 id="将常量压入栈的指令"><a href="#将常量压入栈的指令" class="headerlink" title="将常量压入栈的指令"></a>将常量压入栈的指令</h3><ul><li><p>aconst_null 将null对象引用压入栈</p></li><li><p>iconst_m1 将int类型常量-1压入栈</p></li><li><p>iconst_0 将int类型常量0压入栈</p></li><li><p>iconst_1 将int类型常量1压入栈</p></li><li><p>iconst_2 将int类型常量2压入栈</p></li><li><p>iconst_3 将int类型常量3压入栈</p></li><li><p>iconst_4 将int类型常量4压入栈</p></li><li><p>iconst_5 将int类型常量5压入栈</p></li><li><p>lconst_0 将long类型常量0压入栈</p></li><li><p>lconst_1 将long类型常量1压入栈</p></li><li><p>fconst_0 将float类型常量0压入栈</p></li><li><p>fconst_1 将float类型常量1压入栈</p></li><li><p>dconst_0 将double类型常量0压入栈</p></li><li><p>dconst_1 将double类型常量1压入栈 </p></li><li><p>bipush 将一个8位带符号整数压入栈</p></li><li><p>sipush 将16位带符号整数压入栈</p></li><li><p>ldc 把常量池中的项压入栈</p></li><li><p>ldc_w 把常量池中的项压入栈（使用宽索引）</p></li><li><p>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</p></li></ul><h3 id="从栈中的局部变量中装载值的指令"><a href="#从栈中的局部变量中装载值的指令" class="headerlink" title="从栈中的局部变量中装载值的指令"></a>从栈中的局部变量中装载值的指令</h3><ul><li><p>iload 从局部变量中装载int类型值</p></li><li><p>lload 从局部变量中装载long类型值</p></li><li><p>fload 从局部变量中装载float类型值</p></li><li><p>dload 从局部变量中装载double类型值</p></li><li><p>aload 从局部变量中装载引用类型值（refernce）</p></li><li><p>iload_0 从局部变量0中装载int类型值</p></li><li><p>iload_1 从局部变量1中装载int类型值</p></li><li><p>iload_2 从局部变量2中装载int类型值</p></li><li><p>iload_3 从局部变量3中装载int类型值</p></li><li><p>lload_0 从局部变量0中装载long类型值</p></li><li><p>lload_1 从局部变量1中装载long类型值</p></li><li><p>lload_2 从局部变量2中装载long类型值</p></li><li><p>lload_3 从局部变量3中装载long类型值</p></li><li><p>fload_0 从局部变量0中装载float类型值</p></li><li><p>fload_1 从局部变量1中装载float类型值</p></li><li><p>fload_2 从局部变量2中装载float类型值</p></li><li><p>fload_3 从局部变量3中装载float类型值</p></li><li><p>dload_0 从局部变量0中装载double类型值</p></li><li><p>dload_1 从局部变量1中装载double类型值</p></li><li><p>dload_2 从局部变量2中装载double类型值</p></li><li><p>dload_3 从局部变量3中装载double类型值</p></li><li><p>aload_0 从局部变量0中装载引用类型值</p></li><li><p>aload_1 从局部变量1中装载引用类型值</p></li><li><p>aload_2 从局部变量2中装载引用类型值</p></li><li><p>aload_3 从局部变量3中装载引用类型值</p></li><li><p>iaload 从数组中装载int类型值</p></li><li><p>laload 从数组中装载long类型值</p></li><li><p>faload 从数组中装载float类型值</p></li><li><p>daload 从数组中装载double类型值</p></li><li><p>aaload 从数组中装载引用类型值</p></li><li><p>baload 从数组中装载byte类型或boolean类型值</p></li><li><p>caload 从数组中装载char类型值</p></li><li><p>saload 从数组中装载short类型值</p></li></ul><h3 id="将栈中的值存入局部变量的指令"><a href="#将栈中的值存入局部变量的指令" class="headerlink" title="将栈中的值存入局部变量的指令"></a>将栈中的值存入局部变量的指令</h3><ul><li><p>istore 将int类型值存入局部变量</p></li><li><p>lstore 将long类型值存入局部变量</p></li><li><p>fstore 将float类型值存入局部变量</p></li><li><p>dstore 将double类型值存入局部变量</p></li><li><p>astore 将将引用类型或returnAddress类型值存入局部变量</p></li><li><p>istore_0 将int类型值存入局部变量0</p></li><li><p>istore_1 将int类型值存入局部变量1</p></li><li><p>istore_2 将int类型值存入局部变量2</p></li><li><p>istore_3 将int类型值存入局部变量3</p></li><li><p>lstore_0 将long类型值存入局部变量0</p></li><li><p>lstore_1 将long类型值存入局部变量1</p></li><li><p>lstore_2 将long类型值存入局部变量2</p></li><li><p>lstore_3 将long类型值存入局部变量3</p></li><li><p>fstore_0 将float类型值存入局部变量0</p></li><li><p>fstore_1 将float类型值存入局部变量1</p></li><li><p>fstore_2 将float类型值存入局部变量2</p></li><li><p>fstore_3 将float类型值存入局部变量3</p></li><li><p>dstore_0 将double类型值存入局部变量0</p></li><li><p>dstore_1 将double类型值存入局部变量1</p></li><li><p>dstore_2 将double类型值存入局部变量2</p></li><li><p>dstore_3 将double类型值存入局部变量3</p></li><li><p>astore_0 将引用类型或returnAddress类型值存入局部变量0</p></li><li><p>astore_1 将引用类型或returnAddress类型值存入局部变量1</p></li><li><p>astore_2 将引用类型或returnAddress类型值存入局部变量2</p></li><li><p>astore_3 将引用类型或returnAddress类型值存入局部变量3</p></li><li><p>iastore 将int类型值存入数组中</p></li><li><p>lastore 将long类型值存入数组中</p></li><li><p>fastore 将float类型值存入数组中</p></li><li><p>dastore 将double类型值存入数组中</p></li><li><p>aastore 将引用类型值存入数组中</p></li><li><p>bastore 将byte类型或者boolean类型值存入数组中</p></li><li><p>castore 将char类型值存入数组中</p></li><li><p>sastore 将short类型值存入数组中</p></li></ul><h2 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h2><p>wide 使用附加字节扩展局部变量索引</p><p>通用(无类型）栈操作</p><ul><li><p>nop 不做任何操作</p></li><li><p>pop 弹出栈顶端一个字长的内容</p></li><li><p>pop2 弹出栈顶端两个字长的内容</p></li><li><p>dup 复制栈顶部一个字长内容</p></li><li><p>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈</p></li><li><p>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p></li><li><p>dup2 复制栈顶部两个字长内容</p></li><li><p>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p></li><li><p>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈</p></li><li><p>swap 交换栈顶部两个字长内容</p></li></ul><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li><p>i2l 把int类型的数据转化为long类型</p></li><li><p>i2f 把int类型的数据转化为float类型</p></li><li><p>i2d 把int类型的数据转化为double类型 </p></li><li><p>l2i 把long类型的数据转化为int类型</p></li><li><p>l2f 把long类型的数据转化为float类型</p></li><li><p>l2d 把long类型的数据转化为double类型 </p></li><li><p>f2i 把float类的数据转化为int类型</p></li><li><p>f2l 把float类型的数据转化为long类型</p></li><li><p>f2d 把float类型的数据转化为double类型</p></li><li><p>d2i 把double类型的数据转化为int类型</p></li><li><p>d2l 把double类型的数据转化为long类型</p></li><li><p>d2f 把double类型的数据转化为float类型</p></li><li><p>i2b 把int类型的数据转化为byte类型</p></li><li><p>i2c 把int类型的数据转化为char类型</p></li><li><p>i2s 把int类型的数据转化为short类型</p></li></ul><h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><ul><li><p>iadd 执行int类型的加法</p></li><li><p>ladd 执行long类型的加法</p></li><li><p>isub 执行int类型的减法</p></li><li><p>lsub 执行long类型的减法</p></li><li><p>imul 执行int类型的乘法</p></li><li><p>lmul 执行long类型的乘法</p></li><li><p>idiv 执行int类型的除法</p></li><li><p>ldiv 执行long类型的除法</p></li><li><p>irem 计算int类型除法的余数</p></li><li><p>lrem 计算long类型除法的余数</p></li><li><p>ineg 对一个int类型值进行取反操作</p></li><li><p>lneg 对一个long类型值进行取反操作</p></li><li><p>iinc 把一个常量值加到一个int类型的局部变量上</p></li></ul><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><ul><li><p>ishl 执行int类型的向左移位操作</p></li><li><p>lshl 执行long类型的向左移位操作</p></li><li><p>ishr 执行int类型的向右移位操作 </p></li><li><p>lshr 执行long类型的向右移位操作</p></li><li><p>iushr 执行int类型的向右逻辑移位操作 </p></li><li><p>lushr 执行long类型的向右逻辑移位操作</p></li></ul><h3 id="按位布尔运算"><a href="#按位布尔运算" class="headerlink" title="按位布尔运算"></a>按位布尔运算</h3><ul><li><p>iand 对int类型值进行“逻辑与”操作</p></li><li><p>land 对long类型值进行“逻辑与”操作</p></li><li><p>ior 对int类型值进行“逻辑或”操作</p></li><li><p>lor 对long类型值进行“逻辑或”操作</p></li><li><p>ixor 对int类型值进行“逻辑异或”操作</p></li><li><p>lxor 对long类型值进行“逻辑异或”操作</p></li></ul><h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><ul><li><p>fadd 执行float类型的加法 </p></li><li><p>dadd 执行double类型的加法</p></li><li><p>fsub 执行float类型的减法</p></li><li><p>dsub 执行double类型的减法 </p></li><li><p>fmul 执行float类型的乘法</p></li><li><p>dmul 执行double类型的乘法</p></li><li><p>fdiv 执行float类型的除法 </p></li><li><p>ddiv 执行double类型的除法 </p></li><li><p>frem 计算float类型除法的余数</p></li><li><p>drem 计算double类型除法的余数 </p></li><li><p>fneg 将一个float类型的数值取反 </p></li><li><p>dneg 将一个double类型的数值取反</p></li></ul><h2 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h2><h3 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h3><ul><li><p>new 创建一个新对象</p></li><li><p>checkcast 确定对象为所给定的类型</p></li><li><p>getfield 从对象中获取字段</p></li><li><p>putfield 设置对象中字段的值</p></li><li><p>getstatic 从类中获取静态字段</p></li><li><p>putstatic 设置类中静态字段的值</p></li><li><p>instanceof 判断对象是否为给定的类型</p></li></ul><h3 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h3><ul><li><p>newarray 分配数据成员类型为基本上数据类型的新数组</p></li><li><p>anewarray 分配数据成员类型为引用类型的新数组</p></li><li><p>arraylength 获取数组长度</p></li><li><p>multianewarray 分配新的多维数组</p></li></ul><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h3><ul><li><p>ifeq 如果等于0，则跳转</p></li><li><p>ifne 如果不等于0，则跳转</p></li><li><p>iflt 如果小于0，则跳转</p></li><li><p>ifge 如果大于等于0，则跳转</p></li><li><p>ifgt 如果大于0，则跳转</p></li><li><p>ifle 如果小于等于0，则跳转</p></li><li><p>if_icmpcq 如果两个int值相等，则跳转 </p></li><li><p>if_icmpne 如果两个int类型值不相等，则跳转</p></li><li><p>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转</p></li><li><p>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转</p></li><li><p>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转</p></li><li><p>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转 </p></li><li><p>ifnull 如果等于null，则跳转</p></li><li><p>ifnonnull 如果不等于null，则跳转</p></li><li><p>if_acmpeq 如果两个对象引用相等，则跳转 </p></li><li><p>if_acmpnc 如果两个对象引用不相等，则跳转</p></li></ul><h3 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h3><ul><li><p>lcmp 比较long类型值</p></li><li><p>fcmpl 比较float类型值（当遇到NaN时，返回-1）</p></li><li><p>fcmpg 比较float类型值（当遇到NaN时，返回1）</p></li><li><p>dcmpl 比较double类型值（当遇到NaN时，返回-1）</p></li><li><p>dcmpg 比较double类型值（当遇到NaN时，返回1）</p></li></ul><h3 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h3><ul><li><p>goto 无条件跳转</p></li><li><p>goto_w 无条件跳转（宽索引）</p></li></ul><h3 id="表跳转指令"><a href="#表跳转指令" class="headerlink" title="表跳转指令"></a>表跳转指令</h3><ul><li><p>tableswitch 通过索引访问跳转表，并跳转</p></li><li><p>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p></li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li><p>athrow 抛出异常或错误 </p></li><li><p>finally子句</p></li><li><p>jsr 跳转到子例程</p></li><li><p>jsr_w 跳转到子例程（宽索引）</p></li><li><p>rct 从子例程返回</p></li></ul><h2 id="方法调用与返回"><a href="#方法调用与返回" class="headerlink" title="方法调用与返回"></a>方法调用与返回</h2><h3 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h3><ul><li><p>invokcvirtual 运行时按照对象的类来调用实例方法</p></li><li><p>invokespecial 根据编译时类型来调用实例方法</p></li><li><p>invokestatic 调用类（静态）方法</p></li><li><p>invokcinterface 调用接口方法</p></li></ul><h3 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h3><ul><li><p>ireturn 从方法中返回int类型的数据</p></li><li><p>lreturn 从方法中返回long类型的数据</p></li><li><p>freturn 从方法中返回float类型的数据 </p></li><li><p>dreturn 从方法中返回double类型的数据 </p></li><li><p>areturn 从方法中返回引用类型的数据</p></li><li><p>return 从方法中返回，返回值为void</p></li></ul><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><ul><li><p>montiorenter 进入并获取对象监视器</p></li><li><p>monitorexit 释放并退出对象监视器</p></li></ul><h2 id="JVM指令助记符"><a href="#JVM指令助记符" class="headerlink" title="JVM指令助记符"></a>JVM指令助记符</h2><ul><li><p>变量到操作数栈：iload,iload_,lload,lload_,fload,fload_,dload,dload_,aload,aload_</p></li><li><p>操作数栈到变量：istore,istore_,lstore,lstore_,fstore,fstore_,dstore,dstor_,astore,astore_</p></li><li><p>常数到操作数栈：bipush,sipush,ldc,ldc_w,ldc2_w,aconst_null,iconst_ml,iconst_,lconst_,fconst_,dconst_ </p></li><li><p>加：iadd,ladd,fadd,dadd</p></li><li><p>减：isub,lsub,fsub,dsub</p></li><li><p>乘：imul,lmul,fmul,dmul</p></li><li><p>除：idiv,ldiv,fdiv,ddiv</p></li><li><p>余数：irem,lrem,frem,drem </p></li><li><p>取负：ineg,lneg,fneg,dneg</p></li><li><p>移位：ishl,lshr,iushr,lshl,lshr,lushr</p></li><li><p>按位或：ior,lor</p></li><li><p>按位与：iand,land </p></li><li><p>按位异或：ixor,lxor</p></li><li><p>类型转换：i2l,i2f,i2d,l2f,l2d,f2d(放宽数值转换) </p></li><li><p>i2b,i2c,i2s,l2i,f2i,f2l,d2i,d2l,d2f(缩窄数值转换)</p></li><li><p>创建类实便：new</p></li><li><p>创建新数组：newarray,anewarray,multianwarray </p></li><li><p>访问类的域和类实例域：getfield,putfield,getstatic,putstatic </p></li><li><p>把数据装载到操作数栈：baload,caload,saload,iaload,laload,faload,daload,aaload</p></li><li><p>从操作数栈存存储到数组：bastore,castore,sastore,iastore,lastore,fastore,dastore,aastore</p></li><li><p>获取数组长度：arraylength</p></li><li><p>检相类实例或数组属性：instanceof,checkcast </p></li><li><p>操作数栈管理：pop,pop2,dup,dup2,dup_xl,dup2_xl,dup_x2,dup2_x2,swap</p></li><li><p>有条件转移：ifeq,iflt,ifle,ifne,ifgt,ifge,ifnull,ifnonnull,if_icmpeq,if_icmpene,if_icmplt,if_icmpgt,if_icmple,if_icmpge,if_acmpeq,if_acmpne,lcmp,fcmpl,fcmpg,dcmpl,dcmpg </p></li><li><p>复合条件转移：tableswitch,lookupswitch</p></li><li><p>无条件转移：goto,goto_w,jsr,jsr_w,ret</p></li><li><p>调度对象的实便方法：invokevirtual</p></li><li><p>调用由接口实现的方法：invokeinterface</p></li><li><p>调用需要特殊处理的实例方法：invokespecial</p></li><li><p>调用命名类中的静态方法：invokestatic</p></li><li><p>方法返回：ireturn,lreturn,freturn,dreturn,areturn,return</p></li><li><p>异常：athrow</p></li><li><p>finally关键字的实现使用：jsr,jsr_w,ret</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM-指令大全&quot;&gt;&lt;a href=&quot;#JVM-指令大全&quot; class=&quot;headerlink&quot; title=&quot;JVM 指令大全&quot;&gt;&lt;/a&gt;JVM 指令大全&lt;/h1&gt;&lt;h2 id=&quot;栈和局部变量操作&quot;&gt;&lt;a href=&quot;#栈和局部变量操作&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="JVM" scheme="https://blog.yahyav2rayssr.top/categories/Java/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.yahyav2rayssr.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 杂项</title>
    <link href="https://blog.yahyav2rayssr.top/posts/1b362162/"/>
    <id>https://blog.yahyav2rayssr.top/posts/1b362162/</id>
    <published>2023-04-16T12:11:46.542Z</published>
    <updated>2023-04-16T12:11:46.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><img src="/posts/1b362162/image-20200902000129644.png" alt="image-20200902000129644" style="zoom: 33%;"><h2 id="JVM执行引擎"><a href="#JVM执行引擎" class="headerlink" title="JVM执行引擎"></a>JVM执行引擎</h2><img src="/posts/1b362162/image-20200902000245071.png" alt="image-20200902000245071" style="zoom:33%;"><h2 id="类加载器种类"><a href="#类加载器种类" class="headerlink" title="类加载器种类"></a>类加载器种类</h2><img src="/posts/1b362162/image-20200902000355284.png" alt="image-20200902000355284" style="zoom:33%;"><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><img src="/posts/1b362162/image-20200902000331784.png" alt="image-20200902000331784" style="zoom:33%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h2 id=&quot;类加载过程&quot;&gt;&lt;a href=&quot;#类加载过程&quot; class=&quot;headerlink&quot; title=&quot;类加载过程&quot;&gt;&lt;/a&gt;类加载过</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="JVM" scheme="https://blog.yahyav2rayssr.top/categories/Java/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.yahyav2rayssr.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 运行时数据区域</title>
    <link href="https://blog.yahyav2rayssr.top/posts/703fe08b/"/>
    <id>https://blog.yahyav2rayssr.top/posts/703fe08b/</id>
    <published>2023-04-16T12:11:21.193Z</published>
    <updated>2023-04-16T12:11:21.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><img src="/posts/703fe08b/11.jpg" class><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器占用较小的内存空间，可以看做是<strong>当前线程所执行的字节码的行号指示器</strong>，由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说就是一个内核）都只会执行一条线程中的指令。因此，<strong>为了线程切换后能够恢复到正确的执行位置</strong>，每条线程都需要有一个独立的程序计数器。</p><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>虚拟机栈也是线程私有，而且生命周期与线程相同，每个Java方法在执行的时候都会创建一个栈帧（Stack Frame）用于存储<strong>局部变量表、操作数栈、动态链接、方法出口</strong>等信息。</p><ul><li>局部变量表：存放了编译器可知的<strong>各种基本数据类型</strong>（boolean、byte等）、<strong>对象引用</strong>（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向另一个代表对象的句柄或其他次对象相关的位置）和<strong>returnAddress类型</strong>（指向了一条字节码指令的地址）</li></ul><img src="/posts/703fe08b/12.jpg" class><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法占（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）方法服务</strong>。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><strong>Java堆（Java Heap）的唯一目的就是存放对象实例</strong>，Java世界里“几乎”所有的对象实例都在这里分配内存。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区（Method Area）Java堆一样，是各个线程共享的内存区域，用于<strong>存储已被虚拟机加载的类型信息、常量（final）、静态变量、即时编译器编译后的代码等数据</strong>；别名叫做“非堆”（Non-Heap），目的是与Java堆区分开来。</p><blockquote><p>JDK8中完全废弃了永久代的概念，改用在本地内存中实现的元空间（Meta-space）来代替，把JDK7中永久代剩余的内容（主要是类型信息）全部移到元空间中。</p></blockquote><p>方法区的内存回收目标主要是针对<strong>常量池的回收和对类型的卸载</strong>（此部分比较苛刻）。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Running Constant Pool）是方法区的一部分；运行时常量池相对于Class文件常量池的另外一个重要特性是<strong>动态性</strong>，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性本开发人员用得比较多的便是String类的intern()方法。</p><p><strong>JDK1.7之后被移动到堆中了。</strong></p><img src="/posts/703fe08b/43.jpg" class><h4 id="intern方法详解"><a href="#intern方法详解" class="headerlink" title="intern方法详解"></a>intern方法详解</h4><p>String.intern()是一个Native(本地)方法，它的作用是如果<strong>字符串常量池已经包含一个等于此String对象的字符串，则返回字符串常量池中这个字符串的引用</strong>, <strong>否则将当前String对象的引用地址（堆中）添加到字符串常量池中并返回</strong>。</p><blockquote><p>由于intern(）操作每次都需要与常量池中的数据进行比较以查看常量池中是否存在等值数据，同时JVM需要确保常量池中的数据的唯一性，这就涉及到加锁机制，这些操作都是有需要占用CPU时间的，所以如果进行intern操作的是大量不会被重复利用的String的话，则有点得不偿失。由此可见，String.intern()主要 <strong>适用于只有有限值，并且这些有限值会被重复利用的场景</strong>，如：数据库表中的列名、人的姓氏、编码类型等。</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-comment">// 1： 首先会在Heap中创建对象，然后在常量池中放入zhagnsan 和 wangwu ，但是并不会放入zhagnsanwangwu</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;zhangsan&quot;</span>) + <span class="hljs-string">&quot;wangwu&quot;</span>;<br>      <span class="hljs-comment">// 2：调用 intern ，因为字符串常量池中没有”zhangsanwangwu”这种拼接后的字符串，所以将堆中String对象的引用地址添加到字符串常量池中。jdk1.7后常量池引入到了Heap中，所以可以直接存储引用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a.intern();<br>      <span class="hljs-comment">// 3：因为 a 的地址和 b的地址一致，所以是true</span><br>        System.out.println(a == b);<br>      <br>      <span class="hljs-comment">// 4：因常量池中已经存在 zhangsanwangwu 了，所以直接返回引用就是 a 类型 a ==b 锁 a==b==c</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;zhangsanwangwu&quot;</span>;<br>        System.out.println(a == c); <span class="hljs-comment">// true</span><br>      System.out.println(b == c); <span class="hljs-comment">// true</span><br>      <br>      <span class="hljs-comment">// 5：首先会在Heap中创建对象，然后会在常量池中存储 zhang 和 san</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;zhang&quot;</span>) + <span class="hljs-string">&quot;san&quot;</span>;<br>      <span class="hljs-comment">// 6： 返回的是 常量池中的 地址，因在a变量时已经将 zhangsan 放入到了常量池中</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> d.intern();<br>      System.out.println(d == f); <span class="hljs-comment">// false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Class文件常量池"><a href="#Class文件常量池" class="headerlink" title="Class文件常量池"></a>Class文件常量池</h4><p>Class文件常量池，用于存放编译期生成的各种<strong>字面量和符号引用</strong>，这部分内容将在类加载后进入方法区的运行时常量池中存放。运行时常量池中主要存放两大类常量：<strong>字面量和符号引用。当Class文件常量池加载到方法区时，会把符号引用转换为直接引用，存放到运行时常量池。</strong></p><img src="/posts/703fe08b/44.jpg" class><img src="/posts/703fe08b/45.jpg" class><blockquote><p>除了字符串常量池，8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 <code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Character</code> 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池，超出此范围仍然会去创建新的对象。</p></blockquote><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>NIO（New Input&#x2F;Output）类是一种引入了一种基于通道（Channel）与缓冲区（Buffer）的I&#x2F;O方式的操作类，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p><h1 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h1><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程，在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存大小在类加载完成之后便可完全确定，为对象分配内存的任务实际上便等同于把一块确定大小的内存块从Java堆中划分出来。</p><h2 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h2><h3 id="指针碰撞"><a href="#指针碰撞" class="headerlink" title="指针碰撞"></a>指针碰撞</h3><p>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空间的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存仅仅是把那个指针向空闲方向挪动一段与对象大小相等的距离，这种分配方式叫做<strong>指针碰撞</strong>（Bump the barrier）。</p><h3 id="空闲列表"><a href="#空闲列表" class="headerlink" title="空闲列表"></a>空闲列表</h3><p>但如果Java堆中的内存并不是规整的，虚拟机就必须维护一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新记录上的记录，这种分配方式成为<strong>空闲列表</strong>。</p><blockquote><p>实际上使用哪种内存分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器<strong>是否带有空间压缩整理（Compact）的能力</strong>决定。因此，当使用Serial，ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效；而当使用CMS这种基于清除（Sweep）算法的收集器时，<strong>理论上</strong>就只能采用较为复杂的空闲列表来分配内存。</p><p>虚拟机是采用CAS配上失败重试的方法保证更新操作的原子性；另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲区</strong>（Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配内存，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过<code>-XX:+/-UseTLAB</code>参数来设定。</p></blockquote><h1 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h1><img src="/posts/703fe08b/image-20200913095535261.png" class alt="image-20200913095535261"><img src="/posts/703fe08b/image-20200913101857388.png" class alt="image-20200913101857388"><p>对象在堆内存中的存储布局可以划分为三个部分：<strong>对象头</strong>（Header），<strong>实例数据</strong>（Instance Data）和<strong>对齐填充</strong>（Padding）。</p><p><strong>内存布局图</strong>：</p><img src="/posts/703fe08b/13.png" class><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>HotSpot虚拟机的<strong>对象头</strong>包括两部分信息，第一部分是<strong>“Mark Word</strong>”，用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等。</p><h3 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h3><p>Mark Word记录了对象和锁有关的信息，当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。</p><p>Mark Word在32位JVM中的长度是32bit，在64位JVM中长度是64bit。</p><p>Mark Word在不同的锁状态下存储的内容不同，在32位JVM中是这么存的：</p><img src="/posts/703fe08b/image-20200906225322365.png" alt="image-20200906225322365"><table><thead><tr><th><strong>存储内容</strong></th><th><strong>标志位</strong></th><th><strong>状态</strong></th></tr></thead><tbody><tr><td>对象哈希码、对象分代年龄</td><td>01</td><td>未锁定</td></tr><tr><td>指向锁记录的指针</td><td>00</td><td>轻量级锁定</td></tr><tr><td>指向重量级锁的指针</td><td>10</td><td>膨胀（重量级锁定）</td></tr><tr><td>空，不需要记录信息</td><td>11</td><td>GC标记</td></tr><tr><td>偏向线程ID、偏向时间戳、对象分代年龄<br>偏向锁线程ID、epoch、对象分代年龄、偏向锁标识</td><td>01</td><td>可偏向</td></tr></tbody></table><img src="/posts/703fe08b/14.png" class><h4 id="重量级锁-Monitor"><a href="#重量级锁-Monitor" class="headerlink" title="重量级锁-Monitor"></a>重量级锁-Monitor</h4><p>Mark Word 状态取决于 Monitor 锁，Monitor 锁必须加 synchronized 锁才会生效</p><img src="/posts/703fe08b/image-20200913102643892.png" alt="image-20200913102643892" style="zoom: 33%;"><p>例子：</p><blockquote><p>synchronized 通过一个 lock 引用 找到 monitor 对象来操控 Mark Word 头里面的内容。</p></blockquote><img src="/posts/703fe08b/image-20200913104011024.png" alt="image-20200913104011024" style="zoom: 33%;"><img src="/posts/703fe08b/image-20200913103948183.png" alt="image-20200913103948183" style="zoom:33%;"><h4 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h4><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><img src="/posts/703fe08b/image-20200913113443514.png" alt="image-20200913113443514" style="zoom: 50%;"><h6 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h6><img src="/posts/703fe08b/image-20200913113818910.png" alt="image-20200913113818910" style="zoom:50%;"><img src="/posts/703fe08b/image-20200913114538933.png" alt="image-20200913114538933" style="zoom: 50%;"><img src="/posts/703fe08b/image-20200913115504641.png" alt="image-20200913115504641" style="zoom: 50%;"><h6 id="撤销-调用对象的-HashCode"><a href="#撤销-调用对象的-HashCode" class="headerlink" title="撤销-调用对象的 HashCode"></a>撤销-调用对象的 HashCode</h6><img src="/posts/703fe08b/image-20200913120113450.png" alt="image-20200913120113450" style="zoom: 50%;"><h6 id="撤销-其他线程使用对象"><a href="#撤销-其他线程使用对象" class="headerlink" title="撤销-其他线程使用对象"></a>撤销-其他线程使用对象</h6><h6 id="撤销-调用wait-x2F-notify"><a href="#撤销-调用wait-x2F-notify" class="headerlink" title="撤销-调用wait&#x2F;notify"></a>撤销-调用wait&#x2F;notify</h6><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h6><img src="/posts/703fe08b/image-20200913121419831.png" alt="image-20200913121419831" style="zoom:50%;"><h6 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h6><img src="/posts/703fe08b/image-20200913153300105.png" alt="image-20200913153300105" style="zoom:50%;"><h5 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h5><blockquote><p>信息存储在当前线程的栈帧里的锁记录（Lock Record）里面。</p></blockquote><h6 id="加锁流程"><a href="#加锁流程" class="headerlink" title="加锁流程"></a>加锁流程</h6><img src="/posts/703fe08b/image-20200913110754925.png" alt="image-20200913110754925"><img src="/posts/703fe08b/image-20200913111159080.png" alt="image-20200913111159080" style="zoom: 50%;"><h6 id="解锁流程"><a href="#解锁流程" class="headerlink" title="解锁流程"></a>解锁流程</h6><img src="/posts/703fe08b/image-20200913111333013.png" alt="image-20200913111333013" style="zoom: 50%;"><h5 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h5><img src="/posts/703fe08b/image-20200913112046793.png" alt="image-20200913112046793" style="zoom:50%;"><img src="/posts/703fe08b/image-20200913112126073.png" class alt="image-20200913112126073"><img src="/posts/703fe08b/image-20200913112002946.png" class alt="image-20200913112002946"><h5 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h5><img src="/posts/703fe08b/image-20200913112336880.png" class alt="image-20200913112336880"><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-comment">// 预热次数</span><br><span class="hljs-meta">@Warmup(iterations=3)</span><br><span class="hljs-comment">// 测试次数</span><br><span class="hljs-meta">@Measurement(iterations=5)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBenchmark</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        x++;<br>    &#125;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-comment">// JIT  即时编译器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-keyword">synchronized</span> (o) &#123;<br>            x++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><p>默认开启优化，可用<code>-XX:-EliminateLocks</code>禁用</p><img src="/posts/703fe08b/image-20200913155025000.png" class alt="image-20200913155025000"><h3 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h3><p>对象头的另一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>实例数据是对象真正存储的有效信息，即我们在程序代码里面所以定义的各种类型的字段内容。</p><blockquote><ul><li><p>-XX:FieldsAllocationStyle</p><p>实例数据的字段的存储顺序受此参数影响，相同宽度的字段总是被分配到一起存放。</p><p>HotSpot虚拟机默认的分配顺序为longs&#x2F;doubles、ints、shorts&#x2F;chars、bytes&#x2F;booleans、oops（Ordinary Object Pointers）</p></li><li><p>+XX:CompactFields</p><p>子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间，默认为true即启用。</p></li></ul></blockquote><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求<strong>对象起始地址必须是8字节的整数倍</strong>，换句话说就是对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p><h1 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h1><p>对象的访问定位主要有句柄和直接指针两种。</p><h2 id="句柄"><a href="#句柄" class="headerlink" title="句柄"></a>句柄</h2><blockquote><p>使用句柄访问的最好好处就是reference中存储的是稳定句柄地址，在对象移动时只会改变句柄中的实例数据指针，而reference本身不需要被修改。</p></blockquote><p>如果使用句柄访问的话，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p><img src="/posts/703fe08b/15.jpg" class><h2 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h2><p>速度快，节省了一次指针定位的时间开销。HotSpot采用此方式</p><img src="/posts/703fe08b/16.jpg" class><h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="直接引用和符号引用"><a href="#直接引用和符号引用" class="headerlink" title="直接引用和符号引用"></a>直接引用和符号引用</h2><p>1.符号引用（Symbolic References）：</p><p>　　符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在<a href="http://lib.csdn.net/base/javaee">Java</a>中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p><p>2.直接引用：</p><p> 直接引用可以是</p><p>（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）</p><p>（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）</p><p>（3）一个能间接定位到目标的句柄</p><p>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><img src="/posts/703fe08b/204.jpg" class><p>其中，加载、验证、准备、初始化、卸载的<strong>开始顺序</strong>是确定的，注意，只是按顺序开始，进行与结束的顺序并不一定。解析阶段可能在初始化之后开始。</p><p>一、类的加载</p><p>我们平常说的加载大多不是指的类加载机制，只是类加载机制中的第一步加载。在这个阶段，JVM主要完成三件事：</p><p>1、通过一个类的全限定名（包名与类名）来获取定义此类的二进制字节流（Class文件）。而获取的方式，可以通过jar包、war包、网络中获取、JSP文件生成等方式。</p><p>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。这里只是转化了数据结构，并未合并数据。（方法区就是用来存放已被加载的类信息，常量，静态变量，编译后的代码的运行时内存区域）</p><p>3、在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。这个Class对象并没有规定是在Java堆内存中，它比较特殊，虽为对象，但存放在方法区中。</p><p>二、类的连接</p><p>类的加载过程后生成了类的 java.lang.Class 对象，接着会进入连接阶段，连接阶段负责将类的二进制数据合并入JRE（Java运行时环境）中。类的连接大致分三个阶段。</p><p><em><strong>1、验证：</strong></em>验证被加载后的类是否有正确的结构，类数据是否会符合虚拟机的要求，确保不会危害虚拟机安全。</p><p><em><strong>2、准备：</strong></em>为类的静态变量（static filed）在方法区分配内存，并赋默认初值（0值或null值）。如static int a &#x3D; 100;</p><p>静态变量a就会在准备阶段被赋默认值0。</p><p>对于一般的成员变量是在类实例化时候，随对象一起分配在堆内存中。</p><p>另外，静态常量（static final filed）会在准备阶段赋程序设定的初值，如static final int a &#x3D; 666;  静态常量a就会在准备阶段被直接赋值为666，对于静态变量，这个操作是在初始化阶段进行的。</p><p><em><strong>3、解析：</strong></em>将类的二进制数据中的符号引用换为直接引用。</p><p>三、类的初始化</p><p>类初始化是类加载的最后一步，除了加载阶段，用户可以通过自定义的类加载器参与，其他阶段都完全由虚拟机主导和控制。到了初始化阶段才真正执行Java代码。</p><p>****类的初始化的主要工作****是为静态变量赋程序设定的初值。</p><p>如static int a &#x3D; 100;在准备阶段，a被赋默认值0，在初始化阶段就会被赋值为100。</p><p>Java虚拟机规范中严格规定了****有且只有五种情况必须对类进行初始化****：</p><p>1、使用new字节码指令创建类的实例，或者使用getstatic、putstatic读取或设置一个静态字段的值（放入常量池中的常量除外），或者调用一个静态方法的时候，对应类必须进行过初始化。</p><p>2、通过java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则要首先进行初始化。</p><p>3、当初始化一个类的时候，如果发现其父类没有进行过初始化，则首先触发父类初始化。</p><p>4、当虚拟机启动时，用户需要指定一个主类（包含main()方法的类），虚拟机会首先初始化这个类。</p><p>5、使用jdk1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、RE_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先触发其初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h1&gt;&lt;img src=&quot;/posts/703fe08b/11.jpg&quot; class&gt;

&lt;h2 id=&quot;程序计</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="JVM" scheme="https://blog.yahyav2rayssr.top/categories/Java/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.yahyav2rayssr.top/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾收集器与内存分配策略</title>
    <link href="https://blog.yahyav2rayssr.top/posts/5b44aded/"/>
    <id>https://blog.yahyav2rayssr.top/posts/5b44aded/</id>
    <published>2023-04-16T12:10:59.882Z</published>
    <updated>2023-04-16T12:10:59.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><h2 id="对象回收处理过程"><a href="#对象回收处理过程" class="headerlink" title="对象回收处理过程"></a>对象回收处理过程</h2><img src="/posts/5b44aded/22.jpg" class><h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><p>判断一个对象是否存活需要同时满足以下三个条件：</p><ol><li>该类所有的实例都已经被回收</li><li>加载该类的类加载器已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用</li></ol><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a><del>引用计数算法</del></h3><p>引用计数法的逻辑是：在堆中存储对象时，在对象头处维护一个counter计数器，如果一个对象增加了一个引用与之相连，则将counter++。如果一个引用关系失效则counter–。如果一个对象的counter变为0，则说明该对象已经被废弃，不处于存活状态。</p><img src="/posts/5b44aded/20.jpg" class><p>这种方法来标记对象的状态会存在很多问题：</p><blockquote><p>1 jdk从1.2开始增加了多种引用方式：软引用、弱引用、虚引用，且在不同引用情况下程序应进行不同的操作。如果我们只采用一个引用计数法来计数无法准确的区分这么多种引用的情况。</p></blockquote><p>引用计数法无法解决多种类型引用的问题。但这并不是致命的，因为我们可以通过增加逻辑区分四种引用情况，虽然麻烦一些但还算是引用计数法的变体，真正让引用计数法彻底报废的下面的情况；如果一个对象A持有对象B，而对象B也持有一个对象A，那发生了类似操作系统中死锁的循环持有，这种情况下A与B的counter恒大于1，会使得GC永远无法回收这两个对象。</p><img src="/posts/5b44aded/21.jpg" class><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>在主流的商用程序语言中(Java和C#)，都是使用可达性分析算法判断对象是否存活的。这个算法的基本思路就是通过一系列名为<strong>GC Roots</strong>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，下图对象object5, object6, object7虽然有互相判断，但它们到GC Roots是不可达的，所以它们将会判定为是可回收对象。</p><img src="/posts/5b44aded/17.jpg" class><p>如下情况的对象可以作为GC Roots：</p><ul><li><p>虚拟机栈(栈桢中的本地变量表)中的引用的对象</p></li><li><p>方法区中的类静态属性引用的对象</p></li><li><p>方法区中的常量引用的对象</p></li><li><p>本地方法栈中JNI（Native方法）的引用的对象</p></li><li><p>所有被同步锁持有的对象</p></li><li><p>反应Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</p></li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><h3 id="强引用-StrongReference"><a href="#强引用-StrongReference" class="headerlink" title="强引用(StrongReference)"></a>强引用(StrongReference)</h3><p><strong>强引用</strong>是使用最普遍的引用。如果一个对象具有强引用，那<strong>垃圾回收器</strong>绝不会回收它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">strongReference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br></code></pre></td></tr></table></figure><h3 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h3><p>如果一个对象只具有<strong>软引用</strong>，则<strong>内存空间充足</strong>时，<strong>垃圾回收器</strong>就<strong>不会</strong>回收它；如果<strong>内存空间不足</strong>了，就会<strong>回收</strong>这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。</p><blockquote><p>软引用可用来实现内存敏感的高速缓存。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 强引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">strongReference</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-comment">// 软引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>SoftReference&lt;String&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;String&gt;(str);<br></code></pre></td></tr></table></figure><h3 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h3><p><strong>弱引用</strong>与<strong>软引用</strong>的区别在于：只具有<strong>弱引用</strong>的对象拥有<strong>更短暂</strong>的<strong>生命周期</strong>。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有<strong>弱引用</strong>的对象，不管当前<strong>内存空间足够与否</strong>，都会<strong>回收</strong>它的内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>   WeakReference&lt;String&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(str);<br>   str = <span class="hljs-literal">null</span>;<br>   <br><span class="hljs-comment">// 复制代码JVM首先将软引用中的对象引用置为null，然后通知垃圾回收器进行回收：</span><br>   str = <span class="hljs-literal">null</span>;<br>   System.gc();<br></code></pre></td></tr></table></figure><p><strong>弱引用</strong>再次变为一个<strong>强引用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>WeakReference&lt;String&gt; weakReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(str);<br><span class="hljs-comment">// 弱引用转强引用</span><br><span class="hljs-type">String</span> <span class="hljs-variable">strongReference</span> <span class="hljs-operator">=</span> weakReference.get();<br></code></pre></td></tr></table></figure><h3 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用(PhantomReference)"></a>虚引用(PhantomReference)</h3><p><strong>虚引用</strong>顾名思义，就是<strong>形同虚设</strong>。与其他几种引用都不同，<strong>虚引用</strong>并<strong>不会</strong>决定对象的<strong>生命周期</strong>。如果一个对象<strong>仅持有虚引用</strong>，那么它就和<strong>没有任何引用</strong>一样，在任何时候都可能被垃圾回收器回收。</p><p><strong>应用场景：</strong></p><p><strong>虚引用</strong>主要用来<strong>跟踪对象</strong>被垃圾回收器<strong>回收</strong>的活动。 <strong>虚引用</strong>与<strong>软引用</strong>和<strong>弱引用</strong>的一个区别在于：</p><blockquote><p>虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;abc&quot;</span>);<br><span class="hljs-type">ReferenceQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>();<br><span class="hljs-comment">// 创建虚引用，要求必须与一个引用队列关联</span><br><span class="hljs-type">PhantomReference</span> <span class="hljs-variable">pr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>(str, queue);<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><table><thead><tr><th>引用类型</th><th>被垃圾回收时间</th><th>用途</th><th>生存时间</th></tr></thead><tbody><tr><td>强引用</td><td>从来不会</td><td>对象的一般状态</td><td>JVM停止运行时终止</td></tr><tr><td>软引用</td><td>当内存不足时</td><td>对象缓存</td><td>内存不足时终止</td></tr><tr><td>弱引用</td><td>正常垃圾回收时</td><td>对象缓存</td><td>垃圾回收后终止</td></tr><tr><td>虚引用</td><td>正常垃圾回收时</td><td>跟踪对象的垃圾回收</td><td>垃圾回收后终止</td></tr></tbody></table><blockquote><p>任何一个对象的finallize()方法都只会被系统调用一次。</p></blockquote><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>垃圾收集算法可以划分为“引用计数式垃圾收集”和“追踪式垃圾收集”两大类。</p><img src="/posts/5b44aded/23.jpg" class><h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><ul><li><p>弱分代假说：绝大多数对象都是朝生夕灭的。</p></li><li><p>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡。</p></li><li><p>跨代引用假说：举个例子，如果某个新生代对象存在跨代引用，由于年老代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到年老代中，这时跨代引用也随即被消除了。</p><p>根据此引申出一个在新生代的数据结构，俗称<strong>记忆集</strong>：这个结构把年老代划分成若干小块，当发生新生代收集时，引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p></li></ul><blockquote><p>GC概念：</p><ul><li><p>部分收集（Partial PC）</p><ul><li><p>新生代收集（Minor GC &#x2F; Young GC）</p></li><li><p>老年代收集（Major GC &#x2F; Old GC）：目前只有CMS收集器会有单独收集老年代的行为。</p></li></ul></li><li><p>整堆收集（Full GC）</p></li></ul></blockquote><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a><strong>标记清除算法</strong></h3><p>该算法用于<strong>新生代</strong>的处理，标记-清除算法分为标记和清除两个阶段。该算法首先从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象并进行回收（也可以反过来标记存活的对象）</p><img src="/posts/5b44aded/18.jpg" class><ul><li><strong>效率问题：</strong>标记和清除两个过程的效率都不高;</li><li><strong>空间碎片化问题：</strong>标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，因此标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><img src="/posts/5b44aded/19.jpg" class><h3 id="半复制算法"><a href="#半复制算法" class="headerlink" title="半复制算法"></a><strong>半复制算法</strong></h3><p><strong>复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</strong>这种算法适用于对象存活率低的场景，比如新生代。</p><img src="/posts/5b44aded/24.jpg" class><h4 id="Appel式回收原理"><a href="#Appel式回收原理" class="headerlink" title="Appel式回收原理"></a>Appel式回收原理</h4><p>Appel式回收是针对标准ML提出的一种自适应分代策略，在ML语言中，一次回收完成通常只有不到2%的对象能够存活，Appel式回收正式针对这一种情况而设计的策略。<strong>Appel式回收策略将空间分为三个：老年代、复制保留区、新生代，在HotSpot虚拟机中的实现中新生代收集器将新生代变成Eden空间，将复制保留区变成两块较小的Survivor空间，在程序运行中每次分配内存只使用Eden和其中一块Survivor空间，在发生垃圾收集时，将存活的对象复制到保留的那一块Survivor上，另外两块空间直接清零</strong>（在HotSpot虚拟机中Eden和Survivor的比例为8:1）。</p><p>可通过JVM参数：<code>-XX:SurvivorRatio</code>配置比例，<code>-XX:SurvivorRatio=8</code> 表示 <code>Eden区大小 / 1块Survivor区大小 = 8</code>。</p><p><strong>第一次Young GC</strong></p><img src="/posts/5b44aded/25.jpg" class><p>当Eden区满的时候，触发第一次Young GC，把存活对象拷贝到Survivor的from区，清空Eden区。</p><p>当Survivor空间不足以容纳一次Minor GC之后，就需要依赖其他内存区域（大部分时候是老年代）进行分配担保，这些没有足够空间存放的对象直接进入其他区域；再次触发Young GC，扫描Eden区和from区，把存活的对象复制到To区，清空Eden区和from区。如果此时Survivor区的空间不够了，就会提前把对象放入老年代。</p><p><strong>第二次Young GC</strong></p><img src="/posts/5b44aded/26.jpg" class><p>再次触发Young GC，扫描Eden区和from区，把存活的对象复制到To区，清空Eden区和from区。如果此时Survivor区的空间不够了，就会提前把对象放入老年代。</p><blockquote><p>交换次数可以通过JVM参数<code>MaxTenuringThreshold</code>进行设置。</p></blockquote><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>标记整理算法的标记过程类似标记清除算法，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存，类似于磁盘整理的过程，该垃圾回收算法适用于对象存活率高的场景（<strong>老年代</strong>）。</p><img src="/posts/5b44aded/27.jpg" class><blockquote><p>Hotspot虚拟机里面关注吞吐量的Parallel Scavenge收集是基于标记-整理算法的；</p><p>而关注延迟的CMS收集器则是基于标记-清除算法的，辅助以标记-整理算法，两种算法同时使用。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾收集器与内存分配策略&quot;&gt;&lt;a href=&quot;#垃圾收集器与内存分配策略&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器与内存分配策略&quot;&gt;&lt;/a&gt;垃圾收集器与内存分配策略&lt;/h1&gt;&lt;h2 id=&quot;对象回收处理过程&quot;&gt;&lt;a href=&quot;#对象回收处</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="JVM" scheme="https://blog.yahyav2rayssr.top/categories/Java/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.yahyav2rayssr.top/tags/JVM/"/>
    
    <category term="垃圾收集器" scheme="https://blog.yahyav2rayssr.top/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM 垃圾收集器</title>
    <link href="https://blog.yahyav2rayssr.top/posts/9e0bfe2e/"/>
    <id>https://blog.yahyav2rayssr.top/posts/9e0bfe2e/</id>
    <published>2023-04-16T12:10:38.171Z</published>
    <updated>2023-04-16T12:10:38.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a><strong>并发和并行</strong></h3><ul><li><strong>并行（Parallel）：</strong>指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）：</strong>指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</li></ul><h3 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a><strong>Minor GC 和 Full GC</strong></h3><ul><li><strong>新生代GC（Minor GC）：</strong>指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li><strong>老年代GC（Major GC &#x2F; Full GC）：</strong>指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li></ul><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a><strong>吞吐量</strong></h3><p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F;（运行用户代码时间 + 垃圾收集时间）。虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><ul><li><p><code>CMSScavengeBeforeRemark</code></p><p>在CMS GC前启动一次ygc，目的在于减少old gen对ygc gen的引用，降低remark时的开销—–一般CMS的GC耗时 80%都在remark阶段</p></li></ul><table><thead><tr><th><strong>参数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>UseSerialGC</td><td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收</td></tr><tr><td>UseParNewGC</td><td>打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收</td></tr><tr><td>UseConcMarkSweepGC</td><td>打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用</td></tr><tr><td>UseParallelGC</td><td>虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge + Serial Old（PS MarkSweep）的收集器组合进行内存回收</td></tr><tr><td>UseParallelOldGC</td><td>打开此开关后，使用Parallel Scavenge + Parallel Old的收集器组合进行内存回收</td></tr><tr><td>SurvivorRatio</td><td>新生代中Eden区域与Survivor区域的容量比值，默认值为8，代表Eden：Survivor&#x3D;8：1</td></tr><tr><td>PretenureSizeThreshold</td><td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td></tr><tr><td>MaxTenuringThreshold</td><td>晋升到老年代的对象年龄，每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数时就进入老年代</td></tr><tr><td>UseAdaptiveSizePolicy</td><td>动态调整Java堆中各个区域的大小以及进入老年代的年龄</td></tr><tr><td>HandlePromotionFailure</td><td>是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td></tr><tr><td>ParallelGCThreads</td><td>设置并行GC时进行内存回收的线程数。默认情况下，当 CPU 数量小于8， ParallelGCThreads 的值等于 CPU 数量，当 CPU 数量大于 8 时，则使用公式：3+((5*CPU)&#x2F;8)；同时这个参数只要是并行 GC 都可以使用，不只是 ParNew。</td></tr><tr><td>GCTimeRatio</td><td>GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td>MaxGCPauseMillis</td><td>设置GC的最大停顿时间，仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td>CMSInitingOccupancyFraction</td><td>设置CMS收集器在老年代空间被使用多少后触发垃圾收集。默认值为68%，仅在使用CMS收集器时生效</td></tr><tr><td>UseCMSCompactAtFullCollection</td><td>设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理，仅在使用CMS收集器时生效</td></tr><tr><td>CMSFullGCsBeforeCompaction</td><td>设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</td></tr></tbody></table><h2 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h2><p><strong>记忆集是一种用户记录从非收集区域指向收集区域的指针集合的抽象数据结构。</strong>它其中的每个元素分别对应内存中的一块连续区域是否有跨代引用对象，如果有，该区域会被标记为“脏的”（dirty），否则就是“干净的”（clean）。这样在GC时，只需要扫描记忆集合就可以简单地确定跨代引用的位置，是个典型的空间换时间的思路。</p><h3 id="记忆粒度"><a href="#记忆粒度" class="headerlink" title="记忆粒度"></a>记忆粒度</h3><ul><li><strong>字长精度：</strong>每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个 精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li><li><strong>对象精度：</strong>每个记录精确到一个对象，该对象里有字段含有跨代指针。</li><li><strong>卡精度：</strong>每个记录精确到一块内存区域，该区域内有对象含有跨代指针。</li></ul><h3 id="卡表与卡页"><a href="#卡表与卡页" class="headerlink" title="卡表与卡页"></a>卡表与卡页</h3><p><strong>卡表是记忆集的一种具体实现</strong>，它定义记忆集的记录精度、与堆内存的映射关系等。在垃圾收集发生时，只要筛选出卡表的数组元素的值为1，称为这个元素变脏，没有则标识为0，借此得出哪些卡页内存块中包含<strong>跨代指针</strong>。如图所示：</p><img src="/posts/9e0bfe2e/28.jpg" class><h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>在JDK 7之前，卡表的写屏障是无条件的。也就是说，不管更新的引用是否为跨代引用，都会出现一次写屏障。虽然这个造成的overhead相当的小，但在大并发情况下，又会造成虚共享（false sharing）问题。</p><h3 id="虚共享"><a href="#虚共享" class="headerlink" title="虚共享"></a>虚共享</h3><p>CPU的缓存体系是以缓存行（cache line）为单位的，一条缓存行包含2的整数次幂个连续字节，一般为64B大。以64B为前提的话，那么一条缓存行就可以放下64个卡表元素，而64个卡页可以映射到32KB（64*512字节）的堆空间。如果同时有多个线程对同一块32KB堆空间内的引用进行更新，就会在同一个缓存行内发生碰撞，造成缓存频繁写回或者失效，影响性能。</p><p>下图示出虚共享的例子。核心1上的线程更新X的引用，而核心2上的线程更新Y的引用，它们落到了同一个缓存行内。</p><img src="/posts/9e0bfe2e/29.jpg" class><p>为了避免这种开销，在JDK 7及以后，引入了参数<code>-XX:+UseCondCardMark</code>来开启卡标记时有条件的写屏障，也就是先检查卡表中对应的位是不是脏的，如果不是脏的，再进行标记。这个思路非常简单，但有效地避免了虚共享问题。</p><h2 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h2><p><strong>指针的自愈能力</strong></p><ul><li>在ZGC中，当读取处于重分配集的对象时，会被读屏障拦截，通过转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象。ZGC将这种行为叫做指针的“自愈能力”。</li><li>好处是：第一次访问旧对象访问会变慢，但也只会有一次变慢，当“自愈”完成后，后续访问就不会变慢了。<ul><li>Shenandoah每次访问都慢，对比发现，ZGC的执行负载更低。</li></ul></li></ul><h2 id="虚拟机的标记实现方案"><a href="#虚拟机的标记实现方案" class="headerlink" title="虚拟机的标记实现方案"></a>虚拟机的标记实现方案</h2><ul><li>把标记直接记录在对象头上（如Serial收集器）；</li><li>把标记记录在与对象相互独立的数据结构上（如G1、Shenandoah使用了一种相当于堆内存的1&#x2F;64大小的，称为BitMap的结构来记录标记信息）；</li><li>直接把标记信息记在引用对象的指针上（如ZGC）</li></ul><h2 id="垃圾收集器-1"><a href="#垃圾收集器-1" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><img src="/posts/9e0bfe2e/30.jpg" style="zoom:67%;"><p>可以看到垃圾收集器是按对象的分代来划分的，可以用双箭头连接的垃圾收集器表示两者可以配合使用。可以看到新生代垃圾收集器有Serial、ParNew、Parallel Scavenge，G1，属于老年代的垃圾收集器有CMS、Serial Old、Parallel Old和G1.其中的G1是一种既可以对新生代对象也可以对老年代对象进行回收的垃圾收集器。然而，在所有的垃圾收集器中，并没有一种普遍使用的垃圾收集器。在不同的场景下，每种垃圾收集器有各自的优势。</p><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a><strong>Serial收集器</strong></h3><p>Serial收集器是最基本、发展历史最悠久的收集器。它是一种单线程垃圾收集器，这就意味着在其进行垃圾收集的时候需要暂停其他的线程，也就是之前提到的”Stop the world“。虽然这个过程是在用户不可见的情况下把用户正常的线程全部停掉，听起来有点狠，这点是很难让人接受的。Serial、Serial Old收集器的工作示意图如下：</p><img src="/posts/9e0bfe2e/31.jpg" style="zoom:80%;"><p>尽管由以上不能让人接受的地方，但是Serial收集器还是有其优点的：简单而高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得较高的手机效率。到目前为止，<strong>Serial收集器依然是Client模式下的默认的新生代垃圾收集器。</strong></p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a><strong>ParNew收集器</strong></h3><p>可ParNew收集器是Serial收集器的多线程版本，ParNew收集器的工作示意图如下：</p><img src="/posts/9e0bfe2e/32.jpg" style="zoom:80%;"><p>ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器。除去性能因素，很重要的原因是除了Serial收集器外，目前只有它能与CMS收集器配合工作。</p><p>但是，在单CPU环境中，ParNew收集器绝对不会有比Serial收集器更好的效果，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。然而，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。</p><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a><strong>Parallel Scavenge收集器</strong></h3><p>Parallel Scavenge收集器是新生代垃圾收集器，使用复制算法，也是并行的多线程收集器。与ParNew收集器相比，很多相似之处，但是Parallel Scavenge收集器更关注可控制的<strong>吞吐量</strong>。吞吐量越大，垃圾收集的时间越短，则用户代码则可以充分利用CPU资源，尽快完成程序的运算任务。</p><p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p><ul><li><code>XX:MaxGCPauseMillis</code> 控制最大的垃圾收集停顿时间</li><li><code>XX:GCRatio</code> 直接设置吞吐量的大小。</li></ul><p>直观上，只要最大的垃圾收集停顿时间越小，吞吐量是越高的，但是GC停顿时间的缩短是以牺牲吞吐量和新生代空间作为代价的。比如原来10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，每次停顿70毫秒。停顿时间下降的同时，吞吐量也下降了。</p><p>除此之外，Parallel Scavenge收集器还可以设置参数-XX:+UseAdaptiveSizePocily来动态调整停顿时间或者最大的吞吐量，这种方式称为GC自适应调节策略，这点是ParNew收集器所没有的。</p><h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a><strong>Serial Old收集器</strong></h3><p>Serial Old收集器是Serial收集器的老年代版本，也是一个单线程收集器，采用“标记-整理算法”进行回收。其运行过程与Serial收集器一样。</p><p>Serial Old收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p><img src="/posts/9e0bfe2e/31-1594828571397.jpg" style="zoom:80%;"><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a><strong>Parallel Old收集器</strong></h3><p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法进行垃圾回收。其通常与Parallel Scavenge收集器配合使用，“<strong>吞吐量优先</strong>”收集器是这个组合的特点，在注重吞吐量和CPU资源敏感的场合，都可以使用这个组合。</p><img src="/posts/9e0bfe2e/33.jpg" style="zoom:80%;"><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a><strong>CMS收集器</strong></h3><p>CMS收集器（Concurrent Mark Sweep）的目标就是获取最短回收停顿时间，是基于标记-清除算法实现的。在注重服务器的响应速度，希望停顿时间最短，则CMS收集器是比较好的选择。</p><p>整个执行过程分为以下4个步骤：</p><p>初始标记<br>并发标记<br>重新标记<br>并发清除<br>初始标记和重新标记这两个步骤仍然需要暂停Java执行线程，初始标记只是标记GC Roots能够关联到的对象，并发标记就是执行GC Roots Tracing的过程，而重新标记就是为了修正并发标记期间因用户程序执行而导致标记发生变动使得标记错误的记录。其执行过程如下：</p><img src="/posts/9e0bfe2e/34.jpg" style="zoom:80%;"><p>由上图可知，整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，因此，总体上CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>CMS的优点很明显：并发收集、低停顿。由于进行垃圾收集的时间主要耗在并发标记与并发清除这两个过程，虽然初始标记和重新标记仍然需要暂停用户线程，但是从总体上看，这部分占用的时间相比其他两个步骤很小，所以可以认为是低停顿的。</p><p>尽管如此，CMS收集器的缺点也是很明显的：</p><p>对CPU资源太敏感，这点可以这么理解，虽然在并发标记阶段用户线程没有暂停，但是由于收集器占用了一部分CPU资源，导致程序的响应速度变慢</p><p>CMS收集器无法处理浮动垃圾。所谓的“浮动垃圾”，就是在并发标记阶段，由于用户程序在运行，那么自然就会有新的垃圾产生，这部分垃圾被标记过后，CMS无法在当次集中处理它们（为什么？原因在于CMS是以获取最短停顿时间为目标的，自然不可能在一次垃圾处理过程中花费太多时间），只好在下一次GC的时候处理。这部分未处理的垃圾就称为“浮动垃圾”</p><p>由于CMS收集器是基于“标记-清除”算法的，前面说过这个算法会导致大量的空间碎片的产生，一旦空间碎片过多，大对象就没办法给其分配内存,那么即使内存还有剩余空间容纳这个大对象，但是却没有连续的足够大的空间放下这个对象，所以虚拟机就会触发一次Full GC（这个后面还会提到）这个问题的解决是通过控制参数-XX:+UseCMSCompactAtFullCollection，用于在CMS垃圾收集器顶不住要进行FullGC的时候开启空间碎片的合并整理过程。</p><p><strong>CMS GC要决定是否在full GC时做压缩</strong>依赖以下情况：</p><ol><li><del>UseCMSCompactAtFullCollection</del> 与 CMSFullGCsBeforeCompaction 是搭配使用的；前者目前默认就是true了，也就是关键在后者上。</li><li>用户调用了System.gc()，而且DisableExplicitGC没有开启。</li><li>young gen报告接下来如果做增量收集会失败；简单来说也就是young gen预计old gen没有足够空间来容纳下次young GC晋升的对象。</li></ol><h4 id="增量式并发收集器"><a href="#增量式并发收集器" class="headerlink" title="增量式并发收集器"></a><del>增量式并发收集器</del></h4><p>增量式并发收集器是为了缓解CMS收集器CPU资源占用过多而设计出来的CMS收集变种，所做的事情和以前单核处理器年代PC机操作系统靠抢占式多任务来模拟多核并行多任务的思想一样，是在并发标记清理的时候让收集器线程和用户线程交替运行，尽量减少垃圾收集线程的独占资源的时间；由于性能一半已被废弃。</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a><strong>G1收集器</strong></h3><p>G1（Garbage-First）收集器是现今收集器技术的最新成果之一，之前一直处于实验阶段。</p><p>衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数据最多，回收收益最大，这就是G1收集器的Mixed GC模式。</p><p>与前几个收集器相比，G1收集器有以下特点：</p><ul><li>并行与并发</li><li>分代收集（仍然保留了分代的概念）</li><li>空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）</li><li>可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）</li></ul><p>此外，G1收集器将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region（化整为零）。</p><p>G1的工作过程如下：</p><ul><li><p>初始标记（Initial Marking）</p></li><li><p>并发标记（Concurrent Marking）</p></li><li><p>最终标记（Final Marking）</p></li><li><p>筛选回收（Live Data Counting and Evacuation）</p></li></ul><p>初始标记阶段仅仅只是标记一下GC Roots能够直接关联的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段的用户程序并发运行的时候，能在正确可用的Region中创建对象，这个阶段需要暂停线程。</p><p>并发标记阶段从GC Roots进行可达性分析，找出存活的对象，这个阶段食欲用户线程并发执行的。</p><p>最终标记阶段则是修正在并发标记阶段因为用户程序的并发执行而导致标记产生变动的那一部分记录，这部分记录被保存在Remembered Set Logs中，最终标记阶段再把Logs中的记录合并到Remembered Set中，这个阶段是并行执行的，仍然需要暂停用户线程。</p><p>最后在筛选阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划，这个阶段需要暂停线程。整个执行过程如下：</p><img src="/posts/9e0bfe2e/35.jpg" style="zoom:80%;"><h2 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h2><blockquote><p>Shenandoah和ZGC为什么被称为低延迟GC，因为它几乎整个工作过程全部都是并发的，只有初始标记、最终标记这些阶段有短暂的停顿，这部分停顿的时间基本上是固定的，与堆的容量、堆中对象的数量没有正比例关系。实际上，它们都可以在任意可管理的（譬如现在ZGC只能管理4TB以内的堆）堆容量下，实现垃圾收集的停顿都不超过十毫秒这种以前听起来是天方夜谭、匪夷所思的目标。这两款目前仍处于实验状态的收集器，被官方命名为“低延迟垃圾收集器”。</p></blockquote><p>衡量垃圾收集器的三项最重要的指标是：内存占用（Footprint）、吞吐量（Throughput）和延迟（Latency），三者共同构成了一个“不可能三角”。</p><h3 id="Shenandoah垃圾回收器"><a href="#Shenandoah垃圾回收器" class="headerlink" title="Shenandoah垃圾回收器"></a>Shenandoah垃圾回收器</h3><p>Shenandoah收集器是通过比较并交换（Compare ANd Swap，CAS）操作来保证并发时对象的访问正确性的。</p><p>Shenandoah的内存屏障模型是基于引用访问屏障的实现，只拦截对象中数据类型为引用类型的读写操作。</p><blockquote><p>比起稍后要介绍的有着Oracle正朔血统的ZGC，Shenandoah反而更像是G1的下一代继承者。使用转发指针（Forwarding Pointer，也常被称为Indirection Pointer）来实现对象移动与用户程序并发的一种解决方案。</p></blockquote><h4 id="Shenandoah相比起G1的改进"><a href="#Shenandoah相比起G1的改进" class="headerlink" title="Shenandoah相比起G1的改进"></a>Shenandoah相比起G1的改进</h4><p>虽然Shenandoah也是使用基于Region的堆内存布局，同样有着用于存放大对象的HumongousRegion，默认的回收策略也同样是优先处理回收价值最大的Region……但在管理堆内存方面，它与G1至少有三个明显的不同之处，最重要的当然是支持并发的整理算法，G1的回收阶段是可以多线程并行的，但却不能与用户线程并发，这点作为Shenandoah最核心的功能稍后笔者会着重讲解。其次，Shenandoah（目前）是默认不使用分代收集的，换言之，不会有专门的新生代Region或者老年代Region的存在，没有实现分代，并不是说分代对Shenandoah没有价值，这更多是出于性价比的权衡，基于工作量上的考虑而将其放到优先级较低的位置上。最后，Shenandoah摒弃了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”（Connection Matrix）的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题。</p><h4 id="九个阶段"><a href="#九个阶段" class="headerlink" title="九个阶段"></a>九个阶段</h4><ol><li>初始标记 这个阶段仍是“Stop The World”的，但停顿时间与堆大小无关，只与GC Roots的数量相关</li><li>并发标记 与G1一样，遍历对象图，标记出全部可达的对象，这个阶段是与用户线程一起并发的，时间长短取决于堆中存活对象的数量以及对象图的结构复杂程度。</li><li>最终标记 与G1一样，处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集（Collection Set）。最终标记阶段也会有一小段短暂的停顿。</li><li>并发清理 这个阶段用于清理那些整个区域内连一个存活对象都没有找到的Region</li><li>并发回收 在这个阶段，Shenandoah要把回收集里面的存活对象先复制一份到其他未被使用的Region之中。复制对象这件事情如果将用户线程冻结起来再做那是相当简单的，但如果两者必须要同时并发进行的话，就变得复杂起来了。其困难点是在移动对象的同时，用户线程仍然可能不停对被移动的对象进行读写访问，移动对象是一次性的行为，但移动之后整个内存中所有指向该对象的引用都还是旧对象的地址，这是很难一瞬间全部改变过来的。对于并发回收阶段遇到的这些困难，Shenandoah将会通过读屏障和被称为“Brooks Pointers”的转发指针来解决。并发回收阶段运行的时间长短取决于回收集的大小</li><li>初始引用更新 并发回收阶段复制对象结束后，还需要把堆中所有指向旧对象的引用修正到复制后的新地址，这个操作称为引用更新。</li><li>并发引用更新 真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少。并发引用更新与并发标记不同，它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。</li><li>最终引用更新 解决了堆中的引用更新后，还要修正存在于GC Roots中的引用。这个阶段是Shenandoah的最后一次停顿，停顿时间只与GC Roots的数量相关。</li><li>并发清理 经过并发回收和引用更新之后，整个回收集中所有的Region已再无存活对象，最后再调用一次并发清理过程来回收这些Region的内存空间，供以后新对象分配使用。</li></ol><h3 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h3><blockquote><p>ZGC是一款在JDK 11中新加入的具有实验性质[插图]的低延迟垃圾收集器，是由Oracle公司研发的。2018年Oracle创建了JEP 333将ZGC提交给OpenJDK，推动其进入OpenJDK 11的发布清单之中。</p></blockquote><p>ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。但是ZGC和Shenandoah的实现思路又是差异显著的。</p><p>ZGC收集器是一款基于Region内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。</p><p><strong>ZGB可分为三种容量：</strong></p><ul><li>小型Region（Small Region）：容量固定为2MB，用于放置小于256KB的小对象。</li><li>中型Region（Medium Region）：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象。</li><li>大型Region（Large Region）：容量不固定，可以动态变化，但必须为2MB的整数倍，用于放置4MB或以上的大对象。每个大型Region中只会存放一个大对象，所以实际容量可能小于中型Region，最小容量可低至4MB。大型Region在ZGC的实现中是不会被重分配的，因为复制一个大对象的代价非常高昂。</li></ul><h4 id="并发整理算法的实现"><a href="#并发整理算法的实现" class="headerlink" title="并发整理算法的实现"></a>并发整理算法的实现</h4><blockquote><p>Shenandoah使用转发指针和读屏障来实现并发整理，ZGC虽然同样用到了读屏障，但用的却是一条与Shenandoah完全不同，更加复杂精巧的解题思路。</p></blockquote><p>ZGC收集器有一个标志性的设计是它采用的染色指针技术（Colored Pointer），直接把标记信息记在引用对象的指针上。指针对于计算机来讲，它也是一个信息的载体，但是目前而言，内存中的理论可访问信息是远大于实际需求的，尽管Linux高18位不能用来寻址，但剩余的46位也足以满足需求，所以ZGC团队就将指针信息载体进行染色，将其高4位用来存储四个记号信息，通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到。</p><p>由于这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过4TB（2的42次幂）。</p><img src="/posts/9e0bfe2e/36.jpg" class><h4 id="染色指针的三大优势："><a href="#染色指针的三大优势：" class="headerlink" title="染色指针的三大优势："></a>染色指针的三大优势：</h4><ol><li>染色指针可以使得一旦某个Region的存活对象被移走之后，这个Region立即就能够被释放和重用掉，而不必等待整个堆中所有指向该Region的引用都被修正后才能清理。</li><li>染色指针可以大幅减少在垃圾收集过程中内存屏障的使用数量，设置内存屏障，尤其是写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作。</li><li>染色指针可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据，以便日后进一步提高性能。</li></ol><h4 id="四个阶段"><a href="#四个阶段" class="headerlink" title="四个阶段"></a>四个阶段</h4><ol><li>并发标记（Concurrent Mark）：并发标记是遍历对象图做可达性分析的阶段，与G1、Shenandoah不同的是，ZGC的标记是在指针上而不是在对象上进行的，标记阶段会更新染色指针中的Marked 0、Marked 1标志位。</li><li>并发预备重分配（Concurrent Prepare for Relocate）：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些Region，ZGC划分Region的目的并非为了像G1那样做收益优先的增量回收，而实用范围更大的扫描成本换取省去G1中记忆集的维护成本。此外，在JDK12的ZGC中开始支持的类卸载以及弱引用的处理，也是在这个阶段中完成的。</li><li>并发重分配（Concurrent Relocate）：重分配是ZGC执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的Region上，并为重分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。得益于染色指针的支持，ZGC收集器能仅从引用上就明确得知一个对象是否处于重分配集之中，<strong>如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据Region上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，ZGC将这种行为称为指针的“自愈”（Self-Healing）能力</strong>。</li><li>并发重映射（Concurrent Remap）：重映射所做的就是修正整个堆中指向重分配集中旧对象的所有引用。ZGC的并发重映射并不是一个必须要“迫切”去完成的任务，因为前面提到ZGC有”自愈”能力，最坏也就多跳转一层，这时候，一旦所有指针都被修正之后，原来记录新旧对象关系的转发表就可以释放掉了。</li></ol><h4 id="现代处理器一般使用请求分页机制-虚拟内存映射技术。"><a href="#现代处理器一般使用请求分页机制-虚拟内存映射技术。" class="headerlink" title="现代处理器一般使用请求分页机制+虚拟内存映射技术。"></a>现代处理器一般使用请求分页机制+虚拟内存映射技术。</h4><ul><li>请求分页机制把线性地址空间和物理地址空间分别划分为大小相等的块。这样的块称为页。通过在线性虚拟空间的页和物理地址空间的页建立映射表，分页机制会进行线性地址到物理地址的映射，完成线性地址到物理地址的转换。</li><li>Linus&#x2F;x86-64平台上的ZGC使用了多重映射将多个不同的虚拟内存地址映射到同一个物理内存地址上，多对一映射。意味着ZGC在虚拟内存空间中看到的地址空间比实际的堆内存容量更大。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="JVM" scheme="https://blog.yahyav2rayssr.top/categories/Java/JVM/"/>
    
    
    <category term="JVM" scheme="https://blog.yahyav2rayssr.top/tags/JVM/"/>
    
    <category term="垃圾收集器" scheme="https://blog.yahyav2rayssr.top/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 详解</title>
    <link href="https://blog.yahyav2rayssr.top/posts/8e078847/"/>
    <id>https://blog.yahyav2rayssr.top/posts/8e078847/</id>
    <published>2023-04-16T11:38:13.560Z</published>
    <updated>2023-04-16T11:38:13.560Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ详解"><a href="#RabbitMQ详解" class="headerlink" title="RabbitMQ详解"></a>RabbitMQ详解</h1><p><strong>RabbitMQ的优点：</strong></p><ul><li>开源, 性能有效, 稳定性好</li><li>提供可靠性消息投递模式(confirm), 返回模式(return)等</li><li>与Spring完美整合, API丰富</li><li>集群模式丰富, 支持表达式配置, 高可用HA模式, 镜像队列模型</li><li>可以保证数据不丢失的前提下做到高可靠性, 可用性</li></ul><p><strong>RabbitMQ高性能原因：</strong></p><ul><li>由Erlang语言开发，继承其天生的并发性，稳定性和安全性有保障</li></ul><p><strong>RabbitMQ的协议：</strong></p><p>AMQP（Advanced Message Queuing Protocol）高级消息队列协议，是一个异步消息传递所使用应用层协议规范，为面向消息中间件设计，基于此协议的客户端与消息中间件可以无视消息来源传递消息，不受客户端、消息中间件、不同的开发语言环境等条件的限制。</p><img src="/posts/8e078847/85.jpg" class><p>设计概念解释：</p><ul><li>Server : 又称Broker, 接受客户端连接, 实现AMQP实体服务</li><li>Connection : 连接, 应用程序与Broker的网络连接</li><li>Channel : 网络信道, 几乎所有的操作都在Channel中进行, Channel是进行消息读写的通道。客户端可以建立多个Channel, 每个Channel代表一个会话任务。</li><li>Message : 消息, 服务器和应用程序之间传送的数据, 有Properties和Body组成。Properties可以对消息进行修饰, 比如消息的优先级, 延迟等高级特性; Body就是消息体内容。</li><li>Virtual Host : 虚拟地址, 用于进行逻辑隔离, 最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue, 同一个Virtual Host里面不能有相同名称的Exchange或Queue</li><li>Exchange : 交换机, 用于接收消息, 根据路由键转发消息到绑定的队列</li><li>Binding : Exchange和Queue之间的虚拟连接, binding中可以包含routing key</li><li>Routing Key : 一个路由规则, 虚拟机可用它来确定如何路由一个特定消息</li><li>Queue : 也成Message Queue, 消息队列, 用于保存消息并将它们转发给消费者</li></ul><p><strong>RabbitMQ整体架构</strong></p><img src="/posts/8e078847/86.jpg" class><h1 id="RabbitMQ成员简介"><a href="#RabbitMQ成员简介" class="headerlink" title="RabbitMQ成员简介"></a>RabbitMQ成员简介</h1><h2 id="Binding-绑定"><a href="#Binding-绑定" class="headerlink" title="Binding-绑定"></a>Binding-绑定</h2><ul><li>Exchange和Exchange, Queue之间的连接关系</li><li>绑定中可以包含RoutingKey或者参数</li></ul><h2 id="Queue-消息队列"><a href="#Queue-消息队列" class="headerlink" title="Queue-消息队列"></a>Queue-消息队列</h2><ul><li>消息队列, 实际存储消息数据</li><li>Durability : 是否持久化</li><li>Auto delete : 如选yes,代表当最后一个监听被移除之后, 该Queue会自动被删除</li></ul><h2 id="Message-消息"><a href="#Message-消息" class="headerlink" title="Message-消息"></a>Message-消息</h2><ul><li>服务和应用程序之间传送的数据</li><li>本质上就是一段数据, 由Properties和Payload(Body)组成</li><li>常用属性 : delivery mode, headers(自定义属性)</li><li>其他属性<ul><li>content_type, content_encoding, priority</li><li>correlation_id : 可以认为是消息的唯一id</li><li>replay_to : 重回队列设定</li><li>expiration : 消息过期时间</li><li>message_id : 消息id</li><li>timestamp, type, user_id, app_id, cluster_id</li></ul></li></ul><h2 id="Virtual-Host-虚拟主机"><a href="#Virtual-Host-虚拟主机" class="headerlink" title="Virtual Host-虚拟主机"></a>Virtual Host-虚拟主机</h2><ul><li>虚拟地址, 用于进行逻辑隔离, 最上层的消息路由</li><li>一个Virtual Host里面可以有若干个Exchange和Queue</li><li>同一个Virtual Host里面不能有相同名称的Exchange或Queue</li></ul><h2 id="Exchange-交换机"><a href="#Exchange-交换机" class="headerlink" title="Exchange-交换机"></a>Exchange-交换机</h2><p>接收消息，并根据路由键转发消息到所绑定的队列</p><p>注：交换机不会存储消息，如果消息发送到没有绑定消费队列的交换机，消息则丢失。</p><img src="/posts/8e078847/87.jpg" style="zoom:80%;"><p><strong>交换机的属性</strong></p><ul><li>Name : 交换机名称</li><li>Type : 交换机类型, direct, topic, fanout, headers</li><li>Durability : 是否需要持久化, true为持久化</li><li>Auto Delete : 当最后一个绑定到Exchange上的队列删除后, 自动删除该Exchange</li><li>Internal : 当前Exchange是否用于RabbitMQ内部使用, 默认为False, 这个属性很少会用到</li><li>Arguments : 扩展参数, 用于扩展AMQP协议制定化使用</li></ul><p><strong>交换机的四种类型</strong></p><ul><li>Direct exchange（直连交换机）是根据消息携带的路由键（routing key）将消息投递给对应队列的<ul><li>注意 : Direct模式可以使用RabbitMQ自带的Exchange(default Exchange), 所以不需要将Exchange进行任何绑定(binding)操作, 消息传递时, RoutingKey必须完全匹配才会被队列接收, 否则该消息会被抛弃</li></ul></li></ul><img src="/posts/8e078847/88.jpg" class><ul><li>Fanout exchange（扇型交换机）将消息路由给绑定到它身上的所有队列<ul><li>不处理路由键, 只需要简单的将队列绑定到交换机上</li><li>发送到交换机的消息都会被转发到与该交换机绑定的所有队列上</li><li>Fanout交换机转发消息是最快的</li></ul></li></ul><img src="/posts/8e078847/89.jpg" style="zoom: 67%;"><ul><li>Topic exchange（主题交换机）队列通过路由键绑定到交换机上，然后，交换机根据消息里的路由值，将消息路由给一个或多个绑定队列（模糊匹配）<ul><li>“#” : 匹配一个或多个词</li><li>“*” : 匹配一个词</li></ul></li></ul><img src="/posts/8e078847/90.jpg" style="zoom:80%;"><ul><li>Headers exchange（头交换机）类似主题交换机，但是头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。</li></ul><h1 id="RabbitMQ常用的5种工作模式"><a href="#RabbitMQ常用的5种工作模式" class="headerlink" title="RabbitMQ常用的5种工作模式"></a>RabbitMQ常用的5种工作模式</h1><h2 id="1、点对点-简单-的队列"><a href="#1、点对点-简单-的队列" class="headerlink" title="1、点对点(简单)的队列"></a>1、点对点(简单)的队列</h2><img src="/posts/8e078847/91.jpg" class alt="img"><ul><li>不需要交换机</li><li>一个生产者，一个消费者</li></ul><h2 id="2、工作队列（公平性）"><a href="#2、工作队列（公平性）" class="headerlink" title="2、工作队列（公平性）"></a>2、工作队列（公平性）</h2><img src="/posts/8e078847/92.jpg" class alt="img"><ul><li>不需要交换机</li><li>一个生产者，多个消费者，但是一个消息只会发送给一个队列（竞争的消费者模式）</li><li>默认是轮询，即会将消息轮流发给多个消费者，但这样对消费得比较慢的消费者不公平</li><li>可采用公平分配，即能者多劳<ul><li>channel.basicQos(1); &#x2F;&#x2F; 限定：发送一条信息给消费者A，消费者A未反馈处理结果之前，不会再次发送信息给消费者A</li><li>boolean autoAck &#x3D; false; &#x2F;&#x2F; 取消自动反馈 channel.basicConsume(QUEUE_NAME, autoAck, consumer); &#x2F;&#x2F; 接收信息</li><li>channel.basicAck(envelope.getDeliveryTag(), false); &#x2F;&#x2F; 反馈消息处理完毕</li></ul></li></ul><h2 id="3、发布-x2F-订阅"><a href="#3、发布-x2F-订阅" class="headerlink" title="3、发布&#x2F;订阅"></a>3、发布&#x2F;订阅</h2><img src="/posts/8e078847/93.jpg" class alt="img"><ul><li>一个生产者，多个消费者</li><li>每一个消费者都有自己的一个队列</li><li>生产者没有直接发消息到队列中，而是发送到交换机</li><li>每个消费者的队列都绑定到交换机上</li><li>消息通过交换机到达每个消费者的队列</li></ul><p>该模式就是Fanout Exchange（扇型交换机）将消息路由给绑定到它身上的所有队列</p><h2 id="4、路由"><a href="#4、路由" class="headerlink" title="4、路由"></a>4、路由</h2><img src="/posts/8e078847/94.jpg" class alt="img"><p>生产者发送消息到交换机并指定一个路由key，消费者队列绑定到交换机时要制定路由key（key匹配就能接受消息，key不匹配就不能接受消息）</p><p>该模式采用Direct exchange（直连交换机）</p><h2 id="5、主题（通配符）"><a href="#5、主题（通配符）" class="headerlink" title="5、主题（通配符）"></a>5、主题（通配符）</h2><img src="/posts/8e078847/95.jpg" class alt="img"><p>此模式实在路由key模式的基础上，使用了通配符来管理消费者接收消息。生产者P发送消息到交换机X，交换机根据绑定队列的routing key的值进行通配符匹配</p><p>符号#：匹配一个或者多个词lazy.# 可以匹配lazy.irs或者lazy.irs.cor</p><p>符号<em>：只能匹配一个词 lazy.</em> 可以匹配 lazy.irs 或者 lazy.cor</p><p>该模式采用Topic exchange（主题交换机）</p><h1 id="消息可靠性传递或回退（生产者端）"><a href="#消息可靠性传递或回退（生产者端）" class="headerlink" title="消息可靠性传递或回退（生产者端）"></a>消息可靠性传递或回退（生产者端）</h1><p>生产者发送消息出去之后，不知道到底有没有发送到RabbitMQ服务器， 默认是不知道的。而且有的时候我们在发送消息之后，后面的逻辑出问题了，我们不想要发送之前的消息了，需要撤回该怎么做。</p><p><strong>AMQP 事务机制</strong></p><ul><li>txSelect  将当前channel设置为transaction模式</li><li>txCommit  提交当前事务</li><li>txRollback  事务回滚</li></ul><p><strong>Confirm 模式</strong></p><p>消息的确认, 是指生产者投递消息后, 如果Broker收到消息, 则会给我们产生一个应答</p><p>生产者进行接收应答, 用来确定这条消息是否正常发送到Broker, 这种方式也是消息的可靠性投递的核心保障</p><ul><li>在channel上开启确认模式 : channel.confirmSelect()</li><li>在channel上添加监听 : addConfirmListener, 监听成功和失败的返回结果, 根据具体的结果对消息进行重新发送, 或记录日志等后续处理</li></ul><p><strong>Return消息机制</strong></p><p>Return Listener用于处理一些不可路由的消息</p><p>正常情况下消息生产者通过指定一个Exchange和RoutingKey, 把消息送到某一个队列中去, 然后消费者监听队列, 进行消费，但在某些情况下, 如果在发送消息的时候, 当前的exchange不存在或者指定的路由key路由不到,这个时候如果我们需要监听这种不可达的消息, 就要使用Return Listener。</p><p>在基础API中有一个关键的配置项Mandatory : 如果为true, 则监听器会接收到路由不可达的消息, 然后进行后续处理（补偿或人工处理）, 如果为false, 那么broker端自动删除该消息。</p><p><strong>如何保障消息可靠传递</strong></p><ul><li>保障消息的成功发出</li><li>保障MQ节点的成功接收</li><li>发送端收到MQ节点(Broker)的确认应答</li><li>完善的消息补偿机制</li></ul><p>方案：</p><p>1、消息落库, 对消息状态进行标记</p><img src="/posts/8e078847/96.jpg" class alt="img"><ul><li>step1:消息入库</li><li>step2:消息发送</li><li>step3:消费端消息确认</li><li>step4:更新库中消息状态为已确认</li><li>step5:定时任务读取数据库中未确认的消息</li><li>step6:未收到确认结果的消息重新发送</li><li>step7:如果重试几次之后仍然失败, 则将消息状态更改为投递失败的终态, 后面需要人工介入</li></ul><p>2、消息的延迟投递, 做二次确认, 回调检查</p><img src="/posts/8e078847/97.jpg" class alt="img"><ul><li>step1 : 第一次消息发送, 必须业务数据落库之后才能进行消息发送</li><li>step2 : 第二次消息延迟发送, 设定延迟一段时间发送第二次check消息</li><li>step3 : 消费端监听Broker, 进行消息消费</li><li>step4 : 消费成功之后, 发送确认消息到确认消息队列</li><li>step5 : Callback Service监听step4中的确认消息队列, 维护消息状态, 是否消费成功等状态</li><li>step6 : Callback Service监听step2发送的Delay Check的消息队列, 检测内部的消息状态, 如果消息是发送成功状态, 则流程结束, 如果消息是失败状态, 或者查不到当前消息状态时, 会通知生产者, 进行消息重发, 重新上述步骤</li></ul><h1 id="重试机制和幂等性保障（消费者端）"><a href="#重试机制和幂等性保障（消费者端）" class="headerlink" title="重试机制和幂等性保障（消费者端）"></a>重试机制和幂等性保障（消费者端）</h1><p><strong>重试机制</strong></p><p>消费者在消费消息的时候，如果消费者业务逻辑出现程序异常，会使用消息重试机制。</p><ul><li>情况1:  消费者获取到消息后，调用第三方接口，但接口暂时无法访问，是否需要重试?  （需要重试机制）</li><li>情况2:  消费者获取到消息后，抛出数据转换异常，是否需要重试?（不需要重试机制）需要发布进行解决。</li></ul><p>对于情况2，如果消费者代码抛出异常是需要发布新版本才能解决的问题，那么不需要重试，重试也无济于事。应该采用日志记录+定时任务job健康检查+人工进行补偿</p><p><strong>重试机制的实现</strong></p><p>在SpringBoot中，@RabbitListener(queue&#x3D;””)用于消费者监听队列。底层使用Aop进行拦截，如果程序没有抛出异常，则自动提交事务。如果抛出异常，该消息会缓存到RabbitMQ服务器，自动实施重试机制，一直到成功为止。可以配置重试间隔时间和重试的次数。</p><p><strong>幂等性保障</strong></p><p>幂等性：多次执行, 结果保持一致</p><p>网络延迟传输中，消费出现异常或者是消费延迟消费，会造成MQ进行重试补偿，在重试过程中，可能会造成重复消费。</p><p>解决方案：</p><ul><li>唯一ID+指纹码机制<ul><li>唯一ID + 指纹码机制，利用数据库主键去重</li><li>SELECT COUNT(1) FROM T_ORDER WHERE ID &#x3D; 唯一ID +指纹码</li><li>好处：实现简单</li><li>坏处：高并发下有数据库写入的性能瓶颈</li><li>解决方案：跟进ID进行分库分表进行算法路由</li></ul></li><li>利用Redis的原子性去实现<ul><li>在接收到消息后将消息ID作为key执行 setnx 命令，如果执行成功就表示没有处理过这条消息，可以进行消费了，执行失败表示消息已经被消费了。</li></ul></li></ul><h1 id="自动签收与手动签收（消费端）"><a href="#自动签收与手动签收（消费端）" class="headerlink" title="自动签收与手动签收（消费端）"></a>自动签收与手动签收（消费端）</h1><p>默认是自动签收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">false</span>, defaultConsumer); <span class="hljs-comment">//关闭自动签收，变为手动签收</span><br>channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>); <span class="hljs-comment">// 手工签收, 第二个参数表示是否批量签收</span><br></code></pre></td></tr></table></figure><h1 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h1><p>消息队列中囤积了大量的消息, 或者某些时刻生产的消息远远大于消费者处理能力的时候, 这个时候如果消费者一次取出大量的消息, 但是客户端又无法处理, 就会出现问题, 甚至可能导致服务崩溃, 所以需要对消费端进行限流</p><p>RabbitMQ提供了一种qos(服务质量保证)功能, 即在非自动确认消息的前提下, 如果一定数目的消息(通过consumer或者channel设置qos的值)未被确认前, 不进行消费新的消息</p><ul><li>自动签收要设置成false, 建议实际工作中也设置成false</li><li><code>void basicQos(int prefetchSize, int prefetchCount, boolean global) throws IOException;</code><ul><li><code>prefetchSize</code> : 消息大小限制, 一般设置为0, 消费端不做限制</li><li><code>prefetchCount</code> : 会告诉RabbitMQ不要同时给一个消费者推送多于N个消息, 即一旦有N个消息还没有ack, 则该consumer将block(阻塞), 直到有消息ack</li><li><code>global</code> : true&#x2F;false 是否将上面设置应用于channel, 简单来说就是上面的限制是channel级别的还是consumer级别 注意 :</li></ul></li></ul><p>prefetchSize和global这两项，RabbitMQ没有实现，暂且不关注，prefetchCount在autoAck设置false的情况下生效,即在自动确认的情况下这个值是不生效的</p><p>限流可实现公平队列。</p><h1 id="消费端ACK和重回队列"><a href="#消费端ACK和重回队列" class="headerlink" title="消费端ACK和重回队列"></a>消费端ACK和重回队列</h1><p><strong>消费端ACK</strong></p><ul><li>消费端的手工ACK和NACK, ACK是确认成功消费, NACK表示消息处理失败, 会重发消息</li><li>消费端进行消费的时候, 如果由于业务异常我们可以进行日志的记录, 然后进行补偿</li><li>如果由于服务器宕机等严重问题, 就需要手工进行ACK保障消费端消费成功</li></ul><p><strong>重回队列</strong></p><ul><li>消费端重回队列是为了对没有处理成功的消息, 把消息重新回递给Broker</li><li>一般在实际应用中, 都会关闭重回队列, 也就是设置为False</li></ul><h1 id="TTL队列-x2F-消息"><a href="#TTL队列-x2F-消息" class="headerlink" title="TTL队列&#x2F;消息"></a>TTL队列&#x2F;消息</h1><ul><li>TTL是Time To Live的缩写, 也就是生存时间</li><li>RabbitMQ支持消息的过期时间, 在消息发送时可以进行指定</li><li>RabbitMQ支持队列的过期时间, 从消息入队列开始计算, 只要超过了队列的超时时间配置, 那么消息会自动清除</li></ul><h1 id="死信队列（DLX）"><a href="#死信队列（DLX）" class="headerlink" title="死信队列（DLX）"></a>死信队列（DLX）</h1><ul><li>Dead-Letter-Exchange</li><li>利用DLX, 当消息在一个队列中变成死信(dead message)之后, 它能被重新publish到另一个Exchange, 这个Exchange就是DLX</li><li>DLX也是一个正常的Exchange, 和一般的Exchange没有区别, 它能在任何队列上被指定, 实际上就是设置某个队列的属性为死信队列</li><li>当这个队列中有死信时, RabbitMQ就会自动将这个消息重新发布到设置的Exchange上去, 进而被路由到另一个队列</li><li>可以监听这个队列中消息做相应的处理, 这个特性可以弥补RabbitMQ3.0以前支持的immediate参数的功能</li></ul><p><strong>消息变成死信有以下几种情况 :</strong></p><ul><li>消息被拒绝(basic.reject&#x2F;basic.nack) 并且requeue重回队列设置成false<ul><li>channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); &#x2F;&#x2F;丢弃消息</li></ul></li><li>消息TTL过期</li><li>队列达到最大长度</li></ul><p><strong>死信队列的设置 :</strong></p><ol><li>设置死信队列属性实现</li></ol><ul><li>首先要设置死信队列的exchange和queue, 然后进行绑定<ul><li>Exchange : dlx.exchange</li><li>Queue : dlx.queue</li><li>RoutingKey : #</li></ul></li><li>然后正常声明交换机, 队列, 绑定, 只不过需要在队列加上一个扩展参数即可 : arguments.put(“x-dead-letter-exchange”, “dlx.exchange”);</li><li>这样消息在过期, reject或nack(requeue要设置成false), 队列在达到最大长度时, 消息就可以直接路由到死信队列。</li></ul><ol start="2"><li>用rabbitmq-delayed-message-exchange插件实现延迟队列</li></ol><h1 id="RabbitMQ负载均衡"><a href="#RabbitMQ负载均衡" class="headerlink" title="RabbitMQ负载均衡"></a>RabbitMQ负载均衡</h1><ol><li><p><strong>轮询法</strong></p></li><li><p><strong>随机法</strong></p></li><li><p><strong>源地址哈希法</strong></p></li><li><p><strong>加权轮询法</strong></p></li><li><p><strong>加权随机法</strong></p></li><li><p><strong>最小连接数法</strong></p></li></ol><h1 id="RabbitMQ之如何保障数据不丢失"><a href="#RabbitMQ之如何保障数据不丢失" class="headerlink" title="RabbitMQ之如何保障数据不丢失"></a>RabbitMQ之如何保障数据不丢失</h1><h2 id="1、费者实例宕机的时候，如何保障数据是不会丢失？"><a href="#1、费者实例宕机的时候，如何保障数据是不会丢失？" class="headerlink" title="1、费者实例宕机的时候，如何保障数据是不会丢失？"></a>1、费者实例宕机的时候，如何保障数据是不会丢失？</h2><p>手动ack机制非常的简单，必须要消费者确保自己处理完毕了一个消息，才能手动发送ack给MQ，MQ收到ack之后才会删除这个消息，如果消费者还没发送ack，消费者自己就宕机了，此时MQ感知到它的宕机，就会重新投递这条消息给其他的消费者实例。通过这种机制保证消费者实例宕机的时候，数据是不会丢失的。</p><p>如果采用手动ack机制，实际上消费者服务每次消费了一条消息，处理完毕完成消费之后，就会发送一个ack消息给RabbitMQ服务器，这个ack消息是会带上自己本次消息的delivery tag的。</p><p>这里大家必须注意的一点，就是delivery tag仅仅在一个channel内部是唯一标识消息投递的。所以说，你ack一条消息的时候，必须是通过接受这条消息的同一个channel来进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<span class="hljs-comment">//表给示消费者成功消费，返回给MQ</span><br></code></pre></td></tr></table></figure><h2 id="2、分析手动ack和默认自动ack区别？"><a href="#2、分析手动ack和默认自动ack区别？" class="headerlink" title="2、分析手动ack和默认自动ack区别？"></a>2、分析手动ack和默认自动ack区别？</h2><p>①实际上默认用自动ack，是非常简单的。RabbitMQ只要投递一个消息出去给仓储服务，那么他立马就把这个消息给标记为删除，因为他是不管消费者服务到底接收到没有，或者处理完没有。所以这种情况下，<strong>性能很好，但是数据容易丢失</strong>。</p><p>②如果手动ack，那么就是必须等消费者服务完成消费以后，才会手动发送ack给RabbitMQ，此时RabbitMQ才会认为消息处理完毕，然后才会标记消息为删除。这样在发送ack之前，消费者服务宕机，<strong>RabbitMQ会重发消息给另外一个消费者服务实例，保证数据不丢失</strong>。</p><h2 id="3、如何保证生产者投递到消息中间件-MQ-的消息不丢失？"><a href="#3、如何保证生产者投递到消息中间件-MQ-的消息不丢失？" class="headerlink" title="3、如何保证生产者投递到消息中间件(MQ)的消息不丢失？"></a>3、如何保证生产者投递到消息中间件(MQ)的消息不丢失？</h2><p><strong>问题：</strong>如果投递出去的消息在网络传输过程中丢失，或者在RabbitMQ的内存中还没写入磁盘的时候宕机，都会导致生产端投递到MQ的数据丢失。而且丢失之后，生产者自己还感知不到，同时还没办法来补救。</p><p>生产者需要开启confirm模式，投递消息到MQ，如果MQ一旦将消息持久化到磁盘之后，必须也要回传一个confirm消息给生产端。这样的话，如果生产端的服务接收到了这个confirm消息，就知道是已经持久化到磁盘了。如果没有接收到confirm消息，那么就说明这条消息半路可能丢失了，此时你就可以重新投递消息到MQ去，确保消息不要丢失。</p><p>而且一旦你开启了confirm模式之后，每次消息投递也同样是有一个delivery tag的，也是起到唯一标识一次消息投递的作用。这样，MQ回传ack给生产端的时候，会带上这个delivery tag。你就知道具体对应着哪一次消息投递了，可以删除这条消息。</p><p>此外，如果RabbitMQ接收到一条消息之后，结果内部出错发现无法处理这条消息，那么MQ会回传一个nack消息给生产者。此时生产者就会感知到这条消息可能处理有问题，你可以选择重新再次投递这条消息到MQ去。</p><p>或者另一种情况，如果某条消息很长时间都没给你回传ack&#x2F;nack，那可能是极端意外情况发生了，数据也丢了，你也可以自己重新投递消息到MQ去。</p><h2 id="4、confirm机制投递消息的高延迟性"><a href="#4、confirm机制投递消息的高延迟性" class="headerlink" title="4、confirm机制投递消息的高延迟性"></a>4、<strong>confirm机制投递消息的高延迟性</strong></h2><p>一旦启用了confirm机制投递消息到MQ之后，MQ是不保证什么时候会给你一个ack或者nack的。</p><p>因为RabbitMQ自己内部将消息持久化到磁盘，本身就是通过异步批量的方式来进行的。正常情况下，你投递到RabbitMQ的消息都会先驻留在内存里，然后过了几百毫秒的延迟时间之后，再一次性批量把多条消息持久化到磁盘里去。这样做，是为了兼顾高并发写入的吞吐量和性能的，因为要是你来一条消息就写一次磁盘，那么性能会很差，每次写磁盘都是一次fsync强制刷入磁盘的操作，是很耗时的。</p><p><strong>那如何解决呢？</strong></p><p>绝对不能以****同步*<em><strong>写消息 + 等待ack的方式来投递消息，用来临时存放未ack消息的存储需要承载高并发写入，而且我们不需要什么复杂的运算操作，这种存储首选绝对不是MySQL之类的关系数据库，而</strong>建议采用kv存储</em>*。kv存储承载高并发能力极强，而且kv操作性能很高。</p><p>生产者消息投递出去之后并且在kv存储器存储，这个投递的线程其实就可以返回了，至于每个消息的异步回调，是通过在channel注册一个confirm监听器实现的。生产者收到一个消息ack之后，就从kv存储中删除这条临时消息；收到一个消息nack之后，就从kv存储提取这条消息然后重新投递一次即可；也可以自己对kv存储里的消息做监控，如果超过一定时长没收到ack，就主动重发消息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RabbitMQ详解&quot;&gt;&lt;a href=&quot;#RabbitMQ详解&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ详解&quot;&gt;&lt;/a&gt;RabbitMQ详解&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;RabbitMQ的优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;</summary>
      
    
    
    
    <category term="中间件" scheme="https://blog.yahyav2rayssr.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="消息队列" scheme="https://blog.yahyav2rayssr.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    <category term="RabbitMQ" scheme="https://blog.yahyav2rayssr.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/"/>
    
    
    <category term="rabbitmq" scheme="https://blog.yahyav2rayssr.top/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>Redis 三种集群架构</title>
    <link href="https://blog.yahyav2rayssr.top/posts/17835f44/"/>
    <id>https://blog.yahyav2rayssr.top/posts/17835f44/</id>
    <published>2023-04-16T11:32:05.798Z</published>
    <updated>2023-04-16T11:32:05.798Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h1><p>Redis基于Reactor模式开发了自己的网络事件处理器，被称为文件事件处理器，由套接字、I&#x2F;O多路复用程序、文件事件分派器（dispatcher），事件处理器四部分组成。</p><img src="/posts/17835f44/1733c64202a74236.jpg" class alt="img"><h2 id="redis为什么那么快"><a href="#redis为什么那么快" class="headerlink" title="redis为什么那么快"></a>redis为什么那么快</h2><ul><li>redis是纯内存操作：数据存放在内存中，内存的响应时间大约是100纳秒，这是Redis每秒万亿级别访问的重要基础。</li><li>非阻塞I&#x2F;O：Redis采用epoll做为I&#x2F;O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接，读写，关闭都转换为了时间，不在I&#x2F;O上浪费过多的时间。</li><li>单线程避免了线程切换和竞态产生的消耗。</li></ul><h1 id="redis-三种集群模式"><a href="#redis-三种集群模式" class="headerlink" title="redis 三种集群模式"></a>redis 三种集群模式</h1><p><a href="https://juejin.im/post/6847902223913992200">redis系列之——分布式锁</a></p><p><a href="https://juejin.im/post/6847902224144662542">redis系列之——缓存穿透、缓存击穿、缓存雪崩</a></p><p><a href="https://juejin.im/post/6850418109493444621">redis系列之——Redis为什么这么快？</a></p><p><a href="https://juejin.im/post/6854573210080378888">redis系列之——数据持久化（RDB和AOF）</a></p><p><a href="https://juejin.im/post/6850418113830846471">redis系列之——一致性hash算法</a></p><p><a href="https://juejin.im/post/6850418111846449165">redis系列之——高可用（主从、哨兵、集群）</a></p><p><a href="https://juejin.im/post/6854573210927644679">redis系列之——事物及乐观锁</a></p><p><a href="https://juejin.im/post/6847902224148856845">redis系列之——数据类型geospatial：你隔壁有没有老王？</a></p><p><a href="https://juejin.im/post/6850418111049367560">redis系列之——数据类型bitmaps：今天你签到了吗？</a></p><p><a href="https://juejin.im/post/6850418111070339085">布隆过滤器是个啥！</a></p><p>所谓的高可用，也叫HA（High Availability），是分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计减少系统不能提供服务的时间。</p><p>如果在实际生产中，如果redis只部署一个节点，当机器故障时，整改服务都不能提供服务了。这就是我们常说的单点故障。</p><p>如果redis部署了多台，当一台或几台故障时，整个系统依然可以对外提供服务，这样就提高了服务的可用性。</p><p>今天我们就聊聊redis高可用的三种模式：<strong>主从模式</strong>，<strong>哨兵模式</strong>，<strong>集群模式</strong>。</p><h2 id="一、主从模式"><a href="#一、主从模式" class="headerlink" title="一、主从模式"></a>一、主从模式</h2><p>一般，系统的高可用都是通过部署多台机器实现的。redis为了避免单点故障，也需要部署多台机器。</p><p>因为部署了多台机器，所以就会涉及到不同机器的的数据同步问题。</p><p>为此，redis提供了Redis提供了复制(replication)功能，当一台redis数据库中的数据发生了变化，这个变化会被自动的同步到其他的redis机器上去。</p><p>redis多机器部署时，这些机器节点会被分成两类，一类是主节点（master节点），一类是从节点（slave节点）。一般主节点可以进行读、写操作，而从节点只能进行读操作。同时由于主节点可以写，数据会发生变化，当主节点的数据发生变化时，会将变化的数据同步给从节点，这样从节点的数据就可以和主节点的数据保持一致了。一个主节点可以有多个从节点，但是一个从节点会只会有一个主节点，也就是所谓的一主多从结构。</p><img src="/posts/17835f44/format,png.png" class alt="一主多从"><h3 id="1-1-机器规划"><a href="#1-1-机器规划" class="headerlink" title="1.1.机器规划"></a>1.1.机器规划</h3><table><thead><tr><th>机器名称</th><th>IP</th><th>端口</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.10</td><td>6379</td></tr><tr><td>slave1</td><td>192.168.1.11</td><td>6379</td></tr><tr><td>slave2</td><td>192.168.1.12</td><td>6379</td></tr><tr><td>slave3</td><td>192.168.1.13</td><td>6379</td></tr></tbody></table><h3 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2.配置"></a>1.2.配置</h3><p><strong>主节点配置</strong></p><p>主节点按照正常的配置配好即可。</p><p><strong>从节点配置</strong></p><p>使用默认的配置启动机器，机器都是主节点。如果想要让机器变成从节点，需要在conf服务器上配置主从复制的相关参数。</p><ul><li>在从节点的配置文件redis.conf中指定主节点的信息（如果需要的话，可以配置主节点的登录密码，主从复制相关的参数）。三台从节点的配置是一样的。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置主节点的ip和端口</span><br>slaveof 192.168.1.10 6379<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从redis2.6开始，从节点默认是只读的</span><br>slave-read-only yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">假设主节点有登录密码，是123456</span><br>masterauth 123456<br></code></pre></td></tr></table></figure><ul><li>也可以不配置上面的文件，使用redis-server命令，在启动从节点时，通过参数–slaveof指定主节点是谁。。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./redis-server --slaveof 192.168.1.10 6379<br></code></pre></td></tr></table></figure><ul><li>也可以不配上面的文件，正常启动redis机器，然后通过<code>redis-cli</code>的命令行执行<code>slaveof 192.168.1.10 6379</code>指定主节点是谁。</li></ul><p>系统运行时，如果master挂掉了，可以在一个从库（如slave1）上手动执行命令<code>slaveof no one</code>，将slave1变成新的master；在slave2和slave3上分别执行<code>slaveof 192.168.1.11 6379</code> 将这两个机器的主节点指向的这个新的master；同时，挂掉的原master启动后作为新的slave也指向新的master上。</p><p>执行命令<code>slaveof no one</code>命令，可以关闭从服务器的复制功能。同时原来同步的所得的数据集都不会被丢弃。</p><h3 id="1-3-机器启动"><a href="#1-3-机器启动" class="headerlink" title="1.3.机器启动"></a>1.3.机器启动</h3><p>首先启动主节点，然后一台一台启动从节点。</p><h3 id="1-4-主从复制的机制"><a href="#1-4-主从复制的机制" class="headerlink" title="1.4.主从复制的机制"></a>1.4.主从复制的机制</h3><img src="/posts/17835f44/format,png-16815647991305.png" alt="复制机制" style="zoom:67%;"><ul><li>从数据库连接主数据库，发送SYNC命令;</li><li>主数据库接收到SYNC命令后，可以执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令;</li><li>主数据库BGSAVE执行完后，向所有从数据库发送快照文件，并在发送期间继续记录被执行的写命令;</li><li>从数据库收到快照文件后丢弃所有旧数据，载入收到的快照;</li><li>主数据库快照发送完毕后开始向从数据库发送缓冲区中的写命令;</li><li>从数据库完成对快照的载入，开始接受命令请求，并执行来自主数据库缓冲区的写命令;(<strong>从数据库初始化完成</strong>)</li><li>主数据库每执行一个写命令就会向从数据库发送相同的写命令，从数据库接收并执行收到的写命令(<strong>从数据库初始化完成后的操作</strong>)</li><li>出现断开重连后，2.8之后的版本会将断线期间的命令传给从数据库，增量复制。</li><li><strong>主从刚刚连接的时候，进行全量同步;全同步结束后，进行增量同步</strong>。当然，如果有需要，slave在任何时候都可以发起全量同步。Redis的策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</li></ul><h3 id="1-5-主从模式的优缺点"><a href="#1-5-主从模式的优缺点" class="headerlink" title="1.5.主从模式的优缺点"></a>1.5.主从模式的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>支持主从复制，主机会自动将数据同步到从机，可以进行读写分离;</li><li>为了分载Master的读操作压力，Slave服务器可以为客户端提供只读操作的服务，写服务依然必须由Master来完成;</li><li>Slave同样可以接受其他Slaves的连接和同步请求，这样可以有效地分载Master的同步压力;</li><li>Master是以非阻塞的方式为Slaves提供服务。所以在Master-Slave同步期间，客户端仍然可以提交查询或修改请求;</li><li>Slave同样是以阻塞的方式完成数据同步。在同步期间，如果有客户端提交查询请求，Redis则返回同步之前的数据。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>Redis不具备自动容错和恢复功能，主机从机的宕机都会导致前端部分读写请求失败，需要等待机器重启或者手动切换前端的IP才能恢复;</li><li>主机宕机，宕机前有部分数据未能及时同步到从机，切换IP后还会引入数据不一致的问题，降低了系统的可用性;</li><li>如果多个Slave断线了，需要重启的时候，尽量不要在同一时间段进行重启。因为只要Slave启动，就会发送sync请求和主机全量同步，当多个Slave重启的时候，可能会导致Master IO剧增从而宕机。</li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂;</li><li>redis的主节点和从节点中的数据是一样的，降低的内存的可用性</li></ul><h2 id="二、哨兵模式"><a href="#二、哨兵模式" class="headerlink" title="二、哨兵模式"></a>二、哨兵模式</h2><p>主从模式下，当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这种方式并不推荐，实际生产中，我们优先考虑哨兵模式。这种模式下，master宕机，哨兵会自动选举master并将其他的slave指向新的master。</p><p>在主从模式下，redis同时提供了哨兵命令<code>redis-sentinel</code>，哨兵是一个独立的进程，作为进程，它会独立运行。其原理是哨兵进程向所有的redis机器发送命令，等待Redis服务器响应，从而监控运行的多个Redis实例。</p><p>哨兵可以有多个，一般为了便于决策选举，使用奇数个哨兵。哨兵可以和redis机器部署在一起，也可以部署在其他的机器上。多个哨兵构成一个哨兵集群，哨兵直接也会相互通信，检查哨兵是否正常运行，同时发现master宕机哨兵之间会进行决策选举新的master</p><img src="/posts/17835f44/format,png-16815648179018.png" class alt="哨兵模式"><p>哨兵模式的作用:</p><ul><li>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器;</li><li>当哨兵监测到master宕机，会自动将slave切换到master，然后通过<em>发布订阅模式</em>通过其他的从服务器，修改配置文件，让它们切换主机;</li><li>然而一个哨兵进程对Redis服务器进行监控，也可能会出现问题，为此，我们可以使用多个哨兵进行监控。各个哨兵之间还会进行监控，这样就形成了多哨兵模式。</li></ul><p>哨兵很像kafka集群中的zookeeper的功能。</p><h3 id="2-1-机器规划"><a href="#2-1-机器规划" class="headerlink" title="2.1.机器规划"></a>2.1.机器规划</h3><table><thead><tr><th>机器名称</th><th>IP</th><th>端口</th></tr></thead><tbody><tr><td>master</td><td>192.168.1.10</td><td>6379</td></tr><tr><td>slave 1</td><td>192.168.1.11</td><td>6379</td></tr><tr><td>slave 2</td><td>192.168.1.12</td><td>6379</td></tr><tr><td>slave 3</td><td>192.168.1.13</td><td>6379</td></tr><tr><td>sentinel 1</td><td>192.168.1.14</td><td>26379</td></tr><tr><td>sentinel 2</td><td>192.168.1.15</td><td>26379</td></tr><tr><td>sentinel 3</td><td>192.168.1.16</td><td>26379</td></tr></tbody></table><p>这里我们将哨兵进程和redis分别部署在不同的机器上，避免因为redis宕机导致sentinel进程不可用。</p><h3 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2.配置"></a>2.2.配置</h3><p>redis.conf的配置和上面主从模式一样，不用变。这里主要说一下哨兵的配置。</p><p>每台机器的哨兵进程都需要一个哨兵的配置文件<code>sentinel.conf</code>，三台机器的哨兵配置是一样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">禁止保护模式</span><br>protected-mode no<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">192.168.1.10代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span><br>sentinel monitor mymaster 192.168.1.10 6379 2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span><br>sentinel auth-pass mymaster 123456<br></code></pre></td></tr></table></figure><h3 id="2-3-机器启动"><a href="#2-3-机器启动" class="headerlink" title="2.3.机器启动"></a>2.3.机器启动</h3><p>首先启动主节点，然后一台一台启动从节点。</p><p>redis集群启动完成后，分别启动哨兵集群所在机器的三个哨兵，使用<code>redis-sentinel /path/to/sentinel.conf</code>命令。</p><h3 id="2-4-哨兵模式的工作"><a href="#2-4-哨兵模式的工作" class="headerlink" title="2.4.哨兵模式的工作"></a>2.4.哨兵模式的工作</h3><ul><li>每个Sentinel（哨兵）进程以每秒钟一次的频率向整个集群中的Master主服务器，Slave从服务器以及其他Sentinel（哨兵）进程发送一个 PING 命令。</li><li>如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel（哨兵）进程标记为主观下线（SDOWN）</li><li>如果一个Master主服务器被标记为主观下线（SDOWN），则正在监视这个Master主服务器的所有 Sentinel（哨兵）进程要以每秒一次的频率确认Master主服务器的确进入了主观下线状态</li><li>当有足够数量的 Sentinel（哨兵）进程（大于等于配置文件指定的值）在指定的时间范围内确认Master主服务器进入了主观下线状态（SDOWN）， 则Master主服务器会被标记为客观下线（ODOWN）</li><li>在一般情况下， 每个 Sentinel（哨兵）进程会以每 10 秒一次的频率向集群中的所有Master主服务器、Slave从服务器发送 INFO 命令。</li><li>当Master主服务器被 Sentinel（哨兵）进程标记为客观下线（ODOWN）时，Sentinel（哨兵）进程向下线的 Master主服务器的所有 Slave从服务器发送 INFO 命令的频率会从 10 秒一次改为每秒一次。</li><li>若没有足够数量的 Sentinel（哨兵）进程同意 Master主服务器下线， Master主服务器的客观下线状态就会被移除。若 Master主服务器重新向 Sentinel（哨兵）进程发送 PING 命令返回有效回复，Master主服务器的主观下线状态就会被移除。</li></ul><p>假设master宕机，sentinel 1先检测到这个结果，系统并不会马上进行 failover(故障转移)选出新的master，仅仅是sentinel 1主观的认为master不可用，这个现象成为<strong>主观下线</strong>。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由sentinel 1发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为<strong>客观下线</strong>。这样对于客户端而言，一切都是透明的。</p><h3 id="2-5-主从模式的优缺点"><a href="#2-5-主从模式的优缺点" class="headerlink" title="2.5.主从模式的优缺点"></a>2.5.主从模式的优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。</li><li>主从可以自动切换，系统更健壮，可用性更高。</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>具有主从模式的缺点，每台机器上的数据是一样的，内存的可用性较低。</li><li>Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li></ul><h2 id="三、集群模式"><a href="#三、集群模式" class="headerlink" title="三、集群模式"></a>三、集群模式</h2><p>先说一个误区：<strong>Redis的集群模式本身没有使用一致性hash算法，而是使用slots插槽</strong>。这是很多人的一个误区。这里先留个坑，后面我会出一期《 redis系列之——一致性hash算法》。</p><p>Redis 的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了 Cluster 集群模式，实现了 Redis 的分布式存储，对数据进行分片，也就是说每台 Redis 节点上存储不同的内容；</p><img src="/posts/17835f44/format,png-168156483733411.png" class alt="集群模式"><p>这里的6台redis两两之间并不是独立的，每个节点都会通过集群总线(cluster bus)，与其他的节点进行通信。通讯时使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是16379。nodes之间的通信采用特殊的二进制协议。</p><p>对客户端来说，整个cluster被看做是一个整体，客户端可以连接任意一个node进行操作，就像操作单一Redis实例一样，当客户端操作的key没有分配到该node上时，Redis会返回转向指令，指向正确的node，这有点儿像浏览器页面的302 redirect跳转。</p><p>根据官方推荐，集群部署至少要 3 台以上的master节点，最好使用 3 主 3 从六个节点的模式。测试时，也可以在一台机器上部署这六个实例，通过端口区分出来。</p><h3 id="3-1-机器规划"><a href="#3-1-机器规划" class="headerlink" title="3.1.机器规划"></a>3.1.机器规划</h3><table><thead><tr><th>机器名称</th><th>IP</th><th>端口</th></tr></thead><tbody><tr><td>master 1</td><td>192.168.1.11</td><td>6379</td></tr><tr><td>master 2</td><td>192.168.1.12</td><td>6379</td></tr><tr><td>master 3</td><td>192.168.1.13</td><td>6379</td></tr><tr><td>slave 1</td><td>192.168.1.21</td><td>6379</td></tr><tr><td>slave 2</td><td>192.168.1.22</td><td>6379</td></tr><tr><td>slave 3</td><td>192.168.1.23</td><td>6379</td></tr></tbody></table><h3 id="3-2-配置"><a href="#3-2-配置" class="headerlink" title="3.2.配置"></a>3.2.配置</h3><p>修改<code>redis.conf</code> 的配置文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开启redis的集群模式</span><br>cluster-enabled yes<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置集群模式下的配置文件名称和位置,redis-cluster.conf这个文件是集群启动后自动生成的，不需要手动配置。</span><br>cluster-config-file redis-cluster.conf<br></code></pre></td></tr></table></figure><h3 id="3-3-机器启动"><a href="#3-3-机器启动" class="headerlink" title="3.3.机器启动"></a>3.3.机器启动</h3><p>6个 Redis 服务分别启动成功之后，这时虽然配置了集群开启，但是这六台机器还是独立的。使用集群管理命令将这6台机器添加到一个集群中。</p><p>借助 redis-tri.rb 工具可以快速的部署集群。</p><p>只需要执行<code>redis-trib.rb create --replicas 1 192.168.1.11:6379 192.168.1.21:6379 192.168.1.12:6379 192.168.1.22:6379 192.168.1.13:6379 192.168.1.23:6379</code>就可以成功创建集群。</p><p>该命令执行创建完成后会有响应的日志，通过相关的日志就可以看出集群中机器的关系(不一定和上图对应)，执行的日志如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Performing <span class="hljs-built_in">hash</span> slots allocation on 6 nodes...</span><br>Master[0] -&gt; Slots 0 - 5460<br>Master[1] -&gt; Slots 5461 - 10922<br>Master[2] -&gt; Slots 10923 - 16383<br>Adding replica 192.168.1.21:6379 to 192.168.1.11:6379<br>Adding replica 192.168.1.22:6379 to 192.168.1.12:6379<br>Adding replica 192.168.1.23:6379 to 192.168.1.13:6379<br>M: 80c80a3f3e33872c047a8328ad579b9bea001ad8 192.168.1.11:6379<br>   slots:[0-5460] (5461 slots) master<br>S: b4d3eb411a7355d4767c6c23b4df69fa183ef8bc 192.168.1.21:6379<br>   replicates 6788453ee9a8d7f72b1d45a9093838efd0e501f1<br>M: 4d74ec66e898bf09006dac86d4928f9fad81f373 192.168.1.12:6379<br>   slots:[5461-10922] (5462 slots) master<br>S: b6331cbc986794237c83ed2d5c30777c1551546e 192.168.1.22:6379<br>   replicates 80c80a3f3e33872c047a8328ad579b9bea001ad8<br>M: 6788453ee9a8d7f72b1d45a9093838efd0e501f1 192.168.1.13:6379<br>   slots:[10923-16383] (5461 slots) master<br>S: 277daeb8660d5273b7c3e05c263f861ed5f17b92 192.168.1.23:6379<br>   replicates 4d74ec66e898bf09006dac86d4928f9fad81f373<br>Can I set the above configuration? (type &#x27;yes&#x27; to accept): yes                  # 输入yes，接受上面配置<br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Nodes configuration updated</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Assign a different config epoch to each node</span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; Sending CLUSTER MEET messages to <span class="hljs-built_in">join</span> the cluster</span><br></code></pre></td></tr></table></figure><p>执行完成后自动生成配置的redis-cluster.conf文件。</p><p>登录集群：<code>redis-cli -c -h 192.168.1.11 -p 6379 -a 123456 # -c，使用集群方式登录</code>。</p><p>查看集群信息：<code>192.168.1.11:6379&gt; CLUSTER INFO #集群状态</code>。</p><p>列出节点信息：<code>192.168.1.11:6379&gt; CLUSTER NODES #列出节点信息</code>。</p><p>添加数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.1.11:6379&gt; set name aaa<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [13680] located at 192.168.1.13:6379                <span class="hljs-comment"># 说明最终将数据写到了192.168.1.13:6379上</span></span><br>OK<br></code></pre></td></tr></table></figure><p>获取数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.1.11:6379&gt; get name<br><span class="hljs-meta prompt_">-&gt; </span><span class="language-bash">Redirected to slot [13680] located at 192.168.1.13:6379                <span class="hljs-comment"># 说明最终到192.168.1.13:6379上读数据</span></span><br>&quot;aaa&quot;<br></code></pre></td></tr></table></figure><h3 id="3-4-运行机制"><a href="#3-4-运行机制" class="headerlink" title="3.4.运行机制"></a>3.4.运行机制</h3><p>在 Redis 的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383，可以从上面<code>redis-trib.rb</code>执行的结果看到这16383个slot在三个master上的分布。还有一个就是cluster，可以理解为是一个集群管理的插件，类似的哨兵。</p><p>当我们的存取的 Key到达的时候，Redis 会根据 crc16的算法对计算后得出一个结果，然后把结果和16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p><p>当数据写入到对应的master节点后，这个数据会同步给这个master对应的所有slave节点。</p><p>为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点。当其它主节点ping主节点master 1时，如果半数以上的主节点与master 1通信超时，那么认为master 1宕机了，就会启用master 1的从节点slave 1，将slave 1变成主节点继续提供服务。</p><p>如果master 1和它的从节点slave 1都宕机了，整个集群就会进入fail状态，因为集群的slot映射不完整。如果集群超过半数以上的master挂掉，无论是否有slave，集群都会进入fail状态。</p><p>redis-cluster采用去中心化的思想，没有中心节点的说法，客户端与Redis节点直连，不需要中间代理层，客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可。</p><h3 id="3-5-集群扩缩容"><a href="#3-5-集群扩缩容" class="headerlink" title="3.5.集群扩缩容"></a>3.5.集群扩缩容</h3><p>对redis集群的扩容就是向集群中添加机器，缩容就是从集群中删除机器，并重新将16383个slots分配到集群中的节点上（数据迁移）。</p><p>扩缩容也是使用集群管理工具 redis-tri.rb。</p><p>扩容时，先使用<code>redis-tri.rb add-node</code>将新的机器加到集群中，这是新机器虽然已经在集群中了，但是没有分配slots，依然是不起做用的。在使用 <code>redis-tri.rb reshard</code>进行分片重哈希（数据迁移），将旧节点上的slots分配到新节点上后，新节点才能起作用。</p><p>缩容时，先要使用 <code>redis-tri.rb reshard</code>移除的机器上的slots，然后使用<code>redis-tri.rb add-del</code>移除机器。</p><h3 id="3-8-集群模式的优缺点"><a href="#3-8-集群模式的优缺点" class="headerlink" title="3.8.集群模式的优缺点"></a>3.8.集群模式的优缺点</h3><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>采用去中心化思想，数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布;</p><p>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除;</p><p>高可用性：部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave 到 Master 的角色提升;</p><p>降低运维成本，提高系统的扩展性和可用性。</p><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>1.Redis Cluster是无中心节点的集群架构，依靠Goss协议(谣言传播)协同自动化修复集群的状态</p><p>但 GosSIp有消息延时和消息冗余的问题，在集群节点数量过多的时候，节点之间需要不断进行 PING&#x2F;PANG通讯，不必须要的流量占用了大量的网络资源。虽然Reds4.0对此进行了优化，但这个问题仍然存在。</p><p>2.数据迁移问题</p><p>Redis Cluster可以进行节点的动态扩容缩容，这一过程，在目前实现中，还处于半自动状态，需要人工介入。在扩缩容的时候，需要进行数据迁移。</p><p>而 Redis为了保证迁移的一致性，迁移所有操作都是同步操作，执行迁移时，两端的 Redis均会进入时长不等的阻塞状态，对于小Key，该时间可以忽略不计，但如果一旦Key的内存使用过大，严重的时候会接触发集群内的故障转移，造成不必要的切换。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>主从模式：master节点挂掉后，需要手动指定新的master，可用性不高，基本不用。</p><p>哨兵模式：master节点挂掉后，哨兵进程会主动选举新的master，可用性高，但是每个节点存储的数据是一样的，浪费内存空间。数据量不是很多，集群规模不是很大，需要自动容错容灾的时候使用。</p><p>集群模式：数据量比较大，QPS要求较高的时候使用。 <strong>Redis Cluster是Redis 3.0以后才正式推出，时间较晚，目前能证明在大规模生产环境下成功的案例还不是很多，需要时间检验。</strong></p><p>完成，收工！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis线程模型&quot;&gt;&lt;a href=&quot;#Redis线程模型&quot; class=&quot;headerlink&quot; title=&quot;Redis线程模型&quot;&gt;&lt;/a&gt;Redis线程模型&lt;/h1&gt;&lt;p&gt;Redis基于Reactor模式开发了自己的网络事件处理器，被称为文件事件处理器，由</summary>
      
    
    
    
    <category term="中间件" scheme="https://blog.yahyav2rayssr.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="Redis" scheme="https://blog.yahyav2rayssr.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
    <category term="Redis" scheme="https://blog.yahyav2rayssr.top/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 基础</title>
    <link href="https://blog.yahyav2rayssr.top/posts/47eac6e4/"/>
    <id>https://blog.yahyav2rayssr.top/posts/47eac6e4/</id>
    <published>2023-04-16T11:19:30.748Z</published>
    <updated>2023-04-16T11:19:30.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="explain解析"><a href="#explain解析" class="headerlink" title="explain解析"></a>explain解析</h1><p>+—-+————-+——-+————+——+—————+——+———+——+——–+———-+——-+<br> | id   | <strong>select_type</strong>  | table  | partitions   |  <strong>type</strong> | possible_keys | key    | key_len  | ref    | rows     | filtered    | <strong>Extra</strong>  |<br>+—-+————-+——-+————+——+—————+——+———+——+——–+———-+——-+</p><h2 id="1、id"><a href="#1、id" class="headerlink" title="1、id"></a>1、id</h2><p>id用来标识整个查询中SELELCT语句的顺序，在嵌套查询中id越大的语句越先执行，该值可能为NULL</p><p>id如果相同，从上往下依次执行。id不同，id值越大，执行优先级越高，如果行引用其他行的并集结果，则该值可以为NU</p><h2 id="2、select-type"><a href="#2、select-type" class="headerlink" title="2、select_type"></a>2、select_type</h2><p><strong>simple</strong></p><p><strong>primary</strong></p><p><strong>union</strong></p><p><strong>dependent union</strong></p><p><strong>subquery</strong></p><p><strong>dependent subquery</strong></p><p><strong>derived</strong></p><h2 id="3、table"><a href="#3、table" class="headerlink" title="3、table"></a>3、table</h2><p>table用来表示输出行所引用的表名</p><h2 id="4、type（重要）"><a href="#4、type（重要）" class="headerlink" title="4、type（重要）"></a>4、type（重要）</h2><p><strong>system</strong></p><p><strong>const</strong></p><p><strong>eq_ref</strong></p><p><strong>ref</strong></p><p><strong>ref_or_null</strong></p><p><strong>index_merge</strong></p><p><strong>range</strong></p><p><strong>index</strong></p><p><strong>all</strong></p><h2 id="6、key（重要）"><a href="#6、key（重要）" class="headerlink" title="6、key（重要）"></a>6、key（重要）</h2><p>key列显示的是当前表实际使用的索引，如果没有选择索引，则此列为null，要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX</p><h2 id="7、key-len"><a href="#7、key-len" class="headerlink" title="7、key_len"></a>7、key_len</h2><p>key_len列显示MySQL决定使用的键长度。如果KEY键是NULL，则长度为NULL。<strong>在不损失精确性的情况下，长度越短越好</strong></p><p>key len的长度还和字符集有关,latin1一个字符占用1个字节,gbk一个字符占用2个字节,utf8一个字符占用3个字节。key_len的计算法方法：</p><h2 id="8、ref"><a href="#8、ref" class="headerlink" title="8、ref"></a>8、ref</h2><p>ref列用来显示使用哪个列或常数与key一起从表中选择相应的行。它显示的列的名字（或const），此列多数时候为null</p><h2 id="9、rows"><a href="#9、rows" class="headerlink" title="9、rows"></a>9、rows</h2><p>rows列显示的是mysql解析器认为执行此SQL时必须扫描的行数。此数值为一个预估值，不是具体值，通常比实际值小</p><h2 id="10、filtered"><a href="#10、filtered" class="headerlink" title="10、filtered"></a>10、filtered</h2><p>此参数为<strong>mysql 5.7 新加参数</strong>，指的是返回结果的行数所占需要读到的行（rows的值）的比例 对于使用join时，前一个表的结果集大小直接影响了循环的行数</p><h2 id="11、extra（重要）"><a href="#11、extra（重要）" class="headerlink" title="11、extra（重要）"></a>11、extra（重要）</h2><p><strong>using index</strong></p><p><strong>using where</strong></p><p><strong>using temporary</strong></p><p><strong>using filesort</strong></p><p><strong>using join buffer</strong></p><p><strong>impossible where</strong></p><p><strong>using index condition</strong></p><h1 id="varchar（100）可以存多少中文字符"><a href="#varchar（100）可以存多少中文字符" class="headerlink" title="varchar（100）可以存多少中文字符"></a>varchar（100）可以存多少中文字符</h1><p>4.0版本以下，varchar(100)，指的是100字节，如果存放UTF8汉字时，只能存33个（每个汉字3字节）</p><p>5.0版本以上，varchar(100)，指的是100字符，无论存放的是数字、字母还是UTF8汉字（每个汉字3字节），都可以存放100个。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;explain解析&quot;&gt;&lt;a href=&quot;#explain解析&quot; class=&quot;headerlink&quot; title=&quot;explain解析&quot;&gt;&lt;/a&gt;explain解析&lt;/h1&gt;&lt;p&gt;+—-+————-+——-+————+——+—————+——+———+——+——–+</summary>
      
    
    
    
    <category term="中间件" scheme="https://blog.yahyav2rayssr.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="MySQL" scheme="https://blog.yahyav2rayssr.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.yahyav2rayssr.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java 设计模式</title>
    <link href="https://blog.yahyav2rayssr.top/posts/fa3d1251/"/>
    <id>https://blog.yahyav2rayssr.top/posts/fa3d1251/</id>
    <published>2023-04-16T11:15:35.690Z</published>
    <updated>2023-04-16T11:15:35.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Initialization-On-Demand-Holder模式"><a href="#Initialization-On-Demand-Holder模式" class="headerlink" title="Initialization On Demand Holder模式"></a>Initialization On Demand Holder模式</h1><blockquote><p>在Java规范中，类的初始化时线程安全的。所以可以采用嵌套类延迟初始化来保证实例访问的安全性。</p></blockquote><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySystem</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Holder</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MySystem</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySystem</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Date</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MySystem</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">getDate</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> date;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MySystem <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Holder.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Iterator模式"><a href="#Iterator模式" class="headerlink" title="Iterator模式"></a>Iterator模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>for循环将循环变量i的作用抽象化，通用化后形成的模式，在设计模式中称为iterator模式。</p><p>Iterator模式用于在数据集合中按照顺序遍历集合。</p><h2 id="示例模式详解"><a href="#示例模式详解" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类和接口一览"><a href="#类和接口一览" class="headerlink" title="类和接口一览"></a>类和接口一览</h3><img src="/posts/fa3d1251/118.png" alt="image-20200722164918583" style="zoom:67%;"><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookShelfIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span> &#123;<br>    <span class="hljs-keyword">private</span> BookShelf bookShelf;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> index;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookShelfIterator</span><span class="hljs-params">(BookShelf bookShelf)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bookShelf = bookShelf;<br>        <span class="hljs-built_in">this</span>.index = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; bookShelf.getLength()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> bookShelf.getBookAt(index);<br>        index++;<br>        <span class="hljs-keyword">return</span> book;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookShelf</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Aggregate</span> &#123;<br>    <span class="hljs-keyword">private</span> Book[] books;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> last;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BookShelf</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.books = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>[maxSize];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Book <span class="hljs-title function_">getBookAt</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> books[index];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendBook</span><span class="hljs-params">(Book book)</span> &#123;<br>        <span class="hljs-built_in">this</span>.books[last] = book;<br>        last++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getLength</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookShelfIterator</span>(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Book</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Book</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BookShelf</span> <span class="hljs-variable">bookShelf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BookShelf</span>(<span class="hljs-number">4</span>);<br>        bookShelf.appendBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;Arround the world in 80 days&quot;</span>));<br>        bookShelf.appendBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;Bible&quot;</span>));<br>        bookShelf.appendBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;Cinderella&quot;</span>));<br>        bookShelf.appendBook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Book</span>(<span class="hljs-string">&quot;Daddy-Long-Legs&quot;</span>));<br><br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> bookShelf.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            <span class="hljs-type">Book</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> (Book) it.next();<br>            System.out.println(book.getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解"><a href="#模式详解" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>Iterator（迭代器）</li><li>ConcreteIterator（具体的迭代器）</li><li>Aggregate（集合）</li><li>ConcreteAggregate（具体的集合）</li></ul><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/119.png" alt="image-20200722171418184" style="zoom:67%;"><blockquote><p>在Iterator模式的实现中，很容易在next方法上出错。该方法的返回值到底是应该指向当前元素还是当前元素的下一个元素呢？更详细的讲，next方法的名字应该是下面这样的。</p><p><code>returnCurrentElementAndAdvancedToNextPosition</code></p><p>也就是说，next方法是“返回当前的元素，并指向下一个元素”。</p></blockquote><h1 id="Adaptor模式"><a href="#Adaptor模式" class="headerlink" title="Adaptor模式"></a>Adaptor模式</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>在程序世界中，经常会存在现有的程序无法直接使用，需要做适当的变换之后才能使用的情况。这种用于填补“现有的程序”和”所需的程序“之间差异的设计模式就是Adaptor模式。</p><p>Adaptor模式有以下两种：</p><ul><li>类适配器模式（使用继承的适配器）</li><li>对象适配器模式（使用委托的适配器）</li></ul><h2 id="类适配器模式详解"><a href="#类适配器模式详解" class="headerlink" title="类适配器模式详解"></a>类适配器模式详解</h2><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/121.png" alt="image-20200722193339092" style="zoom: 67%;"><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Banner</span> &#123;<br>    <span class="hljs-keyword">private</span> String string;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Banner</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">this</span>.string = string;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showWithParen</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;(&quot;</span> + string + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showWithAster</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;*&quot;</span> + string + <span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">PrintBanner</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintBanner</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        p.printWeak();<br>        p.printStrong();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Print</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintBanner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Banner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Print</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintBanner</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">super</span>(string);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span> &#123;<br>        showWithParen();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span> &#123;<br>        showWithAster();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="对象适配器模式详解"><a href="#对象适配器模式详解" class="headerlink" title="对象适配器模式详解"></a>对象适配器模式详解</h2><h3 id="类图-2"><a href="#类图-2" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/122.png" style="zoom: 67%;"><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Banner</span> &#123;<br>    <span class="hljs-keyword">private</span> String string;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Banner</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">this</span>.string = string;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showWithParen</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;(&quot;</span> + string + <span class="hljs-string">&quot;)&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showWithAster</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;*&quot;</span> + string + <span class="hljs-string">&quot;*&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">PrintBanner</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintBanner</span>(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        p.printWeak();<br>        p.printStrong();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Print</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrintBanner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Print</span> &#123;<br>    <span class="hljs-keyword">private</span> Banner banner;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PrintBanner</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">this</span>.banner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Banner</span>(string);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printWeak</span><span class="hljs-params">()</span> &#123;<br>        banner.showWithParen();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printStrong</span><span class="hljs-params">()</span> &#123;<br>        banner.showWithAster();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-1"><a href="#模式详解-1" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a>角色</h3><ul><li>Target（对象）</li><li>Client（请求者）</li><li>Adaptee（被适配）</li><li>Adapter（适配）</li></ul><h3 id="类图-3"><a href="#类图-3" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/123.png" style="zoom:67%;"><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>可以使用Adapter模式使新旧版本兼容，帮助我们轻松地同时维护新版本和旧版本。</p><p>例如，假设我们今后只想维护新版本。这时可以让新版本扮演Adaptee角色，旧版本扮演Target角色。接着编写一个扮演Adapter角色的类，让它使用新版本的类来实现旧版本的类中的方法。</p><h1 id="Template-Method模式"><a href="#Template-Method模式" class="headerlink" title="Template Method模式"></a>Template Method模式</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>在父类中定义处理流程的框架，在子类中实现具体处理的模式就称为Template Method模式。</p><h2 id="示例模式详解-1"><a href="#示例模式详解-1" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类和接口一览-1"><a href="#类和接口一览-1" class="headerlink" title="类和接口一览"></a>类和接口一览</h3><img src="/posts/fa3d1251/124.png" alt="image-20200722235251675" style="zoom:67%;"><h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDisplay</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        open();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            print();<br>        &#125;<br>        close();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CharDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDisplay</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> ch;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CharDisplay</span><span class="hljs-params">(<span class="hljs-type">char</span> ch)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ch = ch;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;&lt;&lt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(ch);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;&gt;&gt;&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDisplay</span> &#123;<br>    <span class="hljs-keyword">private</span> String string;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> width;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StringDisplay</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">this</span>.string = string;<br>        <span class="hljs-built_in">this</span>.width = string.getBytes().length;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        printLine();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;|&quot;</span> + string + <span class="hljs-string">&quot;|&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        printLine();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLine</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;+&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;-&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;+&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">AbstractDisplay</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CharDisplay</span>(<span class="hljs-string">&#x27;H&#x27;</span>);<br>        <span class="hljs-type">StringDisplay</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplay</span>(<span class="hljs-string">&quot;Hello, world&quot;</span>);<br>        <span class="hljs-type">StringDisplay</span> <span class="hljs-variable">d3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplay</span>(<span class="hljs-string">&quot;你好，世界&quot;</span>);<br><br>        d1.display();<br>        d2.display();<br>        d3.display();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-2"><a href="#模式详解-2" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a>角色</h3><ul><li>AbstractClass（抽象类）</li><li>ConcreteClass（具体类）</li></ul><h3 id="类图-4"><a href="#类图-4" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/125.png" alt="image-20200723001240425" style="zoom:67%;"><h2 id="用途-1"><a href="#用途-1" class="headerlink" title="用途"></a>用途</h2><p>可以使逻辑处理通用化。</p><p>无论在父类类型的变量中保存哪个子类的实例，程度都可以正常工作，这种原则称为里氏替换原则（LSP）。</p><p>子类具有实现在父类中所声明的抽象方法的责任。因此，这种责任被称为”子类责任“。</p><h1 id="Factory-Method模式"><a href="#Factory-Method模式" class="headerlink" title="Factory Method模式"></a>Factory Method模式</h1><h2 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h2><p>Factory有”工厂“的意思。用Template Mehod模式来构建生成实例的工厂，这就是Factory Method模式。</p><p>在Factory Method模式中，父类决定实例的生成方式，但并不决定所要生成的具体的类。</p><h2 id="示例模式详解-2"><a href="#示例模式详解-2" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类和接口一览-2"><a href="#类和接口一览-2" class="headerlink" title="类和接口一览"></a>类和接口一览</h3><img src="/posts/fa3d1251/126.png" alt="image-20200723002406653" style="zoom:67%;"><img src="/posts/fa3d1251/127.png" alt="image-20200723002438733" style="zoom:67%;"><h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Product <span class="hljs-title function_">create</span><span class="hljs-params">(String owner)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> createProduct(owner);<br>        registerProduct(p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String owner)</span>;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerProduct</span><span class="hljs-params">(Product product)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> String owner;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IDCard</span><span class="hljs-params">(String owner)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;制作&quot;</span> + owner + <span class="hljs-string">&quot;的ID卡&quot;</span>);<br>        <span class="hljs-built_in">this</span>.owner = owner;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;使用&quot;</span> + owner + <span class="hljs-string">&quot;的ID卡&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOwner</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> owner;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IDCardFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">List</span> <span class="hljs-variable">owners</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Product <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String owner)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IDCard</span>(owner);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerProduct</span><span class="hljs-params">(Product product)</span> &#123;<br>        owners.add(((IDCard)product).getOwner());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List <span class="hljs-title function_">getOwners</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> owners;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IDCardFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IDCardFactory</span>();<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">card1</span> <span class="hljs-operator">=</span> factory.create(<span class="hljs-string">&quot;小明&quot;</span>);<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">card2</span> <span class="hljs-operator">=</span> factory.create(<span class="hljs-string">&quot;小红&quot;</span>);<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">card3</span> <span class="hljs-operator">=</span> factory.create(<span class="hljs-string">&quot;小刚&quot;</span>);<br>        card1.use();<br>        card2.use();<br>        card3.use();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-3"><a href="#模式详解-3" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-3"><a href="#角色-3" class="headerlink" title="角色"></a>角色</h3><ul><li>Product（产品）</li><li>Creator（创建者）</li><li>ConcreteProduct（具体的产品）</li><li>ConcreteCreator（具体的创建者）</li></ul><h3 id="类图-5"><a href="#类图-5" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/128.png" style="zoom:67%;"><h1 id="Singleton模式"><a href="#Singleton模式" class="headerlink" title="Singleton模式"></a>Singleton模式</h1><h2 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h2><p>确保只生成一个实例的模式被称作Singleton模式。</p><ul><li>想确保任何情况下都绝对只有1个实例</li><li>想在程序上表现出”只存在一个实例“</li></ul><h2 id="示例模式详解-3"><a href="#示例模式详解-3" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="角色-4"><a href="#角色-4" class="headerlink" title="角色"></a>角色</h3><img src="/posts/fa3d1251/129.png" alt="image-20200723005333978" style="zoom:67%;"><h3 id="类图-6"><a href="#类图-6" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/130.png" style="zoom:67%;"><h3 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;生成了一个实例&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> singleton;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Start.&quot;</span>);<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-keyword">if</span> (obj1 == obj2) &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj1 和 obj2 是相同的实例&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;obj1 和 obj2 是不同的实例&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;End.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-4"><a href="#模式详解-4" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-5"><a href="#角色-5" class="headerlink" title="角色"></a>角色</h3><ul><li><p>Singleton</p><p>在Singleton模式总，只有Singleton这一个角色。Singleton角色中有一个返回唯一实例的static方法。该方法总是会返回同一个实例。</p></li></ul><h3 id="类图-7"><a href="#类图-7" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/131.png" style="zoom:67%;"><blockquote><p>何时生成这个唯一的实例？</p><p>程序运行后，在第一次调用getIntance方法时，Singleton类会被初始化，也就是在这个时候，static字段singleton被初始化，生成了唯一的一个实例。</p></blockquote><h1 id="Prototype模式"><a href="#Prototype模式" class="headerlink" title="Prototype模式"></a>Prototype模式</h1><h2 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h2><p>通过复制生成实例。</p><h2 id="示例模式详解-4"><a href="#示例模式详解-4" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类和接口一览-3"><a href="#类和接口一览-3" class="headerlink" title="类和接口一览"></a>类和接口一览</h3><img src="/posts/fa3d1251/132.png" style="zoom:67%;"><h3 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">HashMap</span> <span class="hljs-variable">showCase</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String name, Product proto)</span> &#123;<br>        showCase.put(name, proto);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">create</span><span class="hljs-params">(String protoName)</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> (Product) showCase.get(protoName);<br>        <span class="hljs-keyword">return</span> p.createClone();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageBox</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> decoChar;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MessageBox</span><span class="hljs-params">(<span class="hljs-type">char</span> decoChar)</span> &#123;<br>        <span class="hljs-built_in">this</span>.decoChar = decoChar;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.getBytes().length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length + <span class="hljs-number">4</span>; i++) &#123;<br>            System.out.print(decoChar);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(decoChar + <span class="hljs-string">&quot; &quot;</span> + s + <span class="hljs-string">&quot; &quot;</span> + decoChar);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length + <span class="hljs-number">4</span>; i++) &#123;<br>            System.out.print(decoChar);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">createClone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            p = (Product) clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Product</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Cloneable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">(String s)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Product <span class="hljs-title function_">createClone</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnderlinePen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Product</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> ulchar;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnderlinePen</span><span class="hljs-params">(<span class="hljs-type">char</span> ulchar)</span> &#123;<br>        <span class="hljs-built_in">this</span>.ulchar = ulchar;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> s.getBytes().length;<br>        System.out.println(<span class="hljs-string">&quot;\&quot;&quot;</span> + s + <span class="hljs-string">&quot;\&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            System.out.print(ulchar);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Product <span class="hljs-title function_">createClone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            p = (Product) clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 准备</span><br>        <span class="hljs-type">Manager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Manager</span>();<br>        <span class="hljs-type">UnderlinePen</span> <span class="hljs-variable">upen</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnderlinePen</span>(<span class="hljs-string">&#x27;~&#x27;</span>);<br>        <span class="hljs-type">MessageBox</span> <span class="hljs-variable">mbox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageBox</span>(<span class="hljs-string">&#x27;*&#x27;</span>);<br>        <span class="hljs-type">MessageBox</span> <span class="hljs-variable">sbox</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageBox</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>        manager.register(<span class="hljs-string">&quot;strong message&quot;</span>, upen);<br>        manager.register(<span class="hljs-string">&quot;warning box&quot;</span>, mbox);<br>        manager.register(<span class="hljs-string">&quot;slash box&quot;</span>, sbox);<br><br>        <span class="hljs-comment">// 生成</span><br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> manager.create(<span class="hljs-string">&quot;strong message&quot;</span>);<br>        p1.use(<span class="hljs-string">&quot;Hello, world&quot;</span>);<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> manager.create(<span class="hljs-string">&quot;warning box&quot;</span>);<br>        p2.use(<span class="hljs-string">&quot;Hello, world&quot;</span>);<br>        <span class="hljs-type">Product</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> manager.create(<span class="hljs-string">&quot;slash box&quot;</span>);<br>        p3.use(<span class="hljs-string">&quot;Hello, world&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-5"><a href="#模式详解-5" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-6"><a href="#角色-6" class="headerlink" title="角色"></a>角色</h3><ul><li><p>Prototype（原型）<br>Product角色负责定义用于复制现有实例来生成新实例的方法。</p></li><li><p>ConcretePrototype（具体的原型）</p><p>ConcretePrototype角色负责实现复制现有实例并生成新实例的方法。</p></li><li><p>Client（使用者）<br>Client角色负责使用复制实例的方法生成新的实例。</p></li></ul><h3 id="类图-8"><a href="#类图-8" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/133.png" style="zoom:67%;"><blockquote><h4 id="需要实现Cloneable的哪些方法"><a href="#需要实现Cloneable的哪些方法" class="headerlink" title="需要实现Cloneable的哪些方法"></a>需要实现Cloneable的哪些方法</h4><p>提到Cloneable接口，很容易让人误以为Clonable接口中声明了close方法。其实这是错误的。在Cloneable接口并没有声明任何方法。它只是用来标记”可以使用clone方法进行复制“的。这样的接口被称为<strong>标记接口（marker interface）</strong>。</p><h4 id="clone方法进行的是浅复制"><a href="#clone方法进行的是浅复制" class="headerlink" title="clone方法进行的是浅复制"></a>clone方法进行的是浅复制</h4><p>clone方法所进行的复制只是<strong>将被复制实例的字段值直接复制到新的实例中</strong>。换言之，它并没有考虑字段所保存的实例的内容。例如，当字段中保存的是数组时，如果使用clone方法进行复制，则只会复制该数据的引用，并不会一一复制数据中的元素。</p><p>像这样的字段对字段的复制（field-to-field-copy）被称为浅复制（shallow copy）。clone方法所进行的复制就是浅复制。</p><p>当使用clone方法进行浅复制无法满足需求时，类的设计者可以实现重写clone方法，实现自己需要的复制功能（重写clone方法时，别忘了使用super.clone()来调用父类的clone方法）。</p><p>clone方法只会进行复制，并不会调用被复制实例的构造函数。</p></blockquote><h1 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a>Builder模式</h1><h2 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h2><p>Builder模式用于组装具有复杂结构的实例。</p><h2 id="示例模式详解-5"><a href="#示例模式详解-5" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类和接口一览-4"><a href="#类和接口一览-4" class="headerlink" title="类和接口一览"></a>类和接口一览</h3><img src="/posts/fa3d1251/134.png" style="zoom:67%;"><img src="/posts/fa3d1251/135.png" style="zoom:67%;"><h3 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeTitle</span><span class="hljs-params">(String title)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeString</span><span class="hljs-params">(String str)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeItems</span><span class="hljs-params">(String[] items)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Director</span> &#123;<br>    <span class="hljs-keyword">private</span> Builder builder;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Director</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        <span class="hljs-built_in">this</span>.builder = builder;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">construct</span><span class="hljs-params">()</span> &#123;<br>        builder.makeTitle(<span class="hljs-string">&quot;Greeting&quot;</span>);<br>        builder.makeString(<span class="hljs-string">&quot;从早上至下午&quot;</span>);<br>        builder.makeItems(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;晚上好。&quot;</span>, <span class="hljs-string">&quot;晚安&quot;</span>, <span class="hljs-string">&quot;再见&quot;</span>&#125;);<br>        builder.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HTMLBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-keyword">private</span> String fileName;<br>    <span class="hljs-keyword">private</span> PrintWriter writer;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeTitle</span><span class="hljs-params">(String title)</span> &#123;<br>        fileName = title + <span class="hljs-string">&quot;.html&quot;</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(fileName));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        writer.println(<span class="hljs-string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&quot;</span>);<br>        writer.println(<span class="hljs-string">&quot;&lt;h1&gt;&quot;</span> + title + <span class="hljs-string">&quot;&lt;/h1&gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeString</span><span class="hljs-params">(String str)</span> &#123;<br>        writer.println(<span class="hljs-string">&quot;&lt;p&gt;&quot;</span> + str + <span class="hljs-string">&quot;&lt;/p&gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeItems</span><span class="hljs-params">(String[] items)</span> &#123;<br>        writer.println(<span class="hljs-string">&quot;&lt;ul&gt;&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; items.length; i++) &#123;<br>            writer.println(<span class="hljs-string">&quot;&lt;li&gt;&quot;</span> + items[i] + <span class="hljs-string">&quot;&lt;/li&gt;&quot;</span>);<br>        &#125;<br>        writer.println(<span class="hljs-string">&quot;&lt;/ul&gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        writer.println(<span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>        writer.close();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> fileName;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TextBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Builder</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeTitle</span><span class="hljs-params">(String title)</span> &#123;<br>        buffer.append(<span class="hljs-string">&quot;===================================\n&quot;</span>);<br>        buffer.append(<span class="hljs-string">&quot;[&quot;</span> + title + <span class="hljs-string">&quot;]\n&quot;</span>);<br>        buffer.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeString</span><span class="hljs-params">(String str)</span> &#123;<br>        buffer.append(<span class="hljs-string">&#x27;◆&#x27;</span> + str + <span class="hljs-string">&quot;\n&quot;</span>);<br>        buffer.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">makeItems</span><span class="hljs-params">(String[] items)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; items.length; i++) &#123;<br>            buffer.append(<span class="hljs-string">&quot; .&quot;</span> + items[i] + <span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        buffer.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        buffer.append(<span class="hljs-string">&quot;===================================\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buffer.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br>        <span class="hljs-keyword">try</span> &#123;<br>            usage();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> br.readLine();<br>            <span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">&quot;plain&quot;</span>)) &#123;<br>                <span class="hljs-type">TextBuilder</span> <span class="hljs-variable">textBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TextBuilder</span>();<br>                <span class="hljs-type">Director</span> <span class="hljs-variable">director</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>(textBuilder);<br>                director.construct();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> textBuilder.getResult();<br>                System.out.println(result);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str.equals(<span class="hljs-string">&quot;html&quot;</span>)) &#123;<br>                <span class="hljs-type">HTMLBuilder</span> <span class="hljs-variable">htmlBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HTMLBuilder</span>();<br>                <span class="hljs-type">Director</span> <span class="hljs-variable">director</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Director</span>(htmlBuilder);<br>                director.construct();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> htmlBuilder.getResult();<br>                System.out.println(fileName + <span class="hljs-string">&quot; 文件编写完成&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.exit(<span class="hljs-number">0</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                br.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">usage</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Usage: java Main plain      编写纯文本文档&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Usage: java Main html       编写HTML文档&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-6"><a href="#模式详解-6" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-7"><a href="#角色-7" class="headerlink" title="角色"></a>角色</h3><ul><li>Builder（建造者）</li><li>ConcreteBuilder（具体的建造者）</li><li>Director（监工）</li><li>Client（使用者）</li></ul><h3 id="类图-9"><a href="#类图-9" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/136.png" style="zoom:67%;"><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><img src="/posts/fa3d1251/137.png" style="zoom:67%;"><h1 id="Abstract-Factory模式"><a href="#Abstract-Factory模式" class="headerlink" title="Abstract Factory模式"></a>Abstract Factory模式</h1><h2 id="示例模式详解-6"><a href="#示例模式详解-6" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类和接口一览-5"><a href="#类和接口一览-5" class="headerlink" title="类和接口一览"></a>类和接口一览</h3><img src="/posts/fa3d1251/138.png" style="zoom:67%;"><img src="/posts/fa3d1251/139.png" style="zoom:67%;"><h2 id="模式详解-7"><a href="#模式详解-7" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-8"><a href="#角色-8" class="headerlink" title="角色"></a>角色</h3><ul><li>AbstractProduct（抽象产品）</li><li>AbstractFactory（抽象工厂）</li><li>Client（委托者）</li><li>ConcreteProduct（具体产品）</li><li>ConcreteFactory（具体工厂）</li></ul><h3 id="类图-10"><a href="#类图-10" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/140.png" style="zoom:67%;"><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>易于增加的工厂</li><li>难以增加的零件</li></ul><h1 id="Bridge模式"><a href="#Bridge模式" class="headerlink" title="Bridge模式"></a>Bridge模式</h1><h2 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h2><p>Bridge的意思是”桥梁“。就像在现实世界中，桥梁的功能是将河流的两侧连接起来一样，Brige模式的作用也是讲两样东西连接起来，它们分别是<strong>类的功能层次结构</strong>和<strong>类的实现层次结构</strong>。</p><h2 id="类的层次结构的两个作用"><a href="#类的层次结构的两个作用" class="headerlink" title="类的层次结构的两个作用"></a>类的层次结构的两个作用</h2><h3 id="希望增加新功能时"><a href="#希望增加新功能时" class="headerlink" title="希望增加新功能时"></a>希望增加新功能时</h3><img src="/posts/fa3d1251/141.png" style="zoom: 67%;"><p>当要增加新的功能时，我们可以从各个层次的类中找出最适合自己需求的类，然后以它为父类编写子类，并在子类中增加新的功能。这就是”类的功能层次结构“。</p><h3 id="希望增加新的实现时"><a href="#希望增加新的实现时" class="headerlink" title="希望增加新的实现时"></a>希望增加新的实现时</h3><img src="/posts/fa3d1251/142.png" style="zoom:67%;"><p>当子类的ConcreteClass实现了父类AbstractClass类的抽象方法时，它们之间就构成了一个小小的层次结构。</p><p>但是，这里的类的层次结构并非用于增加功能，也就是说，这种层次结构并非用于方便我们增加新的方法。它的真正作用是帮助我们实现下面这样的任务分组。</p><ul><li>父类通过声明抽象方法来定义接口（API）</li><li>子类通过实现具体方法来实现接口（API）</li></ul><p>这种层次结构被称为”类的实现层次结构“。</p><h2 id="示例模式详解-7"><a href="#示例模式详解-7" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类和接口一览-6"><a href="#类和接口一览-6" class="headerlink" title="类和接口一览"></a>类和接口一览</h3><img src="/posts/fa3d1251/143.png" style="zoom:67%;"><h3 id="示例代码-8"><a href="#示例代码-8" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDisplay</span><span class="hljs-params">(DisplayImpl impl)</span> &#123;<br>        <span class="hljs-built_in">super</span>(impl);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multiDisplay</span><span class="hljs-params">(<span class="hljs-type">int</span> times)</span> &#123;<br>        open();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; times; i++) &#123;<br>            print();<br>        &#125;<br>        close();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">private</span> DisplayImpl impl;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Display</span><span class="hljs-params">(DisplayImpl impl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.impl = impl;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        impl.rawOpen();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        impl.rawPrint();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        impl.rawClose();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        open();<br>        print();<br>        close();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">private</span> DisplayImpl impl;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Display</span><span class="hljs-params">(DisplayImpl impl)</span> &#123;<br>        <span class="hljs-built_in">this</span>.impl = impl;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        impl.rawOpen();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span> &#123;<br>        impl.rawPrint();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        impl.rawClose();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">()</span> &#123;<br>        open();<br>        print();<br>        close();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDisplayImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DisplayImpl</span> &#123;<br>    <span class="hljs-keyword">private</span> String string;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> width;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StringDisplayImpl</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">this</span>.string = string;<br>        <span class="hljs-built_in">this</span>.width = string.getBytes().length;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rawOpen</span><span class="hljs-params">()</span> &#123;<br>        printLine();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rawPrint</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;|&quot;</span> + string + <span class="hljs-string">&quot;|&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rawClose</span><span class="hljs-params">()</span> &#123;<br>        printLine();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLine</span><span class="hljs-params">()</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;+&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; width; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;-&quot;</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;+&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Display</span> <span class="hljs-variable">d1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Display</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplayImpl</span>(<span class="hljs-string">&quot;Hello, China&quot;</span>));<br>        <span class="hljs-type">Display</span> <span class="hljs-variable">d2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDisplay</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplayImpl</span>(<span class="hljs-string">&quot;Hello, World&quot;</span>));<br>        <span class="hljs-type">CountDisplay</span> <span class="hljs-variable">d3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDisplay</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplayImpl</span>(<span class="hljs-string">&quot;Hello, Universe&quot;</span>));<br>        d1.display();<br>        d2.display();<br>        d3.display();<br>        d3.multiDisplay(<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-8"><a href="#模式详解-8" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-9"><a href="#角色-9" class="headerlink" title="角色"></a>角色</h3><ul><li>Abstraction（抽象化）</li><li>RefinedAbstraction（改善后的抽象化）</li><li>Implementor（实现者）</li><li>ConcreteImplementor（具体实现者）</li></ul><h3 id="类图-11"><a href="#类图-11" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/144.png" style="zoom:67%;"><h2 id="用途-2"><a href="#用途-2" class="headerlink" title="用途"></a>用途</h2><ul><li><p>分开后更容易扩展</p><p>Bridge模式的特征是将”类的功能层次结构“与”类的实现层次结构“分离开了。</p><p>当想要增加功能时，只需要在”类的功能层次结构“一侧增加类即可，不必对”类的实现层次结构“做任何修改。而且，<strong>增加后的功能可以被”所有的实现使用“</strong>。</p></li><li><p>继承是强关联，委托是弱关联</p></li></ul><h1 id="Strategy模式"><a href="#Strategy模式" class="headerlink" title="Strategy模式"></a>Strategy模式</h1><h2 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h2><p>使用Strategy模式可以整体地替换算法的实现部分。能够整体的替换算法，能让我们轻松地以不同的算法去解决同一个问题，这种模式就是Strategy模式。</p><h2 id="示例模式详解-8"><a href="#示例模式详解-8" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类和接口一览-7"><a href="#类和接口一览-7" class="headerlink" title="类和接口一览"></a>类和接口一览</h3><img src="/posts/fa3d1251/145.png" style="zoom:67%;"><h3 id="示例代码-9"><a href="#示例代码-9" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Hand</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HANDVALUE_GUU</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// 表示石头的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HANDVALUE_CHO</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;  <span class="hljs-comment">// 表示剪刀的值</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">HANDVALUE_PAA</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;  <span class="hljs-comment">// 表示布的值</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Hand[] hand = &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hand</span>(HANDVALUE_GUU),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hand</span>(HANDVALUE_CHO),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hand</span>(HANDVALUE_PAA)<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] name = &#123;<br>            <span class="hljs-string">&quot;石头&quot;</span>, <span class="hljs-string">&quot;剪刀&quot;</span>, <span class="hljs-string">&quot;布&quot;</span>,<br>    &#125;;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> handValue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hand</span><span class="hljs-params">(<span class="hljs-type">int</span> handValue)</span> &#123;<br>        <span class="hljs-built_in">this</span>.handValue = handValue;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Hand <span class="hljs-title function_">getHand</span><span class="hljs-params">(<span class="hljs-type">int</span> handValue)</span> &#123;<br>        <span class="hljs-keyword">return</span> hand[handValue];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isStrongerThan</span><span class="hljs-params">(Hand h)</span> &#123;<br>        <span class="hljs-keyword">return</span> fight(h) == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isWeakerThan</span><span class="hljs-params">(Hand h)</span> &#123;<br>        <span class="hljs-keyword">return</span> fight(h) == -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fight</span><span class="hljs-params">(Hand h)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == h) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.handValue + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span> == h.handValue) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name[handValue];<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(System.in));<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">seed1</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine());<br>            <span class="hljs-type">int</span> <span class="hljs-variable">seed2</span> <span class="hljs-operator">=</span> Integer.parseInt(br.readLine());<br>            <span class="hljs-type">Player</span> <span class="hljs-variable">player1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&quot;Taro&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">WinningStragery</span>(seed1));<br>            <span class="hljs-type">Player</span> <span class="hljs-variable">player2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&quot;Hana&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProbStrategy</span>(seed2));<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>                <span class="hljs-type">Hand</span> <span class="hljs-variable">nextHand1</span> <span class="hljs-operator">=</span> player1.nextHand();<br>                <span class="hljs-type">Hand</span> <span class="hljs-variable">nextHand2</span> <span class="hljs-operator">=</span> player2.nextHand();<br>                <span class="hljs-keyword">if</span> (nextHand1.isStrongerThan(nextHand2)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Winner: &quot;</span> + player1);<br>                    player1.win();<br>                    player2.lose();<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nextHand2.isStrongerThan(nextHand1)) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Winner: &quot;</span> + player2);<br>                    player1.lose();<br>                    player2.win();<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Even...&quot;</span>);<br>                    player1.even();<br>                    player2.even();<br>                &#125;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;Total result:&quot;</span>);<br>            System.out.println(player1.toString());<br>            System.out.println(player2.toString());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Strategy strategy;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> winCount;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> lostCount;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> gameCount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Player</span><span class="hljs-params">(String name, Strategy strategy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.strategy = strategy;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Hand <span class="hljs-title function_">nextHand</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> strategy.nextHand();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">win</span><span class="hljs-params">()</span> &#123;<br>        strategy.study(<span class="hljs-literal">true</span>);<br>        winCount++;<br>        gameCount++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lose</span><span class="hljs-params">()</span> &#123;<br>        strategy.study(<span class="hljs-literal">false</span>);<br>        lostCount++;<br>        gameCount++;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">even</span><span class="hljs-params">()</span> &#123;<br>        gameCount++;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Player&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, winCount=&quot;</span> + winCount +<br>                <span class="hljs-string">&quot;, lostCount=&quot;</span> + lostCount +<br>                <span class="hljs-string">&quot;, gameCount=&quot;</span> + gameCount +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProbStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-keyword">private</span> Random random;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">prevHandValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">currentHandValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[][] history = &#123;<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,<br>            &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProbStrategy</span><span class="hljs-params">(<span class="hljs-type">int</span> seed)</span> &#123;<br>        random = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(seed);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Hand <span class="hljs-title function_">nextHand</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bet</span> <span class="hljs-operator">=</span> random.nextInt(getSum(currentHandValue));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">handValue</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//    如果石头，剪刀，布的比率为3:5:7</span><br>        <span class="hljs-comment">//    如果该随机数 0 &lt;= X &lt; 3，那么出石头</span><br>        <span class="hljs-comment">//    如果该随机数 3 &lt;= X &lt; 8，那么出剪刀</span><br>        <span class="hljs-comment">//    如果该随机数 8 &lt;= X &lt; 15，那么出布</span><br>        <span class="hljs-keyword">if</span> (bet &lt; history[currentHandValue][<span class="hljs-number">0</span>]) &#123;<br>            handValue = <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bet &lt; history[currentHandValue][<span class="hljs-number">0</span>] + history[currentHandValue][<span class="hljs-number">1</span>]) &#123;<br>            handValue = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            handValue = <span class="hljs-number">2</span>;<br>        &#125;<br>        prevHandValue = currentHandValue;<br>        currentHandValue = handValue;<br>        <span class="hljs-keyword">return</span> Hand.getHand(handValue);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> hv)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            sum += history[hv][i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">(<span class="hljs-type">boolean</span> win)</span> &#123;<br>        <span class="hljs-keyword">if</span> (win) &#123;<br>            history[prevHandValue][currentHandValue]++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            history[prevHandValue][(currentHandValue + <span class="hljs-number">1</span>) % <span class="hljs-number">3</span>]++;<br>            history[prevHandValue][(currentHandValue + <span class="hljs-number">2</span>) % <span class="hljs-number">3</span>]++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Hand <span class="hljs-title function_">nextHand</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">(<span class="hljs-type">boolean</span> win)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WinningStragery</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Strategy</span> &#123;<br>    <span class="hljs-keyword">private</span> Random random;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">won</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">private</span> Hand preHand;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WinningStragery</span><span class="hljs-params">(<span class="hljs-type">int</span> seed)</span> &#123;<br>        random = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(seed);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Hand <span class="hljs-title function_">nextHand</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!won) &#123;<br>            preHand = Hand.getHand(random.nextInt(<span class="hljs-number">3</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> preHand;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">study</span><span class="hljs-params">(<span class="hljs-type">boolean</span> win)</span> &#123;<br>        won = win;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-9"><a href="#模式详解-9" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-10"><a href="#角色-10" class="headerlink" title="角色"></a>角色</h3><ul><li>Strategy（策略）</li><li>ConcreteStrategy（具体的策略）</li><li>Context（上下文）<br>负责使用Strategy角色。</li></ul><h3 id="类图-12"><a href="#类图-12" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/146.png" style="zoom:67%;"><h1 id="Composite模式"><a href="#Composite模式" class="headerlink" title="Composite模式"></a>Composite模式</h1><h2 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h2><p>能够使容器与内容具有一致性，创造出递归结构的模式就是Composite模式。</p><h2 id="示例模式详解-9"><a href="#示例模式详解-9" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类和接口一览-8"><a href="#类和接口一览-8" class="headerlink" title="类和接口一览"></a>类和接口一览</h3><img src="/posts/fa3d1251/147.png" style="zoom:67%;"><img src="/posts/fa3d1251/148.png" style="zoom:67%;"><h3 id="示例代码-10"><a href="#示例代码-10" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">directory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Directory</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> directory.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Entry) it.next();<br>            size += entry.getSize();<br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Entry <span class="hljs-title function_">add</span><span class="hljs-params">(Entry entry)</span> &#123;<br>        directory.add(entry);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(String prefix)</span> &#123;<br>        System.out.println(prefix + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">this</span>);<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> directory.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Entry) it.next();<br>            entry.printList(prefix + <span class="hljs-string">&quot;/&quot;</span> + name);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> Entry <span class="hljs-title function_">add</span><span class="hljs-params">(Entry entry)</span> <span class="hljs-keyword">throws</span> FileTreatmentException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileTreatmentException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">()</span> &#123;<br>        printList(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(String prefix)</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getName() + <span class="hljs-string">&quot; (&quot;</span> + getSize() + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printList</span><span class="hljs-params">(String prefix)</span> &#123;<br>        System.out.println(prefix + <span class="hljs-string">&quot;/&quot;</span> + <span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileTreatmentException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileTreatmentException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileTreatmentException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Making root entries ...&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">rootDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;root&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">binDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;bin&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">tmpDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;tmp&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">usrDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;usr&quot;</span>);<br>        rootDir.add(binDir);<br>        rootDir.add(tmpDir);<br>        rootDir.add(usrDir);<br>        binDir.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;vi&quot;</span>, <span class="hljs-number">10000</span>));<br>        binDir.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;latex&quot;</span>, <span class="hljs-number">20000</span>));<br>        rootDir.printList();<br><br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Making user entries&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">yuki</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;yuki&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">hanako</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;hanako&quot;</span>);<br>        <span class="hljs-type">Directory</span> <span class="hljs-variable">tomura</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;tomura&quot;</span>);<br>        usrDir.add(yuki);<br>        usrDir.add(hanako);<br>        usrDir.add(tomura);<br>        yuki.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;diary.html&quot;</span>, <span class="hljs-number">100</span>));<br>        yuki.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Composite.java&quot;</span>, <span class="hljs-number">200</span>));<br>        hanako.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;memo.tex&quot;</span>, <span class="hljs-number">300</span>));<br>        tomura.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;game.doc&quot;</span>, <span class="hljs-number">400</span>));<br>        tomura.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;junk.mail&quot;</span>, <span class="hljs-number">500</span>));<br>        rootDir.printList();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-10"><a href="#模式详解-10" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-11"><a href="#角色-11" class="headerlink" title="角色"></a>角色</h3><ul><li><p>Leaf（树叶）<br>表示内容的角色。</p></li><li><p>Composite（复合物）<br>表示容器的角色。</p></li><li><p>Component</p><p>使Leaf角色和Composite角色具有一致性的角色。</p></li><li><p>Client<br>使用Composite模式的角色。</p></li></ul><h3 id="类图-13"><a href="#类图-13" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/149.png" style="zoom:67%;"><h2 id="用途-3"><a href="#用途-3" class="headerlink" title="用途"></a>用途</h2><p>使用Composite模式可以使容器与内容具有一致性，也可以称为多个和单个的一致性。</p><h1 id="Decorator模式"><a href="#Decorator模式" class="headerlink" title="Decorator模式"></a>Decorator模式</h1><h2 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h2><p>像蛋糕一样不断为对象添加装饰的设计模式被称为<strong>Decorator模式</strong>。</p><h2 id="示例模式详解-10"><a href="#示例模式详解-10" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类图-14"><a href="#类图-14" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/150.png" style="zoom:67%;"><h3 id="示例代码-11"><a href="#示例代码-11" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Border</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">protected</span> Display display;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">Border</span><span class="hljs-params">(Display display)</span> &#123;<br>        <span class="hljs-built_in">this</span>.display = display;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getColumns</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRows</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getRowText</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; getRows(); i++) &#123;<br>            System.out.println(getRowText(i));<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FullBorder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Border</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FullBorder</span><span class="hljs-params">(Display display)</span> &#123;<br>        <span class="hljs-built_in">super</span>(display);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getColumns</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + display.getColumns() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRows</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + display.getRows() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRowText</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;+&quot;</span> + makeLine(<span class="hljs-string">&#x27;-&#x27;</span>, display.getColumns()) + <span class="hljs-string">&quot;+&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (row == display.getRows() + <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;+&quot;</span> + makeLine(<span class="hljs-string">&#x27;-&#x27;</span>, display.getColumns()) + <span class="hljs-string">&quot;+&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;|&quot;</span> + display.getRowText(row - <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;|&quot;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">makeLine</span><span class="hljs-params">(<span class="hljs-type">char</span> ch, <span class="hljs-type">int</span> count)</span> &#123;<br>        <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            buf.append(ch);<br>        &#125;<br>        <span class="hljs-keyword">return</span> buf.toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Display</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplay</span>(<span class="hljs-string">&quot;Hello, world&quot;</span>);<br>        <span class="hljs-type">Display</span> <span class="hljs-variable">b2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SideBorder</span>(b1, <span class="hljs-string">&#x27;#&#x27;</span>);<br>        <span class="hljs-type">Display</span> <span class="hljs-variable">b3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FullBorder</span>(b2);<br>        b1.show();<br>        b2.show();<br>        b3.show();<br><br>        <span class="hljs-type">Display</span> <span class="hljs-variable">d4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SideBorder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FullBorder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SideBorder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FullBorder</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringDisplay</span>(<span class="hljs-string">&quot;你好，世界。&quot;</span>)), <span class="hljs-string">&#x27;*&#x27;</span>)), <span class="hljs-string">&#x27;/&#x27;</span>);<br>        d4.show();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SideBorder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Border</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> borderChar;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SideBorder</span><span class="hljs-params">(Display display, <span class="hljs-type">char</span> borderChar)</span> &#123;<br>        <span class="hljs-built_in">super</span>(display);<br>        <span class="hljs-built_in">this</span>.borderChar = borderChar;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getColumns</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + display.getColumns() + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRows</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> display.getRows();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRowText</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-keyword">return</span> borderChar + display.getRowText(row) + borderChar;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringDisplay</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Display</span> &#123;<br>    <span class="hljs-keyword">private</span> String string;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StringDisplay</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-built_in">this</span>.string = string;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getColumns</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> string.getBytes().length;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRows</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRowText</span><span class="hljs-params">(<span class="hljs-type">int</span> row)</span> &#123;<br>        <span class="hljs-keyword">if</span> (row == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> string;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-11"><a href="#模式详解-11" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-12"><a href="#角色-12" class="headerlink" title="角色"></a>角色</h3><ul><li>Component<br>增加功能时的核心角色。</li><li>ConcreteComponent</li><li>Decorator（装饰物）</li><li>ConcreteDecorator（具体的装饰物）</li></ul><h3 id="类图-15"><a href="#类图-15" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/151-1595520359472.png" style="zoom:67%;"><h2 id="用途-4"><a href="#用途-4" class="headerlink" title="用途"></a>用途</h2><p>在不改变被装饰物的前提下增加功能。</p><blockquote><h4 id="继承和委托的一致性"><a href="#继承和委托的一致性" class="headerlink" title="继承和委托的一致性"></a>继承和委托的一致性</h4><p>继承——父类和子类的一致性</p><p>委托——自己和被委托对象的一致性</p></blockquote><h1 id="Visitor模式"><a href="#Visitor模式" class="headerlink" title="Visitor模式"></a>Visitor模式</h1><h2 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h2><p>在Visitor模式中，<strong>数据结构与处理被分离开来</strong>。我们编写一个表示“访问者”的类来访问数据结构中的元素，并把对各元素的处理交给访问者类。这样，当需要增加新的处理时，我们只需要编写新的访问者，然后让数据可以接受访问者的访问即可。</p><h2 id="示例模式详解-11"><a href="#示例模式详解-11" class="headerlink" title="示例模式详解"></a>示例模式详解</h2><h3 id="类和接口一览-9"><a href="#类和接口一览-9" class="headerlink" title="类和接口一览"></a>类和接口一览</h3><img src="/posts/fa3d1251/152.png" style="zoom:67%;"><img src="/posts/fa3d1251/153.png" style="zoom:67%;"><h3 id="示例代码-12"><a href="#示例代码-12" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> Entry <span class="hljs-title function_">add</span><span class="hljs-params">(Entry entry)</span> <span class="hljs-keyword">throws</span> FileTreatmentException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileTreatmentException</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileTreatmentException &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileTreatmentException</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getName() + <span class="hljs-string">&quot; (&quot;</span> + getSize() + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Element</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor v)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Directory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ArrayList</span> <span class="hljs-variable">dir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Directory</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> dir.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Entry) it.next();<br>            size += entry.getSize();<br>        &#125;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Entry <span class="hljs-title function_">add</span><span class="hljs-params">(Entry entry)</span> <span class="hljs-keyword">throws</span> FileTreatmentException &#123;<br>        dir.add(entry);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Iterator <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileTreatmentException &#123;<br>        <span class="hljs-keyword">return</span> dir.iterator();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor v)</span> &#123;<br>        v.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">File</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Entry</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">File</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.size = size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getSize</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">accept</span><span class="hljs-params">(Visitor v)</span> &#123;<br>        v.visit(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileTreatmentException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileTreatmentException</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FileTreatmentException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListVisitor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">currentDir</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(File file)</span> &#123;<br>        System.out.println(currentDir + <span class="hljs-string">&quot;/&quot;</span> + file);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Directory directory)</span> &#123;<br>        System.out.println(currentDir + <span class="hljs-string">&quot;/&quot;</span> + directory);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">saveDir</span> <span class="hljs-operator">=</span> currentDir;<br>        currentDir = currentDir + <span class="hljs-string">&quot;/&quot;</span> + directory.getName();<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">it</span> <span class="hljs-operator">=</span> directory.iterator();<br>        <span class="hljs-keyword">while</span> (it.hasNext()) &#123;<br>            <span class="hljs-type">Entry</span> <span class="hljs-variable">entry</span> <span class="hljs-operator">=</span> (Entry) it.next();<br>            entry.accept(<span class="hljs-built_in">this</span>);<br>        &#125;<br>        currentDir = saveDir;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Visitor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(File file)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">visit</span><span class="hljs-params">(Directory directory)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Making root entries...&quot;</span>);<br>            <span class="hljs-type">Directory</span> <span class="hljs-variable">rootDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;root&quot;</span>);<br>            <span class="hljs-type">Directory</span> <span class="hljs-variable">binDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;bin&quot;</span>);<br>            <span class="hljs-type">Directory</span> <span class="hljs-variable">tmpDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;tmp&quot;</span>);<br>            <span class="hljs-type">Directory</span> <span class="hljs-variable">usrDir</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;usr&quot;</span>);<br>            rootDir.add(binDir);<br>            rootDir.add(tmpDir);<br>            rootDir.add(usrDir);<br>            binDir.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;vi&quot;</span>, <span class="hljs-number">10000</span>));<br>            binDir.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;latex&quot;</span>, <span class="hljs-number">20000</span>));<br>            rootDir.accept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListVisitor</span>());<br><br>            System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;Making user entries&quot;</span>);<br>            <span class="hljs-type">Directory</span> <span class="hljs-variable">yuki</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;yuki&quot;</span>);<br>            <span class="hljs-type">Directory</span> <span class="hljs-variable">hanako</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;hanako&quot;</span>);<br>            <span class="hljs-type">Directory</span> <span class="hljs-variable">tomura</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Directory</span>(<span class="hljs-string">&quot;tomura&quot;</span>);<br>            usrDir.add(yuki);<br>            usrDir.add(hanako);<br>            usrDir.add(tomura);<br>            yuki.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;diary.html&quot;</span>, <span class="hljs-number">100</span>));<br>            yuki.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;Composite.java&quot;</span>, <span class="hljs-number">200</span>));<br>            hanako.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;memo.tex&quot;</span>, <span class="hljs-number">300</span>));<br>            tomura.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;game.doc&quot;</span>, <span class="hljs-number">400</span>));<br>            tomura.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;junk.mail&quot;</span>, <span class="hljs-number">500</span>));<br>            rootDir.accept(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ListVisitor</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (FileTreatmentException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="模式详解-12"><a href="#模式详解-12" class="headerlink" title="模式详解"></a>模式详解</h2><h3 id="角色-13"><a href="#角色-13" class="headerlink" title="角色"></a>角色</h3><ul><li>Visitor（访问者）<br>Visitor角色负责对数据结构中每个具体的元素（ConcreteElement角色）声明一个用于访问XXXXX的visit(XXXXX)方法。</li><li>ConcreteVisitor（具体的访问者）</li><li>Element（元素）<br>Element角色表示Visitor角色的访问对象。</li><li>ConcreteElement</li><li>ObjectStruture（对象结构）<br>ObjectStructure角色处理Element角色集合。</li></ul><h3 id="类图-16"><a href="#类图-16" class="headerlink" title="类图"></a>类图</h3><img src="/posts/fa3d1251/154.png" style="zoom:67%;"><h2 id="用途-5"><a href="#用途-5" class="headerlink" title="用途"></a>用途</h2><p><strong>双重分发</strong></p><p>element接受visitor，而visitor又访问element。</p><p>在Visitor模式中，ConcreteElement和ConcreteVisitor这两个角色共同决定了实际进行的处理。这种消息分发的方式一般被称为双重分发（double dispatch）。</p><p>Visitor模式的目的<strong>将处理从数据结构中分离出来</strong>。数据结构很重要，它能将元素集合和关联在一起。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Initialization-On-Demand-Holder模式&quot;&gt;&lt;a href=&quot;#Initialization-On-Demand-Holder模式&quot; class=&quot;headerlink&quot; title=&quot;Initialization On Demand H</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="设计模式" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.yahyav2rayssr.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 时区问题</title>
    <link href="https://blog.yahyav2rayssr.top/posts/3aad583d/"/>
    <id>https://blog.yahyav2rayssr.top/posts/3aad583d/</id>
    <published>2023-04-16T10:28:39.520Z</published>
    <updated>2023-04-16T10:28:39.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="修改时区"><a href="#修改时区" class="headerlink" title="修改时区"></a>修改时区</h2><p>mysql 数据库可以通过下面两个 sql 查看时区:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT TIMEDIFF(NOW(),CONVERT_TZ(NOW(),@@session.time_zone,&#x27;+00:00&#x27;));<br></code></pre></td></tr></table></figure><p>或者:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT TIMEDIFF(NOW(), UTC_TIMESTAMP); <br></code></pre></td></tr></table></figure><p>如果是中国标准时间, 会输出08:00</p><p>以下记录修改 mysql 时区的几种方法。</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>通过 mysql 命令行模式下动态修改。</p><p>查看 mysql 当前时间，当前时区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">select curtime();   <span class="hljs-comment"># 或select now()也可以</span></span><br>+-----------+<br>| curtime() |<br>+-----------+<br>| 15:18:10  |<br>+-----------+<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">show variables like <span class="hljs-string">&quot;%time_zone%&quot;</span>;</span><br>+------------------+--------+<br>| Variable_name    | Value  |<br>+------------------+--------+<br>| system_time_zone | UTC    |<br>| time_zone        | SYSTEM |<br>+------------------+--------+<br>2 rows in set (0.00 sec)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">time_zone说明mysql使用system的时区，system_time_zone说明system使用UTC时区</span><br></code></pre></td></tr></table></figure><p>修改时区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">set global time_zone = &#x27;+8:00&#x27;;  # 修改mysql全局时区为北京时间，即我们所在的东8区<br>set time_zone = &#x27;+8:00&#x27;;  # 修改当前会话时区<br>flush privileges;  # 立即生效<br></code></pre></td></tr></table></figure><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a><del>方法二</del></h3><p>使用6.0以下版本的jdbc，降版本，并不推荐。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>在 jdbc url 指定默认时区，在jdbc连接的url后面加上<code>serverTimezone=UTC</code>或 GMT 即可，如果指定使用 gmt+8 时区，需要写成 GMT%2B8，否则可能报解析为空的错误。示例如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/demo?serverTimezone=UTC&amp;characterEncoding=utf-8</span><br><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/demo?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8</span><br><br><span class="hljs-attr">jdbc.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/demo?serverTimezone=Asia/Shanghai&amp;characterEncoding=utf-8</span><br></code></pre></td></tr></table></figure><h3 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h3><p>通过修改 my.cnf 配置文件来修改时区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">vim /etc/my.cnf  <span class="hljs-comment">##在[mysqld]区域中加上</span></span><br>default-time_zone = &#x27;+8:00&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">/etc/init.d/mysqld restart  <span class="hljs-comment">##重启mysql使新时区生效</span></span><br></code></pre></td></tr></table></figure><h2 id="关闭SSL"><a href="#关闭SSL" class="headerlink" title="关闭SSL"></a>关闭SSL</h2><p>在这里有一个地方需要注意，MySQL 在高版本需要指明是否进行 SSL 连接。</p><p>SSL 协议提供服务主要：</p><ol><li>认证用户服务器，确保数据发送到正确的服务器；</li><li>加密数据，防止数据传输途中被窃取使用；</li><li>维护数据完整性，验证数据在传输过程中是否丢失；</li></ol><p>当前支持 SSL 协议两层：</p><p>SSL 记录协议（SSL Record Protocol）：建立靠传输协议（TCP）高层协议提供数据封装、压缩、加密等基本功能支持</p><p>SSL 握手协议（SSL Handshake Protocol）：建立SSL记录协议用于实际数据传输始前通讯双进行身份认证、协商加密算法、 交换加密密钥等。</p><p>不建议在没有服务器身份验证的情况下建立SSL连接。根据 MySQL 5.5.45+、5.6.26+ 和 5.7.6+ 的要求，如果不设置显式选项，则必须建立默认的SSL连接。需要通过设置<code>useSSL=false</code></p><p>来显式禁用SSL，或者设置useSSL&#x3D;true并为服务器证书验证提供信任存储。</p><p>1.true 需要连接</p><p>2.false 不需要连接</p><p>所以建议设置useSSL为false，有时遇到的问题可以这样来考虑</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">jdbc</span>:<span class="hljs-string">mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false**</span><br></code></pre></td></tr></table></figure><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://juejin.cn/post/7007044908250824741">mysql的timestamp会存在时区问题？</a></p><p><a href="https://heapdump.cn/article/2986372">数据库时间慢了14个小时，Mybatis说，这个锅我不背！</a></p><p><a href="https://blog.csdn.net/qq_22783587/article/details/124844507">java LocalDateTime 和 mysql datetime timestamp时区问题</a></p><p><a href="https://www.51cto.com/article/706215.html">MySQL 总是差八个小时，如何破？</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h2 id=&quot;修改时区&quot;&gt;&lt;a href=&quot;#修改时区&quot; class=&quot;headerlink&quot; title=&quot;修改时区&quot;&gt;&lt;/a&gt;修改时区&lt;/h</summary>
      
    
    
    
    <category term="中间件" scheme="https://blog.yahyav2rayssr.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="MySQL" scheme="https://blog.yahyav2rayssr.top/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://blog.yahyav2rayssr.top/tags/MySQL/"/>
    
    <category term="时区" scheme="https://blog.yahyav2rayssr.top/tags/%E6%97%B6%E5%8C%BA/"/>
    
  </entry>
  
</feed>
