<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>nginx 安装 &amp; FTP美化</title>
    <url>/posts/1b4fede6/</url>
    <content><![CDATA[目录配置 nginx 美化下载 fancyindexgit clone git@github.com:aperezdc/ngx-fancyindex.git ngx-fancyindex-0.5.2# 或者wget https://github.com/aperezdc/ngx-fancyindex/archive/refs/tags/v0.5.2.zipunzip v0.5.2.zip





下载 fancyindex-themegit clone git@github.com:Naereen/Nginx-Fancyindex-Theme.git# 或者wget https://github.com/Naereen/Nginx-Fancyindex-Theme/archive/refs/heads/master.zip

下载好的目录结构剔除不需要的文件后的最终目录结构如下图所示：
├── fancyindex.conf├── Nginx-Fancyindex│   ├── addNginxFancyIndexForm.js│   ├── footer.html│   ├── header.html│   ├── jquery.min.js│   ├── showdown.min.js│   └── styles.css├── Nginx-Fancyindex-Theme-dark│   ├── addNginxFancyIndexForm.js│   ├── footer.html│   ├── header.html│   ├── jquery.min.js│   ├── showdown.min.js│   └── styles.css├── Nginx-Fancyindex-Theme-light│   ├── addNginxFancyIndexForm.js│   ├── footer.html│   ├── header.html│   ├── HEADER.md│   ├── jquery.min.js│   ├── README.md│   ├── showdown.min.js│   └── styles.css

将 Nginx-Fancyindex、Nginx-Fancyindex-Theme-dark 以及 Nginx-Fancyindex-Theme-light 移动至 &#x2F;etc&#x2F;nginx&#x2F;html 目录下，然后将 fancyindex.conf 移动至 &#x2F;etc&#x2F;nginx 主目录下，使用如下命令：
cp -r Nginx-Fancyindex Nginx-Fancyindex-Theme-dark Nginx-Fancyindex-Theme-light /etc/nginx/htmlcp fancyindex.conf /etc/nginx

安装 nginxyum 安装（不推荐）1. 安装 Nginxyum 安装 nginx 非常简单，就输入一条命令即可。
$ sudo yum -y install nginx   # 安装 nginx$ sudo yum remove nginx  # 卸载 nginx

使用 yum 进行 Nginx 安装时，Nginx 配置文件在 /etc/nginx 目录下。
2. 配置 Nginx 服务$ sudo systemctl enable nginx # 设置开机启动 $ sudo service nginx start # 启动 nginx 服务$ sudo service nginx stop # 停止 nginx 服务$ sudo service nginx restart # 重启 nginx 服务$ sudo service nginx reload # 重新加载配置，一般是在修改过 nginx 配置文件时使用。

源码包安装（推荐）Nginx 源码包安装方式步骤比较繁琐，并且需要提前安装一些 Nginx 依赖库。
1. 依赖库安装安装基础环境yum -y install redhat-rpm-config perl-ExtUtils-Embed gd-devel GeoIP GeoIP-devel GeoIP-data libxslt-devel gperftools

安装 gcc 环境$ sudo yum -y install gcc gcc-c++ # nginx 编译时依赖 gcc 环境

安装 pcre$ sudo yum -y install pcre pcre-devel # 让 nginx 支持重写功能

安装 zlib# zlib 库提供了很多压缩和解压缩的方式，nginx 使用 zlib 对 http 包内容进行 gzip 压缩$ sudo yum -y install zlib zlib-devel

安装 openssl# 安全套接字层密码库，用于通信加密$ sudo yum -y install openssl openssl-devel

以上安装完成后，进行 nginx 安装。
2. nginx 源码包安装创建用户组和用户创建 nginx 用户组
groupadd nginx

创建 nginx 用户并添加进 nginx 用户组
useradd -g nginx -m nginx

设置 nginx 用户密码
passwd nginx

下载配置将准备好的 nginx-1.22.1.tar.gz 包，拷贝至 home 目录下（一般习惯在此目录下进行安装）进行解压缩。
源码包下载地址：nginx: download
$ sudo tar -zxvf nginx-1.22.1.tar.gz # 解压缩

在完成解压缩后，进入 nginx-1.22.1 目录进行源码编译安装。
这里编译的时候需要原有的编译的基础上加上以下参数：
--add-module=../ngx-fancyindex-0.5.2

命令会显示一些环境信息。如果出现错误，一般是依赖库没有安装完成，可按照错误提示信息进行所缺的依赖库安装。
预先创建好如下目录
mkdir -p /var/cache/nginx/&#123;client_temp,proxy_temp,fastcgi_temp,uwsgi_temp,scgi_temp&#125;

完整编译命令如下：
./configure \--prefix=/etc/nginx \--sbin-path=/usr/sbin/nginx \--modules-path=/usr/lib64/nginx/modules \--conf-path=/etc/nginx/nginx.conf \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--pid-path=/var/run/nginx.pid \--lock-path=/var/run/nginx.lock \--http-client-body-temp-path=/var/cache/nginx/client_temp \--http-proxy-temp-path=/var/cache/nginx/proxy_temp \--http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \--http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \--http-scgi-temp-path=/var/cache/nginx/scgi_temp \--user=nginx \--group=nginx \--with-compat \--with-file-aio \--with-threads \--with-http_addition_module \--with-http_auth_request_module \--with-http_dav_module \--with-http_flv_module \--with-http_gunzip_module \--with-http_gzip_static_module \--with-http_mp4_module \--with-http_random_index_module \--with-http_realip_module \--with-http_secure_link_module \--with-http_slice_module \--with-http_ssl_module \--with-http_stub_status_module \--with-http_sub_module \--with-http_v2_module \--with-mail \--with-mail_ssl_module \--with-stream \--with-stream_realip_module \--with-stream_ssl_module \--with-stream_ssl_preread_module \--with-cc-opt=&#x27;-I/usr/local/opt/pcre/include -I/usr/local/opt/openssl/include&#x27; \--with-ld-opt=&#x27;-L/usr/local/opt/pcre/lib -L/usr/local/opt/openssl/lib&#x27; \--add-module=../ngx-fancyindex

查看 fancy 是否安装成功
[root@yahya ~]# 2&gt;&amp;1 ./nginx -V | tr &#x27; &#x27; &#x27;\n&#x27;|grep fan--add-module=ngx-fancyindex-0.5.2

目录结构一览nginx 运行主 bin 文件已放至 /usr/sbin 目录下，可以直接使用 nginx 的相关命令而不需要定位到绝对路径，目录结构功能一览如下：
主配置文件目录[root@yahya ~]# tree /etc/nginx/etc/nginx├── fastcgi.conf├── fastcgi.conf.default├── fastcgi_params├── fastcgi_params.default├── html│   ├── 50x.html│   ├── fancyindex.conf│   ├── index.html│   ├── Nginx-Fancyindex│   │   ├── addNginxFancyIndexForm.js│   │   ├── footer.html│   │   ├── header.html│   │   ├── jquery.min.js│   │   ├── showdown.min.js│   │   └── styles.css│   ├── Nginx-Fancyindex-Theme-dark│   │   ├── addNginxFancyIndexForm.js│   │   ├── footer.html│   │   ├── header.html│   │   ├── jquery.min.js│   │   ├── showdown.min.js│   │   └── styles.css│   └── Nginx-Fancyindex-Theme-light│       ├── addNginxFancyIndexForm.js│       ├── footer.html│       ├── header.html│       ├── HEADER.md│       ├── jquery.min.js│       ├── README.md│       ├── showdown.min.js│       └── styles.css├── koi-utf├── koi-win├── mime.types├── mime.types.default├── nginx.conf├── nginx.conf.default├── pass_file├── scgi_params├── scgi_params.default├── uwsgi_params├── uwsgi_params.default└── win-utf

日志目录[root@yahya ~]# tree /var/log/nginx/var/log/nginx├── access.log└── error.log

临时文件目录[root@yahya ~]# tree /var/cache/nginx/var/cache/nginx├── client_temp├── fastcgi_temp├── proxy_temp├── scgi_temp└── uwsgi_temp

运行目录[root@yahya ~]# tree /var/run/var/run├── nginx.pid

编译安装进行源码编译并安装 nginx
$ make # 编译$ make install # 安装

3. 添加登录认证安装 htpasswd
sudo yum install -y httpd-tools

设置用户名密码
htpasswd -c -d /etc/nginx/pass_file &lt;username&gt;

回车，按提示输入两次密码。再次访问网站会弹出登录框做认证，这里设置用户名密码均为 admin。
4. 配置 nginx.conf#user  nobody;worker_processes  1;#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events &#123;    worker_connections  1024;&#125;http &#123;    include       mime.types;    default_type  application/octet-stream;    #log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;    #                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;    #                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    charset utf-8;    #access_log  logs/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    gzip  on;    server &#123;        listen       80;        server_name  localhost;        client_max_body_size 4G;        #charset koi8-r;        #access_log  logs/host.access.log  main;        error_page   500 502 503 504  /50x.html;        location / &#123;            root   html;            index  index.html index.htm;        &#125;        location /download &#123;            include /etc/nginx/fancyindex.conf; # 目录美化配置            auth_basic &quot;You are not authorized&quot;;            auth_basic_user_file /etc/nginx/pass_file;            alias /usr/local/download/; # 指定目录所在路径            autoindex on; # 开启目录浏览            autoindex_format html; # 以html风格将目录展示在浏览器中            autoindex_exact_size off; # 切换为 off 后，以可读的方式显示文件大小，单位为 KB、MB 或者 GB            autoindex_localtime on; # 以服务器的文件时间作为显示的时间            charset utf-8,gbk; # 展示中文文件名        &#125;        #error_page  404              /404.html;        # redirect server error pages to the static page /50x.html        #        error_page   500 502 503 504  /50x.html;        location = /50x.html &#123;            root   html;        &#125;    &#125;&#125;

常用命令查找当前 nginx 安装目录
which nginx

启动服务
nginx

重新加载服务
nginx -s reload

停止服务
nginx -s stop

查看 nginx 服务进程
ps -ef | grep nginx # 查看服务进程

参考链接linux添加用户，用户组（centos7）
How To Set Up Basic HTTP Authentication With Nginx on CentOS 7
CentOS 7 安装 Nginx
Nginx 文件服务器页面美化，按时间倒叙
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx SSL 配置</title>
    <url>/posts/6da6896d/</url>
    <content><![CDATA[目录编译安装为了给 nginx 增加 ssl 安全证书配置，需要在编译的时候增加以下选项：
--with-http_ssl_module

如果之前的 nginx 编译的时候已经加上上述选项，可以直接跳过，否则可以参考下面命令的基础用法：
./configure --prefix=&lt;安装位置&gt; --with-http_ssl_module

然后执行下面的命令进行 nginx 的安装
make &amp;&amp; make install

配置 nginx.confserver &#123;    listen       443 ssl;    server_name  localhost vless.yahyav2rayssr.top;    # ssl证书地址    ssl_certificate     /etc/nginx/cert/cloudflare-ssl.pem;  # pem文件的路径    ssl_certificate_key  /etc/nginx/cert/cloudflare-ssl.key; # key文件的路径    # ssl验证相关配置    ssl_session_timeout  5m;    #缓存有效期    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;    #加密算法    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;    #安全链接可选的加密协议    ssl_prefer_server_ciphers on;   #使用服务器端的首选算法    location / &#123;        root   html;        index  index.html index.htm;    &#125;&#125;

将 http 重定向 httpsserver &#123;    listen       80;    server_name  localhost vless.yahyav2rayssr.top;    return 301 https://$server_name$request_uri;&#125;

重启 nginxnginx -s reload

参考链接Nginx 安装 SSL 配置 HTTPS 超详细完整全过程
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 基本概念</title>
    <url>/posts/56e587e1/</url>
    <content><![CDATA[目录$host 和 $http_host 的区别$host 是 core 模块内部的一个变量

当请求头里不存在 Host 属性或者是个空值，$host 则等于 server_name
如果请求头里有 Host 属性，那么 $host 等于 Host 属性除了端口号的部分，例如 Host 属性是 www.example.com，那么 $host 就是 www.example.com

$http_host 不是一个固定的变量，他其实是 $http_HEADER 通配后的结果。
$http_HEADER，注意，这里的HEADER是一个通配符，通配的是请求头里的header属性，例如 $http_content_type 表示请求头里 content-type 属性的值，同理，$http_host 指的就是请求头里的 host 属性，也就是说，如果请求头里面 Host 为空，$http_host 取到的值也就是空。
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 常用命令</title>
    <url>/posts/ffa59763/</url>
    <content><![CDATA[测试文件是否正确nginx -t

指定外部配置文件nginx -c &lt;path_to_config&gt;

显示 nginx 版本号nginx -v

显示 nginx 的版本号以及编译环境信息以及编译时的参数nginx -V

]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 常用配置</title>
    <url>/posts/59e56e3a/</url>
    <content><![CDATA[nginx使用非80端口时url带端口号的解决办法
注意这里$server_port要和浏览器你想显示的端口号保持一致，因为我listen是80所以是80，如果你listen是8080，又想浏览器显示80，这里server_port 就设置成80。

server &#123;    listen 80;    server_name localhost;			# 参数之一    port_in_redirect off        proxy_set_header Host $host:$server_port;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header REMOTE-HOST $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    location / &#123;        proxy_pass http://127.0.0.1:8080/;    &#125;&#125;

proxy_pass反向代理cookie,session丢失server &#123;    listen 80;    server_name le.qin.com le.qin.cn;    location / &#123;        proxy_pass http://127.0.0.1:9002/;        root html;        index index.html;        rewrite &quot;^/+$&quot; /officialsite/initLedaIndex last;        proxy_cookie_path /offIcialsite/initLedaIndex /;        proxy_set_header Cookie $http_cookie;        proxy_set_header Host $http_host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    &#125;&#125;

proxy header 端口错误
nginx监听端口为非80端口时需要配置如下：

proxy_set_header Host $host:$server_port

proxy_redirect 使用
如果需要修改从被代理服务器传来的应答头中的”Location”和”Refresh”字段，可以用这个指令设置。

proxy_redirect 语法：proxy_redirect [ default | off | redirect replacement ] 默认值：proxy_redirect default 使用字段：http, server, location
示例：
server &#123;    listen 80;    server_name www.boke.com;    location / &#123;        proxy_pass http://192.168.1.154:8080;        proxy_redirect ~^http://192.168.1.154:8080(.*) http://www.boke.com$1;    &#125;&#125;

[root@localhost nginx]# curl -I http://www.boke.com/wumanHTTP/1.1 301 Moved PermanentlyServer: nginxDate: Thu, 24 Dec 2015 12:02:00 GMTContent-Type: text/html; charset=iso-8859-1Connection: keep-alive# 修改前Location: http://192.168.1.154:8080/wuman/# 修改后Location: http://www.boke.com/wuman/

location配置直接输出文本直接返回文本：
location / &#123;    default_type    text/plain;    return 502 &quot;服务正在升级，请稍后再试……&quot;;&#125;

也可以使用html标签格式：
location / &#123;    default_type    text/html;    return 502 &quot;服务正在升级，请稍后再试……&quot;;&#125;

也可以直接返回json文本：
location / &#123;    default_type    application/json;    return 502 &#x27;&#123;&quot;status&quot;:502,&quot;msg&quot;:&quot;服务正在升级，请稍后再试……&quot;&#125;&#x27;;&#125;

配置resolver指定DNS解析resolver可以指定多个DNS，使用valid来设置缓存时间，如下：
resolver 119.29.29.29 114.114.114.114 valid=3600s;

如果不填写端口则默认使用53，还可以向下面这样指定DNS端口：
resolver 127.0.0.1:5353 valid=30s;

强制更新解析：
resolver 127.0.0.1;set $backend &quot;foo.example.com&quot;;proxy_pass http://$backend;

server_name 配置前言虚拟主机是一种在单一主机或主机群上运行多个网站或服务的技术，可以用来解决IP地址资源有限而网站数目日益增多的问题。实现方式主要有以下三种:

基于域名(Name-based)
基于IP地址(IP-based)
基于Port端口(Port-based)

其中使用最广泛无疑是基于域名的方式,不同的域名通过DNS最终可以解析到相同的IP地址,在对应的机器上我们可以使用Nginx等Web服务器软件对不同的域名请求进行相应的处理。这里再提及一点,我们平时访问一个网站，是通过DNS将其解析到某一个IP上,我们的客户端（通常是浏览器）最终是和这个IP对应的机器建立连接，从而发送请求的。那么Nginx等服务器是如何知道一个请求对应的是哪个域名的呢？
答案在于HTTP协议中的Host请求头,其值为我们要访问的域名。这里需要注意的是,在HTTP&#x2F;1.0中是不支持Host请求头字段的,所以HTTP&#x2F;1.0是不支持虚拟主机技术的，而根据 rfc2616规范 HTTP&#x2F;1.1协议中客户端发送的请求必须带上Host这个请求头,否则服务器必须返回400 Bad Request响应。
而nginx正是通过http模块下的server指令块来配置虚拟主机。
配置语法Syntax:    server_name name ...;Default:    server_name &quot;&quot;;Context: server

server_name形式sever_name指令后面的参数值可以是以下几种:

精确的域名,例如www.example.com
通配符名称,可用表示任意多字符(类似Linux Shell中的),但是通配符必须在域名的最前面或者最后面,例如*.example.com、www.example.*
正则表达式,最前面是一个波浪号,例如&#96;^www\d+.example.com$&#96;表示可以匹配以www开头，后跟一个到多个数字，然后以.example.com结尾的域名

除了以上几种形式，还有下面几种表示特殊含义的域名:

.example.com,相当于*.example.com + example.com
“” 可以匹配没有带Host头的请求
国际化域名（用得不多,了解即可）,用ASCII码表示，例如xn--e1afmkfd.xn--80akhbyknj4f可表示пример.испытание
_、__或者!@#等无效的域名，可以理解为其可以匹配任意域名，但是优先级最低，最常见的用法是用来设置默认的server,即当一个请求的Host没有命中其他规则时，会采用默认server的配置。配置如下:

server &#123;    listen       80  default_server;    server_name  _;    return       444;&#125;

server_name匹配顺序当需要决定采用哪个server块的配置处理请求时,会根据以下的顺序查找:

精确匹配
以 * 开头的最长通配符名称
以 * 结尾的最长通配符名称
根据在配置文件出现的顺序第一个匹配上的正则表示式名称
默认配置，在 listen 指令中指明了 default_server 的 server 块，若无，为配置文件中第一个声明的 server 块

配置默认serverserver &#123;    listen 80 default_server;    server_name _;    return 200 &quot;default_server&quot;;&#125;

关于listen指令,有几点需要注意的地方:

如果server指令块里没有指定listen指令,则根据运行nginx的用户不同，默认监听的端口也不同,root用户启动默认监听80端口，否则默认监听8000端口
如果配置了listen且只指定了IP,则监听端口为80,此时操作系统可能会不允许非root用户启动nginx，提示

nginx: [emerg] bind() to 127.0.0.1:80 failed (13: Permission denied)

location 配置配置语法Syntax:    location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;location @name &#123; ... &#125;Default: —Context: server, location

根据配置语法我们知道location可以有以下几种形式:

其中 &#x3D; 和 ^~ 修饰符都可以认为是特殊形式的前缀匹配，正则匹配比普通前缀匹配优先级高


&#x3D;，精确匹配
～，正则匹配,大小写敏感
～*，正则匹配, 大小写不敏感
^~，忽略正则表达式的前缀匹配
没有修饰符，普通前缀匹配
@，命名location,可用来做内部重定向

匹配过程根据请求的 URI 和 location 的配置,查找请求对应的 location 过程如下:

将请求URI标准化,包括将”%xx”形式编码的文本进行解码，解析相对路径”.”和”..”以及合并两个或多个相邻的”&#x2F;“成单个”&#x2F;“。
根据请求URI找到并记录匹配上的最长前缀匹配，这里有两个特殊的场景:
找到了&#x3D;修饰的精确匹配,结束查找,采用它的配置。
如果该步骤最终记录下的前缀以^~修饰，则采用它的配置，不会进行后续的查找步骤。


根据在配置文件出现的顺序，检查相应的正则匹配，若有一个匹配上，则应用该配置，且不会继续检查后续的正则配置。
若第3步没有找到匹配上的正则匹配，则采用第2步中找到的最长前缀匹配对应的配置。

根据上面的查找过程，可以得到一些配置优化点：

对于经常要访问的路径，可以使用精确匹配或^&#x3D;修饰的匹配,可以避免进行正则匹配检查。
如果一定要用到正则表达式，可以把最经常被访问的location规则配置在最前面，因为正则匹配命中一个就不会继续验证后续的匹配规则。

注意：
关于最后一条测试结果,需要注意的是，/a/.*$这个正则表达式,并不要求请求URI以/a开头，这也是很容易疏漏的地方,若想匹配以/a开头的请求，应改为^/a/.*$
@name的用法location /try &#123;    try_files $uri $uri/ @name;&#125;location /error &#123;    error_page 404 = @name;    return 404;&#125;location @name &#123;    return 200 &quot;@name&quot;;&#125;

]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 常见错误</title>
    <url>/posts/516ff0b8/</url>
    <content><![CDATA[目录413错误
fastcgi_intercept_errors 语法: fastcgi_intercept_errors on|off 默认: fastcgi_intercept_errors off 添加位置: http, server, location 默认情况下，nginx不支持自定义404错误页面，只有这个指令被设置为on，nginx才支持将404错误重定向

修改nginx配置文件，配置客户端请求大小和缓存大小
在http&#123;&#125;中输入
client_max_body_size 8M;(配置请求体缓存区大小) client_body_buffer_size 128k;(设置客户端请求体最大值) fastcgi_intercept_errors on;

post 解决办法针对post请求解决办法： 
修改nginx.conf里面的几个相关的配置参数 
client_body_buffer_size 10m(配置请求体缓存区大小, 不配的话) client_max_body_size 20m(设置客户端请求体最大值) client_body_temp_path /data/temp (设置临时文件存放路径。只有当上传的请求体超出缓存区大小时，才会写到临时文件中,注意临时路径要有写入权限) 

如果上传文件大小超过client_max_body_size时，会报413 entity too large的错误。 
get 解决办法
为什么修改 http header 的大小就能解决 get 请求串过长的问题？因为 get 请求参数会拼在 http header 中，所以，修改了 http header 的大小，就能解决上面问题。

针对get请求，我们可以通过修改另外两个配置来解决请求串超长的问题： 
使用字段：http, server 
client_header_buffer_size 16k;large_client_header_buffers 4 16k;

下面讲讲这两个参数以及他们之间的关联关系：
对nginx处理header时的方法：


先处理请求的request_line，之后才是request_header。
这两者的buffer分配策略相同。
先根据client_header_buffer_size配置的值分配一个buffer，如果分配的buffer无法容纳 request_line&#x2F;request_header，那么就会再次根据large_client_header_buffers配置的参数分配large_buffer，如果large_buffer还是无法容纳，那么就会返回414（处理request_line）&#x2F;400（处理request_header）错误。


400错误：HTTP头&#x2F;Cookie过大　　nginx400错误是由于request header过大，通常是由于cookie中写入了较长的字符串所引起的。
​		解决方法是不要在cookie里记录过多数据，如果实在需要的话可以考虑调整在nginx.conf中的client_header_buffer_size(默认1k)
　　若cookie太大，可能还需要调整large_client_header_buffers(默认4k)，该参数说明如下：
　　请求行如果超过buffer，就会报HTTP 414错误(URI Too Long)
　　nginx接受最长的HTTP头部大小必须比其中一个buffer大，否则就会报400的HTTP错误(Bad Request)。
504错误1、修改&#x2F;etc&#x2F;nginx&#x2F;nginx.conf，添加如下信息：
http &#123;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    access_log  /var/log/nginx/access.log  main;    sendfile on;    # tcp_nopush on;    keepalive_timeout 65;    # gzip on;    include /etc/nginx/conf.d/*.conf;            # 用于tomcat反向代理,解决nginx 504错误     proxy_connect_timeout 300; #单位秒     proxy_send_timeout 300; #单位秒     proxy_read_timeout 300; #单位秒     proxy_buffer_size 16k;     proxy_buffers 4 64k;     proxy_busy_buffers_size 128k;     proxy_temp_file_write_size 128k;    # ps:以timeout结尾配置项时间要配置大点&#125;

2、修改server{}，添加如下信息：
location / &#123;        proxy_pass http://182.61.131.62:33060/;        proxy_redirect  off;    	    #用于tomcat反向代理,解决nginx 504错误        proxy_send_timeout 300;        proxy_read_timeout 300;        proxy_connect_timeout 300;        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#125;

http header丢失
header键尽量不要带下划线的命名，不然必须得在nginx里面手动打开如下配置：

underscores_in_headers on;

rewrite post数据丢失rewrite 外部跳转和内部跳转的区别

外部跳转 http:&#x2F;&#x2F; 触发301，POST数据丢失
内部跳转 POST数据不丢失

使用rewrite 与proxy_pass处理此事
location / &#123;    rewrite (.*) /app$1;&#125;location /app &#123;    proxy_pass http://was;&#125;

http 411 length requiredhttp模块添加参数：chunked_transfer_encoding on;
301 URI路径错误问题前端的Nginx负责把http://www.a.com/b/c/开头的url反向代理到后端的 http://127.0.0.1/c/ 上，对于有完整的
路径，如http://www.a.com/b/c/的代理没有问题，Server对应后台服务器的一个目录。
但当访问http://www.a.com/b/c时，后端Nginx会发送一个301到/上，于是返回到前端后URL变成了
http://www.a.com/c/，这个url显然不是我们想要的。

在Apache中有个ProxyPassReverse的参数，用来调整反向代理服务器发送的http应答头的url，可以解决这个问题。

在Nginx代理配置，可以使用proxy_redirect这个参数，它实现的功能和ProxyPassReverse类似，例如增加如下配置：
location ^~ /b &#123;   proxy_pass http://127.0.0.1/;   proxy_redirect http://www.a.com/ /b/; &#125; 

Location 携带错误端口号抓包发现服务器给客户端的跳转指令里加了端口号，如Location: http://www.a.com:9080/abc.html 。因为nginx服务器侦听的是80端口，所以这样的URL给了客户端,必然会出错.针对这种情况, 加一条proxy_redirect指令: proxy_redirect http://www.kevin.com:9080/ / ,即把所有&quot;http://www.a.com:9080/&quot;的内容替换成&quot;/&quot;再发给客户端，就解决了。
server &#123;    listen 80;    server_name www.a.com;    proxy_redirect http://www.a.com:9080/ /; # 增加此行    location / &#123;        proxy_pass http://127.0.0.1:9080;    &#125;&#125;

]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx 证书概念</title>
    <url>/posts/4b23af26/</url>
    <content><![CDATA[目录编码格式X.509 - 这是一种证书标准,主要定义了证书中应该包含哪些内容.其详情可以参考 RFC5280，SSL使用的就是这种证书标准。
目前有以下两种编码格式。
PEMPrivacy Enhanced Mail，打开看文本格式，以”—–BEGIN…”开头，”—–END…”结尾，内容是 BASE64 编码。
查看 PEM 格式证书的信息：
openssl x509 -in cloudflare-ssl.pem -text -noout

Apache 和 NGINX 服务器偏向于使用这种编码格式.
PEM – Openssl 使用 PEM（Privacy Enhanced Mail）格式来存放各种信息，它是 openssl 默认采用的信息存放方式。
Openssl 中的 PEM 文件一般包含如下信息:

内容类型：表明本文件存放的是什么信息内容,它的形式为“——-BEGIN XXXX ——”，与结尾的“——END XXXX——”对应。
头信息：表明数据是如果被处理后存放，openssl 中用的最多的是加密信息，比如加密算法以及初始化向量 iv。
信息体：为 BASE64 编码的数据。可以包括所有私钥（RSA 和 DSA）、公钥（RSA 和 DSA）和 (x509) 证书。它存储用 Base64 编码的 DER 格式数据，用 ascii 报头包围，因此适合系统之间的文本模式传输。

举个栗子：
使用 PEM 格式存储的证书（.pem 格式结尾）：
—–BEGIN CERTIFICATE—–MIICJjCCAdCgAwIBAgIBITANBgkqhkiG9w0BAQQFADCBqTELMAkGA1UEBhMCVVMx………1p8h5vkHVbMu1frD1UgGnPlOO/K7Ig/KrsU=—–END CERTIFICATE—–

使用 PEM 格式存储的私钥（.key 格式结尾）：
—–BEGIN RSA PRIVATE KEY—–MIICJjCCAdCgAwIBAgIBITANBgkqhkiG9w0BAQQFADCBqTELMAkGA1UEBhMCVVMx………1p8h5vkHVbMu1frD1UgGnPlOO/K7Ig/KrsU=—–END RSA PRIVATE KEY—–

使用 PEM 格式存储的证书请求文件(.csr 格式结尾 )：
—–BEGIN CERTIFICATE REQUEST—–MIICJjCCAdCgAwIBAgIBITANBgkqhkiG9w0BAQQFADCBqTELMAkGA1UEBhMCVVMx………1p8h5vkHVbMu1frD1UgGnPlOO/K7Ig/KrsU=—–END CERTIFICATE REQUEST—–

DERDistinguished Encoding Rules，辨别编码规则 (DER) 可包含所有私钥、公钥和证书。它是大多数浏览器的缺省格式，并按 ASN1 DER 格式存储。它是无报头的 － PEM 是用文本报头包围的 DER，打开看是二进制格式,不可读.
查看DER格式证书的信息：
openssl x509 -in cloudflare-ssl.der -inform der -text -noout

Java 和 Windows 服务器偏向于使用这种编码格式。
证书转换PEM 转 CRTopenssl x509 -in cloudflare-ssl.pem -out cloudflare-ssl.crt

CRT 转 PEMopenssl x509 -in cloudflare-ssl.crt -outform pem -out cloudflare-ssl.pem

PEM 转为 DERopenssl x509 -in cloudflare-ssl.pem -outform der -out cloudflare-ssl.der

DER 转为 PEMopenssl x509 -in cloudflare-ssl.der -inform der -outform pem -out cloudflare-ssl.pem

CRT 转 DERopenssl x509 -in cloudflare-ssl.crt -outform der -out cloudflare-ssl.der

从上面的命令我们看出证书的转换是支持三边两两转换的，除了不支持 der 直接转成 crt 之外，如下图所示：

提示：要转换 KEY 文件也类似,只不过把 x509 换成 rsa，要转 CSR 的话，把 x509 换成 req。






]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>证书</tag>
      </tags>
  </entry>
  <entry>
    <title>gitkraken 破解</title>
    <url>/posts/8aace767/</url>
    <content><![CDATA[1. 下载客户端
gitkraken windows版本 6.5.1下载地址-1
gitkraken windows版本 6.5.1下载地址-2
gitkraken Mac版本 6.5.1下载地址
gitkraken linux deb 6.5.1下载地址

2. 屏蔽更新host# gitKraken 更新屏蔽127.0.0.1 release.gitkraken.com

3. 打开gitkraken并登陆4. 下载破解脚本git clone https://github.com/5cr1pt/GitCracken.gitcd GitCracken/GitCrackenrm yarn.lockyarn installyarn build# windows gitbashnode dist/bin/gitcracken.js patcher --asar ~/AppData/Local/gitkraken/app-6.5.0/resources/app.asar# mac node dist/bin/gitcracken.js patcher --asar 你的gitkraken的目录/resources/app.asar

5. 禁用更新删掉Update.exe, 查找和Gitkraken目录有关的Update.exe(一般在C:\Users\你的用户名\AppData\Local\gitkraken目录下)。

参考：
插件github
破解插件
才发现 gitkraken 现在要给钱才能打开私有库了
]]></content>
      <categories>
        <category>破解</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>jrebel 破解</title>
    <url>/posts/b92b7720/</url>
    <content><![CDATA[1. 生成 GUID 的网址https://www.guidgen.com/
2. 用这个网址 + 生成的 GUID 激活https://jrebel.qekang.com/
例如:
https://jrebel.qekang.com/738b776f-6cc9-4ac5-9574-960a057392db


3. 设置离线模式 来防止失效]]></content>
      <categories>
        <category>破解</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>typora 优化</title>
    <url>/posts/1ed812a6/</url>
    <content><![CDATA[插入的图片左对齐p .md-image:only-child&#123;    width: auto;    text-align: inherit;&#125;

右键打开
Win+R 调出运行窗口
输入 regedit 打开注册表



1. 对文件增加Typora右键打开项设置使用 Typora.exe 打开


首先找到路径计算机\HKEY_CLASSES_ROOT\*\shell\
在 shell 文件夹上右键 新建-&gt;项，文件夹名 Typora
在 Typora 右键 新建-&gt;项，文件夹名 command
单击 command，双击右侧名称中的默认，数值数据 中输入&quot;C:\Program Files\Typora\typora.exe&quot; &quot;%1&quot;  (你自己程序所在位置)
此时已经可以在文件上右键通过Typora打开文件了

设置图标和右键中显示的提示

单击Typora
右侧双击默认 数值数据 是右键时提示的文字，这里填写Open With Typora
右侧右键 新建 -&gt; 字符串值，输入icon，双击icon 数值数据输入&quot;C:\Program Files\Typora\typora.exe&quot;  (你自己程序所在位置)


2. 对文件夹增加Typora右键打开项
首先找到路径  计算机\HKEY_CLASSES_ROOT\Folder\shell\
按照上面的方法
新建 Typora 及子项 command
单击 command 右侧设置指令
单击 Typora 右侧设置右键显示的内容和 icon

3. 命令解释
指令要用双引号，若不用双引号window对带有空格的路径识别是有问题的

&quot;C:\Program Files\Typora\typora.exe&quot; &quot;%1&quot;

%1 或获取当前选择的内容，可能是文件的路径，也可能是文件夹的路径
当你cmd终端中输入如下的指令时Typora会打开hello.markdown文件
&quot;C:\Program Files\Typora\typora.exe&quot; &quot;F:\hello.markdown&quot;

4. 简易设置方式在桌面新建 typora-file.reg 和 typora-folder.reg 两个文件
用记事本分别录入两个内容
然后分别双击两个文件会，注册表会自动设置
Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\Typora]&quot;icon&quot;=&quot;C:\\Program Files\\Typora\\typora.exe&quot;@=&quot;Open With Typora&quot;[HKEY_CLASSES_ROOT\*\shell\Typora\command]@=&quot;\&quot;C:\\Program Files\\Typora\\typora.exe\&quot; \&quot;%1\&quot;&quot;

Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Folder\shell\Typora]&quot;icon&quot;=&quot;C:\\Program Files\\Typora\\typora.exe&quot;@=&quot;Open With Typora&quot;[HKEY_CLASSES_ROOT\Folder\shell\Typora\command]@=&quot;\&quot;C:\\Program Files\\Typora\\typora.exe\&quot; \&quot;%1&quot;&quot;

荧光笔高亮开启高亮打开方式：文件 &gt; 偏好设置 &gt; Markdown &gt; Markdown扩展语法中把 高亮 选中 &gt; 重启Typora，如下图所示：


更改高亮配色打开方式：文件 &gt; 偏好设置 &gt; 外观 &gt; 打开主题文件夹 &gt; drake-light.css文件 &gt; Ctrl+F 搜索 mark &gt; 修改喜欢的 background(背景颜色) 和 color(字体颜色) 保存。
这里修改后的最终效果如下：
/* height light */#write mark &#123;    background-color: #f8f840;    padding: .1rem .5rem;    margin: 0 .2rem;&#125;

设置高亮快捷键设置方式：文件 &gt; 偏好设置 &gt; 通用 &gt; 打开高级设置 &gt; 会看到两个json文件，添加绑定快捷键，如下所示：
&#123;   ...	&quot;keyBinding&quot;: &#123;    &quot;Highlight&quot;: &quot;Ctrl + q&quot;  &#125;,  ...&#125;

]]></content>
      <categories>
        <category>破解</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>有道云笔记去广告</title>
    <url>/posts/c1da566d/</url>
    <content><![CDATA[有道云笔记v6.70去除广告去除文章列表底部广告编辑文件C:\Program Files (x86)\Youdao\YoudaoNote\theme\build.xml
搜索AdWraperMid, 找到如下代码块:
&lt;AdWraperMid type=&quot;panel&quot; css=&quot;public&quot; dockstyle=&quot;bottom&quot; visible=&quot;false&quot; bounds=&quot;0,0,0,161&quot;&gt;

修改成如下部分
&lt;AdWraperMid type=&quot;panel&quot; css=&quot;public&quot; dockstyle=&quot;bottom&quot; visible=&quot;false&quot; bounds=&quot;0,0,0,0&quot;&gt;

其实就是修改了第一行末尾的bounds=&quot;0,0,0,161&quot; 为 bounds=&quot;0,0,0,0&quot;，来隐藏广告位窗口。
去除左下角广告搜索PanelAd, 找到如下代码块，&lt;PanelAd 这一行的 ass=&quot;mainform panelclient PanelAd&quot; 删除即可:
&lt;PanelAd type=&quot;adpanel&quot; css=&quot;public&quot; ass=&quot;mainform panelclient PanelAd&quot;&gt;

修改后：
&lt;PanelAd type=&quot;adpanel&quot; css=&quot;public&quot;&gt;

然后保存文件，重启软件。
]]></content>
      <categories>
        <category>破解</category>
      </categories>
      <tags>
        <tag>破解</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql 面试题</title>
    <url>/posts/34945828/</url>
    <content><![CDATA[1、MySQL 中有哪几种锁？
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

2、MySQL 中有哪些不同的表格？
MyISAM
Heap
Merge
INNODB
ISAM

3、简述在 MySQL 数据库中 MyISAM 和 InnoDB 的区别MyISAM：

不支持事务，但是每次查询都是原子的；
支持表级锁，即每次操作是对整个表加锁；
存储表的总行数；
一个 MYISAM 表有三个文件：索引文件、表结构文件、数据文件；
采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。

InnoDb：

支持 ACID 的事务，支持事务的四种隔离级别；
支持行级锁及外键约束，因此可以支持写并发；
不存储总行数；
一个 InnoDb 引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G），受操作系统文件大小的限制；
主键索引采用聚集索引（索引的数据域存储数据文件本身），辅索引的数据域存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为了维持 B+树结构，文件的大调整。

4、MySQL 中 InnoDB 支持的四种事务隔离级别名称，以及逐 级之间的区别？SQL 标准定义的四个隔离级别为：

Read uncommitted 读未提交 在该级别下，一个事务对一行数据修改的过程中，不允许另一个事务对该行数据进行修改，但允许另一个事务对该行数据读。 因此本级别下，不会出现更新丢失，但会出现脏读、不可重复读。
Read committed 读提交 在该级别下，未提交的写事务不允许其他事务访问该行，因此不会出现脏读；但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。
Repeatable read 重复读 在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。
Serializable 序列化 该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低。

5、CHAR 和 VARCHAR 的区别？
CHAR 和 VARCHAR 类型在存储和检索方面有所不同
CHAR 列长度固定为创建表时声明的长度，长度值范围是 1 到 255 当 CHAR 值被存储时，它们被用空格填充到特定长度，检索 CHAR 值时需删除尾随空格。

6、主键和候选键有什么区别？表格的每一行都由主键唯一标识,一个表只有一个主键。
主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。
7、myisamchk 是用来做什么的？它用来压缩 MyISAM 表，这减少了磁盘或内存使用。
MyISAM Static 和 MyISAM Dynamic 有什么区别？
在 MyISAM Static 上的所有字段有固定宽度。动态 MyISAM 表将具有像 TEXT， BLOB 等字段，以适应不同长度的数据类型。
MyISAM Static 在受损情况下更容易恢复。
8、如果一个表有一列定义为 TIMESTAMP，将发生什么？每当行被更改时，时间戳字段将获取当前时间戳。

列设置为 AUTO INCREMENT 时，如果在表中达到最大值，会发生什么情况？它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。
怎样才能找出最后一次插入时分配了哪个自动增量？LAST_INSERT_ID 将返回由 Auto_increment 分配的最后一个值，并且不需要指定表名称。

9、你怎么看到为表格定义的所有索引？索引是通过以下方式为表格定义的：
SHOW INDEX FROM ;
10、LIKE 声明中的％和_是什么意思？％对应于 0 个或更多字符，_只是 LIKE 语句中的一个字符。

如何在 Unix 和 MySQL 时间戳之间进行转换？
UNIX_TIMESTAMP 是从 MySQL 时间戳转换为 Unix 时间戳的命令 
FROM_UNIXTIME 是从 Unix 时间戳转换为 MySQL 时间戳的命令。


11、列对比运算符是什么？在 SELECT 语句的列比较中使用&#x3D;，&lt;&gt;，&lt;&#x3D;，&lt;，&gt; &#x3D;，&gt;，&lt;&lt;，&gt;&gt;，&lt;&#x3D;&gt;，AND， OR 或 LIKE 运算符。
12、BLOB 和 TEXT 有什么区别？BLOB 是一个二进制对象，可以容纳可变数量的数据。TEXT 是一个不区分大小写的 BLOB。
BLOB 和 TEXT 类型之间的唯一区别在于对 BLOB 值进行排序和比较时区分大小写，对 TEXT 值不区分大小写。
13、MySQL_fetch_array 和 MySQL_fetch_object 的区别是 什么？以下是 MySQL_fetch_array 和 MySQL_fetch_object 的区别：
MySQL_fetch_array（） – 将结果行作为关联数组或来自数据库的常规数组返回。
MySQL_fetch_object – 从数据库返回结果行作为对象。
14、MyISAM 表格将在哪里存储，并且还提供其存储格式？每个 MyISAM 表格以三种格式存储在磁盘上：

文件存储表具有“.frm”扩展名
数据文件具有“.MYD”（MYData）扩展名
索引文件具有“.MYI”（MYIndex）扩展名

15、MySQL 如何优化 DISTINCT？DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。
17、可以使用多少列创建索引？任何标准表最多可以创建 16 个索引列。
18、NOW（）和 CURRENT_DATE（）有什么区别？NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。
CURRENT_DATE（）仅显示当前年份，月份和日期。
19、什么是非标准字符串类型？
TINYTEXT
TEXT
MEDIUMTEXT
LONGTEXT

20、什么是通用 SQL 函数？
CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个 或多个字段合并为一个字段
FORMAT(X, D)- 格式化数字 X 到 D 有效数字。
CURRDATE(), CURRTIME()- 返回当前日期或时间。
NOW（） – 将当前日期和时间作为一个值返回。
MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期 值中提取给定数据。
HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。
DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄
SUBTIMES（A，B） – 确定两次之间的差异。
FROMDAYS（INT） – 将整数天数转换为日期值。

21、MySQL 支持事务吗？在缺省模式下，MySQL 是 autocommit 模式的，所有的数据库更新操作都会即时 提交，所以在缺省情况下，MySQL 是不支持事务的。
但是如果你的 MySQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的 MySQL 就可以使用事务处理,使用 SET AUTOCOMMIT&#x3D;0 就可以使 MySQL 允许在非 autocommit 模式，在非 autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK 来回滚你的更改。
22、MySQL 里记录货币用什么字段类型好NUMERIC 和 DECIMAL 类型被 MySQL 实现为同样的类型，这在 SQL92 标准允许。他们被用于保存值，该值的准确精度是极其重要的值，例如与金钱有关的数据。当声明一个类是这些类型之一时，精度和规模的能被(并且通常是)指定。
例如：
salary DECIMAL(9,2)
在这个例子中，9(precision)代表将被用于存储值的总的小数位数，而 2(scale)代 表将被用于存储小数点后的位数。
因此，在这种情况下，能被存储在 salary 列中的值的范围是从-9999999.99 到 9999999.99。
23、MySQL 有关权限的表都有哪几个？MySQL 服务器通过权限表来控制用户对数据库的访问，权限表存放在 MySQL 数据库里，由 MySQL_install_db 脚本初始化。这些权限表分别 user，db，table_priv， columns_priv 和 host。
24、列的字符串类型可以是什么？字符串类型是：
1、SET
2、BLOB
3、ENUM
4、CHAR
5、TEXT
25、MySQL 数据库作发布系统的存储，一天五万条以上的增量， 预计运维三年,怎么优化？1、设计良好的数据库结构，允许部分数据冗余，尽量避免 join 查询，提高效率。
2、选择合适的表字段数据类型和存储引擎，适当的添加索引。
3、 MySQL 库主从读写分离。
4、找规律分表，减少单表中的数据量提高查询速度。
5、添加缓存机制，比如 memcached，apc 等。
6、不经常改动的页面，生成静态页面。
7、书写高效率的 SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE。
26、锁的优化策略
读写分离
分段加锁
减少锁持有的时间
多个线程尽量以相同的顺序去获取资源

不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效 率不如一次加一把大锁。
27、索引的底层实现原理和优化B+树，经过优化的 B+树
主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此 InnoDB 建议为大部分表使用默认自增的主键作为主索引。
28、什么情况下设置了索引但无法使用
以“%”开头的 LIKE 语句，模糊匹配
OR 语句前后没有同时使用索引
数据类型出现隐式转化（如 varchar 不加单引号的话可能会自动转换为 int 型）

30、优化数据库的方法
选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL， 例如’省份’、’性别’最好适用 ENUM
使用连接(JOIN)来代替子查询
适用联合(UNION)来代替手动创建的临时表
事务处理
锁定表、优化事务处理
适用外键，优化锁定表
建立索引
优化查询语句

31、简单描述 MySQL 中，索引，主键，唯一索引，联合索引 的区别，对数据库的性能有什么影响（从读写两方面）索引是一种特殊的文件(InnoDB 数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。

普通索引(由关键字 KEY 或 INDEX 定义的索引)的唯一任务是加快对数据的访问速度。
普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字 UNIQUE 把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。

主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。

索引可以覆盖多个数据列，如像 INDEX(columnA, columnB)索引，这就是联合索引。


索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度， 因为在执行这些写操作时，还要操作索引文件。
32、数据库中的事务是什么?事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。
事务特性：
1、原子性：即不可分割性，事务要么全部被执行，要么就全部不被执行。
2、一致性或可串性：事务的执行使得数据库从一种正确状态转换成另一种正确状态
3、隔离性：在事务正确提交之前，不允许把该事务对数据的任何改变提供给任何其他事务，
4、持久性：事务正确提交后，其结果将永久保存在数据库中，即使在事务提交后有了其他故障，事务的处理结果也会得到保存。
或者这样理解：
事务就是被绑定在一起作为一个逻辑工作单元的 SQL 语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上有个节点。为了确保要么执行，要么不执行，就可以使用事务。要将有组语句作为事务考虑，就需要通过 ACID 测试，即原子性，一致性，隔离性和持久性。
33、SQL 注入漏洞产生的原因？如何防止？SQL 注入产生的原因：程序开发过程中不注意规范书写 sql 语句和对特殊字符行过滤，导致客户端可以通过全局变量 POST 和 GET 提交一些 sql 语句正常执行。
防止 SQL 注入的方式：
开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设执行 sql 语句时使用 addslashes 进行 sql 语句转换
Sql 语句书写尽量不要省略双引号和单引号。
过滤掉 sql 语句中的一些关键词：update、insert、delete、select、 * 。
提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。
34、为表中得字段选择合适得数据类型字段类型优先级: 整形&gt;date,time&gt;enum,char&gt;varchar&gt;blob,tex
优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型
35、存储时期Datatime：以 YYYY-MM-DD HH:MM:SS 格式存储时期时间，精确到秒，占用 8 个字节得存储空间，datatime 类型与时区无关
Timestamp：以时间戳格式存储，占用 4 个字节，范围小 1970-1-1 到 2038-1-19，显示依赖于所指定得时区，默认在第一个列行的数据修改时可以自动得修改
timestamp列得值
Date:（生日）占用得字节数比使用字符串储存要少，使用 date 只 需要 3 个字节，存储日期月份，还可以利用日期时间函数进行日期间得计算
Time：存储时间部分得数据
注意：不要使用字符串类型来存储日期时间数据（通常比字符串占用得储存空间小， 在进行查找过滤可以利用日期得函数）
使用 int 存储日期时间不如使用 timestamp 类型
36、对于关系型数据库而言，索引是相当重要的概念，请回答 有关索引的几个问题：1、索引的目的是什么？
快速访问数据表中的特定信息，提高检索速度
创建唯一性索引，保证数据库表中每一行数据的唯一性。
加速表和表之间的连接
使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间
2、索引对数据库系统的负面影响是什么？
负面影响：
创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间； 当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。
3、为数据表建立索引的原则有哪些？
在最频繁使用的、用以缩小查询范围的字段上建立索引。
在频繁使用的、需要排序的字段上建立索引
4、什么情况下不宜建立索引？
对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。
对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等
37、解释 MySQL 外连接、内连接与自连接的区别先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。
内连接则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。
外连接其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。
左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以 NULL 来填充。
右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL 目前还不支持全外连接。
38、Myql 中的事务回滚机制概述事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。
要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前的状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚。
39、SQL 语言包括哪几部分？每部分都有哪些操作关键字？SQL 语言包括数据定义(DDL)、数据操纵(DML)，数据控制(DCL)和数据查询（DQL）四个部分。

数据定义：Create Table，Alter Table，Drop Table, Create&#x2F;Drop Index 等
数据操纵：select，insert，update，delete
数据控制：grant，revoke
数据查询：select

40、完整性约束包括哪些？数据完整性(Data Integrity)是指数据的精确(Accuracy)和可靠性(Reliability)。
分为以下四类：

实体完整性：规定表的每一行在表中是唯一的实体。
域完整性：是指表中的列必须满足某种特定的数据类型约束，其中约束又包括取值范围、精度等规定。
参照完整性：是指两个表的主关键字和外关键字的数据应一致，保证了表之间的数据的一致性，防止了数据丢失或无意义的数据在数据库中扩散。
用户定义的完整性：不同的关系数据库系统根据其应用环境的不同，往往还需要一些特殊的约束条件。用户定义的完整性即是针对某个特定关系数据库的约束条件，它反映某一具体应用必须满足的语义要求。

与表有关的约束：包括列约束(NOT NULL（非空约束）)和表约束(PRIMARY KEY、 foreign key、check、UNIQUE) 。
41、什么是锁？数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。
加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。
基本锁类型：锁包括行级锁和表级锁。
42、什么叫视图？游标是什么？视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增改查操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。
游标是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。
43、什么是存储过程？用什么来调用？存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL， 使用存储过程比单纯 SQL 语句执行要快。可以用一个命令对象来调用存储过程。
44、如何通俗地理解三个范式？第一范式：1NF 是对属性的原子性约束，要求属性具有原子性，不可再分解。
第二范式：2NF 是对记录的唯一性约束，要求记录有惟一标识，即实体的唯一性。
第三范式：3NF 是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。
范式化设计优缺点:
优点：可以尽量得减少数据冗余，使得更新快，体积小 
缺点：对于查询需要多个表进行关联，减少写得效率增加读得效率，更难进行索引优化
反范式化:
优点：可以减少表得关联，可以更好得进行索引优化
缺点：数据冗余以及数据异常，数据得修改需要更多的成本
46、试述视图的优点？
视图能够简化用户的操作；
视图使用户能以多种角度看待同一数据；
视图为数据库提供了一定程度的逻辑独立性；
视图能够对机密数据提供安全保护。

47、 NULL 是什么意思答：NULL 这个值表示 UNKNOWN(未知)。它不表示“”(空字符串)。对 NULL 这个值的任何比较都会生产一个 NULL 值。不能把任何值与一个 NULL 值进行比较，并在逻辑上希望获得一个答案。
使用 IS NULL 来进行 NULL 判断。
48、主键、外键和索引的区别？定义：

主键：唯一标识一条记录，不能有重复的，不允许为空 
外键：表的外键是另一表的主键，外键可以有重复的，可以是空值
索引：该字段没有重复值，但可以有一个空值

作用：

主键：用来保证数据完整性
外键：用来和其他表建立联系用的
索引：是提高查询排序的速度

个数：

主键：主键只能有一个
外键：一个表可以有多个外键
索引：一个表可以有多个索引

49、你可以用什么来确保表格里的字段只接受特定范围里的值?Check 限制，它在数据库表格里被定义，用来限制输入该列的值。
触发器也可以被用来限制数据库表格里的字段能够接受的值，但是这种办法要求触发器在表格里被定义，这可能会在某些情况下影响到性能。
50、说说对 SQL 语句优化有哪些方法？（选择几条）
Where 子句中 where 表之间的连接必须写在其他 Where 条件之前，那些可以过滤掉最大数量记录的条件必须写在 Where 子句的末尾，HAVING 放在最后。
用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN。
避免在索引列上使用计算
避免在索引列上使用 IS NULL 和 IS NOT NULL
对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。

count(1)和count(*)的区别count(1) and count(字段)
两者的主要区别是
（1） count(1) 会统计表中的所有的记录数， 包含字段为null 的记录。
（2） count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即 不统计字段为null 的记录。 
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis 面试题</title>
    <url>/posts/2e4af39/</url>
    <content><![CDATA[1、解析全局配置文件的时候，做了什么？Configuration
MappedStatement
2、没有实现类，Mybatis的方法是怎么执行的？动态代理MapperProxy
3、接口方法和映射器的statement id是怎么绑定起来的？（怎么根据接口方法拿到SQL语句的？）MappedStatement
4、四大对象是什么时候创建的？openSession()方法里面

Executor

执行SQL语句的时候

StatementHandler

ParameterHandler

ResultSetHandler


5、JDK动态代理，代理能不能被代理能
6、Mybatis集成到Spring的原理是什么？SqlSessionTemplate
MapperFactoryBean
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>rabbitmq 面试题</title>
    <url>/posts/217b8ff8/</url>
    <content><![CDATA[消息堆积一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。
一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：
先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue。接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。 mq 中的消息过期失效了
假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是大量的数据会直接搞丢。
这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是批量重导，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。
假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。
mq 都快写满了
如果消息积压在mq里，你很长时间都没有处理掉，此时导致mq都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，消费一个丢弃一个，都不要了，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。
confirm机制投递消息的高延迟性绝对不能以同步写消息 + 等待ack的方式来投递消息，用来临时存放未ack消息的存储需要承载高并发写入，而且我们不需要什么复杂的运算操作，这种存储首选绝对不是MySQL之类的关系数据库，而建议采用kv存储。kv存储承载高并发能力极强，而且kv操作性能很高。
生产者消息投递出去之后并且在kv存储器存储，这个投递的线程其实就可以返回了，至于每个消息的异步回调，是通过在channel注册一个confirm监听器实现的。生产者收到一个消息ack之后，就从kv存储中删除这条临时消息；收到一个消息nack之后，就从kv存储提取这条消息然后重新投递一次即可；也可以自己对kv存储里的消息做监控，如果超过一定时长没收到ack，就主动重发消息。
异步confirm模式
Channel channel = channelManager.getPublisherChannel(namespaceName);ProxiedConfirmListener confirmListener = new ProxiedConfirmListener();//监听类confirmListener.setChannelManager(channelManager);confirmListener.setChannel(channel);confirmListener.setNamespace(namespaceName);confirmListener.addSuccessCallbacks(successCallbacks);channel.addConfirmListener(confirmListener);channel.confirmSelect();//开启confirm模式AMQP.BasicProperties messageProperties = null;if (message.getProperty() instanceof AMQP.BasicProperties) &#123;    messageProperties = (AMQP.BasicProperties) message.getProperty();&#125;confirmListener.toConfirm(channel.getNextPublishSeqNo(), rawMsg);for(int i = 0;i&lt;50;i++)&#123;    channel.basicPublish(            exchange, routingKey,            mandatory, immediate,            messageProperties,            message.getContent()    );&#125;

异步模式需要自己多写一部分复杂的代码实现，异步监听类，监听server端的通知消息，异步的好处性能会大幅度提升，发送完毕之后，可以继续发送其他消息。 MQServer通知生产端ConfirmListener监听类：用户可以继承接口实现自己的实现类，处理消息确认机制，此处继承类代码省略，就是上面 ProxiedConfirmListener 类： 下面贴下要实现的接口：
package com.rabbitmq.client;import java.io.IOException;/** * Implement this interface in order to be notified of Confirm events. * Acks represent messages handled successfully; Nacks represent * messages lost by the broker.  Note, the lost messages could still * have been delivered to consumers, but the broker cannot guarantee * this. */public interface ConfirmListener &#123;    /**    ** handleAck RabbitMQ消息接收成功的方法，成功后业务可以做的事情    ** 发送端投递消息前，需要把消息先存起来，比如用KV存储，接收到ack后删除    **/    void handleAck(long deliveryTag, boolean multiple)        throws IOException;    //handleNack RabbitMQ消息接收失败的通知方法，用户可以在这里重新投递消息    void handleNack(long deliveryTag, boolean multiple)        throws IOException;&#125;

]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 面试题</title>
    <url>/posts/9657a236/</url>
    <content><![CDATA[1、什么是 Redis?Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key-value 数据库。
Redis 与其他 key - value 缓存产品有以下三个特点：
（1）Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
（2）Redis 不仅仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。
（3）Redis 支持数据的备份，即 master-slave 模式的数据备份。
Redis 优势
（1）性能极高 – Redis 能读的速度是 110000 次&#x2F;s,写的速度是 81000 次&#x2F;s 。
（2）丰富的数据类型 – Redis 支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。
（3）原子 – Redis 的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC指令包起来。
（4）丰富的特性 – Redis 还支持 publish&#x2F;subscribe, 通知, key 过期等等特性。
Redis 与其他 key-value 存储有什么不同？
（1）Redis 有着更为复杂的数据结构并且提供对他们的原子性操作，这是一个不同于其他数据库的进化路径。Redis 的数据类型都是基于基本数据结构的同时对程序员透明，无需进行额外的抽象。
（2）Redis 运行在内存中但是可以持久化到磁盘，所以在对不同数据集进行高速读写时需要权衡内存，因为数据量不能大于硬件内存。在内存数据库方面的另一个优点是，相比在磁盘上相同的复杂的数据结构，在内存中操作起来非常简单，这样 Redis可以做很多内部复杂性很强的事情。同时，在磁盘格式方面他们是紧凑的以追加的方式产生的，因为他们并不需要进行随机访问。
2、Redis 的数据类型？Redis 支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及 zsetsorted set：有序集合)。
我们实际项目中比较常用的是 string，hash 如果你是 Redis 中高级用户，还需要加上下面几种数据结构 HyperLogLog、Geo、Pub&#x2F;Sub。
如果你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。
3、使用 Redis 有哪些好处？（1）速度快，因为数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O1)
（2）支持丰富数据类型，支持 string，list，set，Zset，hash 等
（3）支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行
（4）丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除
4、Redis 相比 Memcached 有哪些优势？（1）Memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类
（2）Redis 的速度比 Memcached 快很
（3）Redis 可以持久化其数据
5、Memcache 与 Redis 的区别都有哪些？（1）存储方式 Memecache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis 有部份存在硬盘上，这样能保证数据的持久性。
（2）数据支持类型 Memcache 对数据类型支持相对简单。 Redis 有复杂的数据类型。
（3）使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。
6、Redis 是单进程单线程的？Redis 是单进程单线程的，redis 利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销。
7、一个字符串类型的值能存储最大容量是多少？512M
8、Redis 的持久化机制是什么？各自的优缺点？Redis提供两种持久化机制 RDB 和 AOF 机制:
1、RDB Redis DataBase 持久化方式：是指用数据集快照的方式半持久化模式)记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复。
优点：
（1）只有一个文件 dump.rdb，方便持久化。
（2）容灾性好，一个文件可以保存到安全的磁盘。
（3）性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了redis的高性能)
（4）相对于数据集大时，比 AOF 的启动效率更高。
缺点：
数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候
2、AOF Append-only file 持久化方式：是指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储)保存为 aof 文件。
优点：
（1）数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次命令操作就记录到 aof 文件中一次。
（2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。
（3）AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）)
缺点：
（1）AOF 文件比 RDB 文件大，且恢复速度慢。
（2）数据集大的时候，比 rdb 启动效率低。
9、Redis 常见性能问题和解决方案：（1）Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务
（2）如果数据比较重要，某个 Slave 开启 AOF 备份数据，策略设置为每秒同步一
（3）为了主从复制的速度和连接的稳定性，Master 和 Slave 最好在同一个局域网
（4）尽量避免在压力很大的主库上增加从
（5）主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1&lt;- Slave2 &lt;- Slave3…这样的结构方便解决单点故障问题，实现 Slave 对 Master的替换。如果 Master 挂了，可以立刻启用 Slave1 做 Master，其他不变。
10、redis 过期键的删除策略？（1）定时删除：在设置键的过期时间的同时，创建一个定时器 timer。让定时器在键的过期时间来临时，立即执行对键的删除操作。
（2）惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键;如果没有过期，就返回该键。
（3）定期删除：每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。
11、Redis 的回收策略（淘汰策略）?volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据
注意这里的 6 种机制，volatile 和 allkeys 规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的 lru、ttl 以及 random 是三种不同的淘汰策略，再加上一种 no-enviction 永不回收的策略。
使用策略规则：
（1）如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 allkeys-lru
（2）如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random
12、为什么 redis 需要把所有数据放到内存中？答 ：Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘 I&#x2F;O 速度为严重影响 redis 的性能。在内存越来越便宜的今天，redis 将会越来越受欢迎。如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。
13、Redis 的同步机制了解么？Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到内存 buffer，待完成后将 rdb 文件全量同步到复制节点，复制节点接受完成后将 rdb 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。
14、Pipeline 有什么好处，为什么要用 pipeline？可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用 redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS峰值的一个重要因素是 pipeline 批次指令的数目。
15、是否使用过 Redis 集群，集群的原理是什么？（1）Redis Sentinal 着眼于高可用，在 master 宕机时会自动将 slave 提升为master，继续提供服务。
（2）Redis Cluster 着眼于扩展性，在单个 redis 内存不足时，使用 Cluster 进行分片存储。
16、Redis 集群方案什么情况下会导致整个集群不可用？有 A，B，C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。
17、Redis 支持的 Java 客户端都有哪些？官方推荐用哪个？Redisson、Jedis、lettuce 等等，官方推荐使用 Redisson。
18、Jedis 与 Redisson 对比有什么优缺点？Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持；Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。
Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。
19、Redis 如何设置密码及验证密码？设置密码：config set requirepass 123456
授权密码：auth 123456
20、说说 Redis 哈希槽的概念？Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念，Redis 集群有16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。
21、Redis 集群的主从复制模型是怎样的？为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.
22、Redis 集群会有写操作丢失吗？为什么？Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。
23、Redis 集群之间是如何复制的？异步复制
24、Redis 集群最大节点个数是多少？16384 个。
25、Redis 集群如何选择数据库？Redis 集群目前无法做数据库选择，默认在 0 数据库。
26、怎么测试 Redis 的连通性？使用 ping 命令。
27、怎么理解 Redis 事务？（1）事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。
（2）事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。
28、Redis 事务相关的命令有哪几个？MULTI、EXEC、DISCARD、WATCH
29、Redis key 的过期时间和永久有效分别怎么设置？EXPIRE 和 PERSIST 命令。
30、Redis 如何做内存优化？尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的 key，而是应该把这个用户的所有信息存储到一张散列表里面。
31、Redis 回收进程如何工作的？一个客户端运行了新的命令，添加了新的数据。Redi 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。一个新的命令被执行，等等。所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。
32、都有哪些办法可以降低 Redis 的内存使用情况呢？如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据，因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。
33、Redis 的内存用完了会发生什么？如果达到设置的上限，Redis 的写命令会返回错误信息（但是读命令还可以正常返回）。或者你可以将 Redis 当缓存来使用配置淘汰机制，当 Redis 达到内存上限时会冲刷掉旧的内容。
34、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？理论上 Redis 可以处理多达 232 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的值。任何 list、set、和 sorted set 都可以放 232 个元素。换句话说，Redis 的存储极限是系统中的可用内存值。
35、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？Redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。
相关知识：Redis 提供 6 种数据淘汰策略：
volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
no-enviction（驱逐）：禁止驱逐数据
36、Redis 最适合的场景？1、会话缓存（Session Cache）
最常用的一种使用 Redis 的情景是会话缓存（session cache）。用 Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用 Redis 来缓存会话的文档。甚至广为人知的商业平台Magento 也提供 Redis 的插件。
2、全页缓存（FPC）
除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis 实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento提供一个插件来使用 Redis 作为全页缓存后端。 此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。
3、队列
Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push&#x2F;pop 操作。 如果你快速的在 Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。
4，排行榜&#x2F;计数器
Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以，我们要从排序集合中获取到排名最靠前的 10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用 Redis 来存储数据的，你可以在这里看到。
5、发布&#x2F;订阅
最后（但肯定不是最不重要的）是 Redis 的发布&#x2F;订阅功能。发布&#x2F;订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布&#x2F;订阅的脚本触发器，甚至用 Redis 的发布&#x2F;订阅功能来建立聊天系统！
37、假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？使用 keys 指令可以扫出指定模式的 key 列表。
对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用 keys 指令会有什么问题？
这个时候你要回答 redis 关键的一个特性：redis 是单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。
38、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。
39、使用过 Redis 做异步队列么，你是怎么用的？一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？使用 pub&#x2F;sub 主题订阅者模式，可以实现1:N 的消息队列。
如果对方追问 pub&#x2F;sub 有什么缺点？
在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。
如果对方追问 redis 如何实现延时队列？
我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。
40、使用过 Redis 分布式锁么，它是什么回事？先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。
这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>spring cloud 面试题</title>
    <url>/posts/238ae934/</url>
    <content><![CDATA[1、什么是 Spring Cloud？Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。
2、使用 Spring Cloud 有什么优势？使用 Spring Boot 开发分布式微服务时，我们面临以下问题
（1）与分布式系统相关的复杂性：这种开销包括网络问题，延迟开销，带宽问题，安全问题。
（2）服务发现：服务发现工具管理群集中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。
（3）冗余：分布式系统中的冗余问题。
（4）负载平衡：负载平衡改善跨多个计算资源的工作负荷，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。
（5）性能问题：由于各种运营开销导致的性能问题。
（6）部署复杂性：Devops 技能的要求。
3、服务注册和发现是什么意思？Spring Cloud 如何实现？当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理。
4、Spring Cloud 和dubbo区别?（1）服务调用方式 dubbo是RPC springcloud Rest Api
（2）注册中心，dubbo 是zookeeper springcloud是eureka，也可以是zookeeper
（3）服务网关，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发，springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。
5、SpringBoot和SpringCloud的区别？SpringBoot专注于快速方便的开发单个个体微服务。
SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，
为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务
SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系.
SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。
6、负载平衡的意义什么？在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。
7、什么是 Hystrix？它如何实现容错？Hystrix 是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。
通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。
思考以下微服务


假设如果上图中的微服务 9 失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。
随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达 1000。这是 hystrix 出现的地方 我们将使用 Hystrix 在这种情况下的 Fallback 方法功能。我们有两个服务 employee-consumer 使用由 employee-consumer 公开的服务。
简化图如下所示


现在假设由于某种原因，employee-producer 公开的服务会抛出异常。我们在这种情况下使用 Hystrix 定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。
8、什么是 Hystrix 断路器？我们需要它吗？由于某些原因，employee-consumer 公开服务会引发异常。在这种情况下使用 Hystrix 我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。


如果 firstPage method() 中的异常继续发生，则 Hystrix 电路将中断，并且员工使用者将一起跳过 firtsPage 方法，并直接调用回退方法。 断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。


9、什么是 Netflix Feign？它的优点是什么？Feign 是受到 Retrofit，JAXRS-2.0 和 WebSocket 启发的 java 客户端联编程序。
Feign 的第一个目标是将约束分母的复杂性统一到 http apis，而不考虑其稳定性。
在 employee-consumer 的例子中，我们使用了 employee-producer 使用 REST 模板公开的 REST 服务。
但是我们必须编写大量代码才能执行以下步骤
（1）使用功能区进行负载平衡。
（2）获取服务实例，然后获取基本 URL。
（3）利用 REST 模板来使用服务。 前面的代码如下
@Controllerpublic class ConsumerControllerClient &#123;    @Autowired    private LoadBalancerClient loadBalancer;    public void getEmployee() throws RestClientException， IOException &#123;        ServiceInstance serviceInstance=loadBalancer.choose(&quot;employee-producer&quot;);        System.out.println(serviceInstance.getUri());        String baseUrl=serviceInstance.getUri().toString();        baseUrl=baseUrl+&quot;/employee&quot;;        RestTemplate restTemplate = new RestTemplate();        ResponseEntity&lt;String&gt; response=null;        try&#123;            response=restTemplate.exchange(baseUrl，                        HttpMethod.GET， getHeaders()，String.class);        &#125;        catch (Exception ex)            &#123;            System.out.println(ex);        &#125;        System.out.println(response.getBody());    &#125;

之前的代码，有像 NullPointer 这样的例外的机会，并不是最优的。我们将看到如何使用 Netflix Feign 使呼叫变得更加轻松和清洁。如果 Netflix Ribbon 依赖关系也在类路径中，那么 Feign 默认也会负责负载平衡。
10、什么是 Spring Cloud Bus？我们需要它吗？考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而Spring Cloud Config 从 GIT 读取这些属性。
下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注册的财产。


如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。
还有另一种使用执行器端点&#x2F;刷新的方式。但是我们将不得不为每个模块单独调用这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http://localhost:8080/refresh。同样对于 Employee Producer2 http://localhost:8081/refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。


Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点&#x2F;总线&#x2F;刷新来实现对任何单个实例的刷新。
11、springcloud 断路器的作用当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应 当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）
断路器有完全打开状态:一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务
半开：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭
关闭：当服务一直处于正常状态 能正常调用
12、什么是SpringCloud Config?在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。
使用：
（1）添加pom依赖
（2）配置文件添加相关配置
（3）启动类添加注解@EnableConfigServer
13、Spring Cloud Gateway?Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。
使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。
14、dubbo是什么
dubbo是一个分布式的服务框架，致力于提高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。
简言之，dubbo就是一个服务框架，如果没有分布式的需求，其实不需要用的，只有分布式的时候，才需要dubbo这样的分布式框架
本质里，dubbo就是个服务调用的东东。。
说白了就是个远程服务调用的分布式框架(告别webservice模式中的wsdl，以服务者与消费者的方式在dubbo上注册)
dubbo可以和spring无缝集成
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper 面试题</title>
    <url>/posts/3647b27d/</url>
    <content><![CDATA[Zookeeper 工作原理Zookeeper 的核心是原子广播，这个机制保证了各个 Server 之间的同步。实现这个机制的协议叫做 Zab 协 议。Zab 协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃 后，Zab 就进入了恢复模式，当领导者被选举出来，且大多数 Server 完成了和 leader 的状态同步以后，恢复模式就结束了。状态同步保证了 leader 和 Server 具有相同的系统状态。
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>查缺补漏</title>
    <url>/posts/d7158ead/</url>
    <content><![CDATA[SpringMVC执行流程:
用户发送请求至前端控制器DispatcherServlet

DispatcherServlet收到请求调用处理器映射器HandlerMapping。

处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。

DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作

执行处理器Handler(Controller，也叫页面控制器)。

Handler执行完成返回ModelAndView

HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet

DispatcherServlet将ModelAndView传给ViewResolver视图解析器

ViewResolver解析后返回具体View

DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。

DispatcherServlet响应用户。


spring的反射有什么问题java的反射破坏了封装，性能也是一个问题；反射不能用jit加速。
springboot启动过程@SpringBootConfiguration 通过与 @Bean 结合完成Bean的 JavaConfig配置；
@ComponentScan 通过范围扫描的方式，扫描特定注解注释的类，将其注册到Spring容器；
@EnableAutoConfiguration 通过 spring.factories 的配置，并结合 @Condition 条件，完成bean的注册；
@Import 通过导入的方式，将指定的class注册解析到Spring容器；


我们将各步骤总结精炼如下：

通过 SpringFactoriesLoader 加载 META-INF/spring.factories 文件，获取并创建 SpringApplicationRunListener 对象
然后由 SpringApplicationRunListener 来发出 starting 消息
创建参数，并配置当前 SpringBoot 应用将要使用的 Environment
完成之后，依然由 SpringApplicationRunListener 来发出 environmentPrepared 消息
创建 ApplicationContext
初始化 ApplicationContext，并设置 Environment，载相关配置等
由 SpringApplicationRunListener 来发出 contextPrepared 消息，告知SpringBoot 应用使用的 ApplicationContext 已准备OK
将各种 beans 装载入 ApplicationContext，继续由 SpringApplicationRunListener 来发出 contextLoaded 消息，告知 SpringBoot 应用使用的 ApplicationContext 已装填OK
refresh ApplicationContext，完成IoC容器可用的最后一步
由 SpringApplicationRunListener 来发出 started 消息
完成最终的程序的启动
由 SpringApplicationRunListener 来发出 running 消息，告知程序已运行起来了

问：Spring Boot Starter 的工作原理是什么？答：Spring Boot 在启动的时候会干这几件事情：

① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources&#x2F;META-INF&#x2F;spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。
② 根据 spring.factories 配置加载 AutoConfigure 类
③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context

1、Spring Boot 的自动配置是如何实现的？Spring Boot 项目的启动注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：

@Configuration
@ComponentScan
@EnableAutoConfiguration

其中 @EnableAutoConfiguration 是实现自动配置的入口，该注解又通过 @Import 注解导入了AutoConfigurationImportSelector，在该类中加载 META-INF&#x2F;spring.factories 的配置信息。然后筛选出以 EnableAutoConfiguration 为 key 的数据，加载到 IOC 容器中，实现自动配置功能！
21、描述一下JVM加载class文件的原理机制？答：JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。
由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。
类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：
​    Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；
​    Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；
​    System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。
Comparable和Comparator接口是干什么的，其区别Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。
Comparator位于包java.util下，而Comparable位于包 java.lang下 Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer 自己就可以完成比较大小操作，已经实现了Comparable接口） 自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序， 这里的自然顺序就是实现Comparable接口设定的排序方式。 
而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。 可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。 
用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。 比如：你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类（实际上你也不能这么做）去改变它的排序行为，只要使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。
分布式Session的几种实现方式
session复制：在支持session复制的服务器上进行，同步session，保持session一致
方案：tomcat-redis-session-manager

session粘滞：强行分发session到各个服务器
方案：负载均衡

cookie存储session：把sessionid存储到cookie中(不安全，cookie容易被盗取，可以存储不重要的数据)

session集中管理：把用户的session存储在单台或者集群服务器的缓存中，所有web服务器从中拿取session，实现session共享
方案：Redis存储用户生成的sessionId或者存储保存sessionId的cookie


Mybatis的mapper文件中resultType和resultMap的区别。1、查询结果为Map时，使用resultType;
2、简单查询且结果为Pojo类，也可以使用resultType,另外，查询字段名与Pojo属性名不一致，可以通过使用别名的方式；
3、复杂的映射或级联，可以使用resultMap;
Spring中七种事务传播行为


事务传播行为类型
说明



PROPAGATION_REQUIRED
如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。


PROPAGATION_SUPPORTS
支持当前事务，如果当前没有事务，就以非事务方式执行。


PROPAGATION_MANDATORY
使用当前的事务，如果当前没有事务，就抛出异常。


PROPAGATION_REQUIRES_NEW
新建事务，如果当前存在事务，把当前事务挂起。


PROPAGATION_NOT_SUPPORTED
以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。


PROPAGATION_NEVER
以非事务方式执行，如果当前存在事务，则抛出异常。


PROPAGATION_NESTED
如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。


REQUIRED,REQUIRES_NEW,NESTED异同NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。但是REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，外围方法事务也将被回滚。而NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。
NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。
nginx负载均衡的5种策略轮询（默认）upstream backserver &#123;    server 192.168.0.14;    server 192.168.0.15;&#125;

weightupstream backserver &#123;    server 192.168.0.14 weight=3;    server 192.168.0.15 weight=7;&#125;

ip_hashupstream backserver &#123;    ip_hash;    server 192.168.0.14:88;    server 192.168.0.15:80;&#125;

fair按后端服务器的响应时间来分配请求，响应时间短的优先分配。
upstream backserver &#123;    server server1;    server server2;    fair;&#125;

url_hashupstream backserver &#123;    server squid1:3128;    server squid2:3128;    hash $request_uri;    hash_method crc32;&#125;

spring是如何解决循环依赖的？构造器的循环依赖：这种依赖spring是处理不了的，直接抛出BeanCurrentlylnCreationException异常。 
单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。 

singletonObjects &#x2F;&#x2F; 一级缓存
earlySingletonObjects &#x2F;&#x2F; 二级缓存
singletonFactories &#x2F;&#x2F; 三级缓存

非单例循环依赖：无法处理。
幂等性实现方案乐观锁如果只是更新已有的数据，没有必要对业务进行加锁，设计表结构时使用乐观锁，一般通过version来做乐观锁，这样既能保证执行效率，又能保证幂等。
防重表使用订单号 orderNo 做为去重表的唯一索引，每次请求都根据订单号向去重表中插入一条数据。第一次请求查询订单支付状态，订单没有支付，进行支付操作，无论成功与否，执行完后更新订单状态为成功或失败，删除去重表中的数据。后续的订单因为表中唯一索引而插入失败，则返回操作失败，直到第一次的请求完成（成功或失败）。


分布式锁对于防重表可以用分布式锁代替，比如 Redis 和 Zookeeper
Redis

订单发起支付请求，支付系统会去 Redis 缓存中查询是否存在该订单号的 Key，如果不存在，则向 Redis 增加 Key 为订单号
查询订单支付状态，如果未支付，则进行支付流程，支付完成后删除该订单号的 key

Zookeeper

订单发起支付请求，支付系统会去 Zookeeper 中创建一个 node，如果创建失败，则表示订单已经被支付
如果创建成功，则进行支付流程，支付完成后删除 node

Token 机制这种方式分成两个阶段：申请 Token 阶段和支付阶段。 第一阶段，在进入到提交订单页面之前，需要订单系统根据用户信息向支付系统发起一次申请 Token 的请求，支付系统将 Token 保存到 Redis 缓存中，为第二阶段支付使用。 第二阶段，订单系统拿着申请到的 Token 发起支付请求，支付系统会检查 Redis 中是否存在该 Token ，如果存在，表示第一次发起支付请求，删除缓存中 Token 后开始支付逻辑处理；如果缓存中不存在，表示非法请求。
消息队列缓冲将订单的支付请求全部发送到消息队列中，然后使用异步任务处理队列中的数据，过滤掉重复的待支付订单，再进行支付流程。
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>查缺补漏</tag>
      </tags>
  </entry>
  <entry>
    <title>面试单题</title>
    <url>/posts/1f03d757/</url>
    <content><![CDATA[基础1、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。
2、抽象类必须要有抽象方法吗？不需要，抽象类不一定非要有抽象方法，以下为示例代码：
abstract class Cat &#123;    public static void sayHi() &#123;        System.out.println(&quot;hi~&quot;);    &#125;&#125;

3、抽象类能使用 final 修饰吗不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类。
4、接口和抽象类的区别



接口
抽象类



实现
接口必须使用 implements 来实现接口
抽象类的子类使用 extends 来继承


构造函数
无
可以有


main 方法
无
可以有


实现数量
多个
单个


访问修饰符
方法默认public修饰
方法可以是任意访问修饰符（除了private）


5、java 中 IO 流分为几种按功能来分：输入流（input）、输出流（output）。
按类型来分：字节流和字符流。
字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。
6、BIO、NIO、AIO 有什么区别
BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。
NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。
AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。

7、Files的常用方法都有哪些？
Files.exists()：检测文件路径是否存在。
Files.createFile()：创建文件。
Files.createDirectory()：创建文件夹。
Files.delete()：删除一个文件或目录。
Files.copy()：复制文件。
Files.move()：移动文件。
Files.size()：查看文件个数。
Files.read()：读取文件。
Files.write()：写入文件。

容器1、java容器都有哪些

2、Collection 和 Collections 有什么区别
java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。
Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。

3、List、Set、Map 之间的区别是什么

4、HashMap 和 Hashtable 有什么区别
hashMap去掉了HashTable 的contains方法，但是保留了containsValue()和containsKey()方法。
hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。
hashMap允许空键值，而hashTable不允许。

5、HashMap,LinkedHashMap,TreeMap的区别HashMap
Map主要用于存储健值对，根据键得到值，因此不允许键重复,但允许值重复。
Hashmap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。
HashMap最多只允许一条记录的键为Null，允许多条记录的值为 Null。
HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。

LinkedHashMapLinkedHashMap是HashMap子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。
TreeMapTreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。
6、HashMap底层实现原理概述HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。 
HashMap数据结构HashMap实际是一种“数组+链表”数据结构。在put操作中，通过内部定义算法寻止找到数组下标，将数据直接放入此数组元素中，若通过算法得到的该数组元素已经有了元素（俗称hash冲突，链表结构出现的实际意义也就是为了解决hash冲突的问题）。将会把这个数组元素上的链表进行遍历，将新的数据放到链表末尾。


当我们往Hashmap中put元素时，首先根据key的hashcode重新计算hash值，根绝hash值得到这个元素在数组中的位置(下标)，如果该数组在该位置上已经存放了其他元素，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放入链尾。如果数组中该位置没有元素，就直接将该元素放到数组的该位置上。

需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)

7、HashSet 的实现原理
HashSet底层由HashMap实现
HashSet的值存放于HashMap的key上
HashMap的value统一为PRESENT

8、Array 和 ArrayList 有何区别？
Array可以容纳基本类型和对象，而ArrayList只能容纳对象。 
Array是指定大小的，而ArrayList大小是固定的。 
Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。

9、在 Queue 中 poll()和 remove()有什么区别？poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。
10、Iterator 和 ListIterator 有什么区别？
Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

多线程1、线程池中 submit()和 execute()方法有什么区别？
接收的参数不一样
submit有返回值，而execute没有
submit方便Exception处理

2、在 java 程序中怎么保证多线程的运行安全？线程安全在三个方面体现：

原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）
可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）
有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）

3、什么是死锁？死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。
怎么防止死锁？死锁的四个必要条件：

互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源
请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放
不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放
环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。
理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。
所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。
此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。
4、synchronized 和 volatile 的区别是什么？
volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。
volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。
volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。

5、synchronized 和 Lock 有什么区别？
首先synchronized是java内置关键字，在jvm层面，Lock是个java类；
synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；
synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；
用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；
synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；
Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。

6、synchronized 和 ReentrantLock 区别是什么？synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： 

ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 
ReentrantLock可以获取各种锁的信息
ReentrantLock可以灵活地实现多路通知

另外，二者的锁机制其实也是不一样的：ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word。
反射1、什么是反射？反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力
Java反射：
在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法
Java反射机制主要提供了以下功能：

在运行时判断任意一个对象所属的类。
在运行时构造任意一个类的对象。
在运行时判断任意一个类所具有的成员变量和方法。
在运行时调用任意一个对象的方法。

2、什么是 java 序列化？什么情况下需要序列化？简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。
什么情况下需要序列化：

当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；
当你想用套接字在网络上传送对象的时候；
当你想通过RMI传输对象的时候；

3、动态代理是什么？有哪些应用？动态代理：
当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。
动态代理的应用：

Spring的AOP
加事务
加权限
加日志

4、JDK和CGLIB动态代理原理

1、JDK动态代理利用拦截器(拦截器必须实现InvocationHanlder)加上反射机制生成一个实现代理接口的匿名类，
在调用具体方法前调用InvokeHandler来处理。
2、CGLIB动态代理利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
3、何时使用JDK还是CGLIB？
如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP。
如果目标对象实现了接口，可以强制使用CGLIB实现AOP。
如果目标对象没有实现了接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换。

4、如何强制使用CGLIB实现AOP？
添加CGLIB库(aspectjrt-xxx.jar、aspectjweaver-xxx.jar、cglib-nodep-xxx.jar)
在Spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;”true”&#x2F;&gt;

5、JDK动态代理和CGLIB字节码生成的区别？
JDK动态代理只能对实现了接口的类生成代理，而不能针对类。
CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成final，对于final类或方法，是无法继承的。

6、CGlib比JDK快？
使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。
在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。

7、Spring如何选择用JDK还是CGLIB？
当Bean实现接口时，Spring就会用JDK的动态代理。
当Bean没有实现接口时，Spring使用CGlib是实现。
可以强制使用CGlib（在spring配置中加入&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;”true”&#x2F;&gt;）。

总结JDK代理是不需要第三方库支持，只需要JDK环境就可以进行代理，使用条件:

实现InvocationHandler 

使用Proxy.newProxyInstance产生代理对象

被代理的对象必须要实现接口


CGLib必须依赖于CGLib的类库，但是它需要类来实现任何接口代理的是指定的类生成一个子类，覆盖其中的方法，是一种继承但是针对接口编程的环境下推荐使用JDK的代理；
5、深拷贝和浅拷贝区别是什么？
浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）
深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）

异常1、throw 和 throws 的区别？throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。
2、final、finally、finalize 有什么区别？
final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾

3、try-catch-finally 中哪个部分可以省略？答：catch 可以省略
原因：更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。
理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。
至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。
4、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？答：会执行，在 return 前执行。
网络1、http 响应码 301 和 302 代表的是什么？有什么区别？答：301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。
区别： 

301 redirect: 301 代表永久性转移(Permanently Moved)。
302 redirect: 302 代表暂时性转移(Temporarily Moved )。

2、简述 tcp 和 udp的区别？
TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。
TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。
TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。
UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。
每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。
TCP对系统资源要求较多，UDP对系统资源要求较少。

3、tcp 为什么要三次握手，两次不行吗？为什么？为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。
如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。
4、说一下 tcp 粘包是怎么产生的？①. 发送方产生粘包
采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。


②. 接收方产生粘包
接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度） 


5、OSI 的七层模型都有哪些？
应用层：网络服务与最终用户的一个接口。
表示层：数据的表示、安全、压缩。
会话层：建立、管理、终止会话。
传输层：定义传输数据的协议端口号，以及流控和差错校验。
网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。
数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。
物理层：建立、维护、断开物理连接。

6、get 和 post 请求有哪些区别？
GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST没有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中。

7、说一下 JSONP 实现原理？jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返货json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。
8、如何实现跨域？
方式一：图片ping或script标签跨域
图片ping常用于跟踪用户点击页面或动态广告曝光次数。script标签可以得到从其他来源数据，这也是JSONP依赖的根据。 

方式二：JSONP跨域
JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 &lt;script&gt;元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有，通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。

方式三：CORS
Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种：
&quot;Access-Control-Allow-Credentials&quot;: true// Ajax设置&quot;withCredentials&quot;: true

方式四：window.name+iframe
window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。

iframe标签的跨域能力；
window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。

每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。
&lt;!--  下述用端口  10000表示：domainA 10001表示：domainB--&gt; &lt;!-- localhost:10000 --&gt;&lt;script&gt;  var iframe = document.createElement(&#x27;iframe&#x27;);  iframe.style.display = &#x27;none&#x27;; // 隐藏   var state = 0; // 防止页面无限刷新  iframe.onload = function() &#123;      if(state === 1) &#123;          console.log(JSON.parse(iframe.contentWindow.name));          // 清除创建的iframe          iframe.contentWindow.document.write(&#x27;&#x27;);          iframe.contentWindow.close();          document.body.removeChild(iframe);      &#125; else if(state === 0) &#123;          state = 1;          // 加载完成，指向当前域，防止错误(proxy.html为空白页面)          // Blocked a frame with origin &quot;http://localhost:10000&quot; from accessing a cross-origin frame.          iframe.contentWindow.location = &#x27;http://localhost:10000/proxy.html&#x27;;      &#125;  &#125;;   iframe.src = &#x27;http://localhost:10001&#x27;;  document.body.appendChild(iframe);&lt;/script&gt; &lt;!-- localhost:10001 --&gt;&lt;!DOCTYPE html&gt;...&lt;script&gt;  window.name = JSON.stringify(&#123;a: 1, b: 2&#125;);&lt;/script&gt;&lt;/html&gt;

方式五：window.postMessage()
HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。
方式六：修改document.domain跨子域
前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域
在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。
方式七：WebSocket
WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。
需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。
方式八：代理
同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题
DomainA客户端（浏览器） &#x3D;&#x3D;&gt; DomainA服务器 &#x3D;&#x3D;&gt; DomainB服务器 &#x3D;&#x3D;&gt; DomainA客户端（浏览器）
Spring &#x2F; Spring MVC1、解释一下什么是 ioc？IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。  IoC 在其他语言中也有应用，并非 Spring 特有。 IoC 容器是 Spring 用来实现 IoC 的载体，IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。
将对象之间的相互依赖关系交给 IOC 容器来管理，并由 IOC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。
Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。
Spring IOC的初始化过程：




IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：


大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。
2、spring 有哪些主要模块？Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问&#x2F;集成、Web、AOP（面向切面编程）、工具、消息和测试模块。


3、spring 常用的注入方式有哪些？Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：

构造方法注入
setter注入
基于注解的注入

4、spring 支持几种 bean 的作用域？当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：

singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例
prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例
request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效
session：对于每次HTTP Session，使用session定义的Bean都将产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效
globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效

其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。
如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。
5、Spring 中的单例 bean 的线程安全问题了解吗？大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。
常见的有两种解决办法：

在Bean对象中尽量避免定义可变的成员变量（不太现实）。
在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。

6、说一下 spring 的事务隔离级别？事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：

脏读：一个事务读到另一个事务未提交的更新数据。
幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。
不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。

7、Spring 事务中的隔离级别有哪几种?TransactionDefinition 接口中定义了五个表示隔离级别的常量：

TransactionDefinition.ISOLATION_DEFAULT:使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.
TransactionDefinition.ISOLATION_READ_UNCOMMITTED:最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读
TransactionDefinition.ISOLATION_READ_COMMITTED:允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生
TransactionDefinition.ISOLATION_REPEATABLE_READ:对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
TransactionDefinition.ISOLATION_SERIALIZABLE:最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。

8、Spring 事务中哪七种事务传播行为?支持当前事务的情况：

TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）

不支持当前事务的情况：

TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。

其他情况：

TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。

9、说一下 spring mvc 运行流程？Spring MVC运行流程图：


Spring运行流程描述：

用户向服务器发送请求，请求被Spring前端控制Servlet DispatcherServlet捕获；

DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；

DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）

提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：

HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息

数据转换：对请求消息进行数据转换。如String转换成Integer、Double等

数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等

数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中



Handler执行完成后，向DispatcherServlet返回一个ModelAndView对象；

根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；

ViewResolver结合Model和View，来渲染视图；

将渲染结果返回给客户端。


10、spring mvc 有哪些组件？Spring MVC的核心组件：

DispatcherServlet：中央控制器，把请求给转发到具体的控制类
Controller：具体处理请求的控制器
HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略
ModelAndView：服务层返回的数据和视图层的封装类
ViewResolver：视图解析器，解析具体的视图
Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作

11、Spring AOP 和 AspectJ AOP 有什么区别？Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。
Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，
如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ，它比Spring AOP 快很多。
12、Spring 中的 bean 生命周期?中文版本图


英文版本图



Bean 容器找到配置文件中 Spring Bean 的定义。
Bean 容器利用 Java Reflection API 创建一个Bean的实例。

如果涉及到一些属性值 利用 set()方法设置一些属性值。

如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。
如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。
如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader 对象的实例。
与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。

如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法

如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。

如果 Bean 在配置文件中的定义包含  init-method 属性，执行指定的方法。

如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法

当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。
当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。


13、@Component 和 @Bean 的区别是什么？
作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。
@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的示例，当我需要用它的时候还给我。
@Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。

14、将一个类声明为Spring的 bean 的注解有哪些?我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：

@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于拿个层，可以使用@Component 注解标注。
@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。
@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。
@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。

15、区分 BeanFactory 和 ApplicationContext

16、@Required 注解有什么用？@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。
public class Employee &#123;	private String name;	@Required	public void setName(String name)&#123;		this.name=name;	&#125;	public string getName()&#123;		return name;	&#125;&#125;

17、@Autowired 注解有什么用？@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配bean。默认情况下，它是类型驱动的注入。
public class Employee &#123;	private String name;	@Autowired	public void setName(String name) &#123;		this.name=name;	&#125;	public string getName()&#123;		return name;	&#125;&#125;

18、@Qualifier 注解有什么用？当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean来消除歧义。 例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。 
Employee.java
public class Employee &#123;	private String name;	@Autowired	public void setName(String name) &#123;		this.name=name;	&#125;	public string getName() &#123;		return name;	&#125;&#125;

EmpAccount.java
public class EmpAccount &#123;	private Employee emp;    	@Autowired	@Qualifier(emp1)	public void showName() &#123;		System.out.println(“Employee name : ”+emp.getName);	&#125;&#125;

19、列举 Spring DAO 抛出的异常。

20、spring JDBC API 中存在哪些类？
JdbcTemplate 
SimpleJdbcTemplate 
NamedParameterJdbcTemplate 
SimpleJdbcInsert 
SimpleJdbcCall

21、列举 spring 支持的事务管理类型Spring 支持两种类型的事务管理：

程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。
声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML的配置来管理事务。

22、spring 支持哪些 ORM 框架
Hibernate
iBatis 
JPA
JDO 
OJB

23、指出在 spring aop 中 concern 和 cross-cuttingconcern 的不同之处。concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。
cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。
24、AOP 有哪些实现方式？实现 AOP 的技术，主要分为两大类：
静态代理 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；

编译时编织（特殊编译器实现）
类加载时编织（特殊的类加载器实现）。

动态代理 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。

JDK 动态代理 
CGLIB

25、如何理解 Spring 中的代理？将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。 Advice + Target Object &#x3D; Proxy
26、介绍一下 WebApplicationContextWebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。
27、Bean 工厂和 Application contexts 有什么区别？Application contexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行的那些不得不由 bean 工厂以程序化方式处理的操作，可以在Application contexts 中以声明的方式处理。
Application contexts 实现了 MessageSource 接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。
28、自动装配有哪些局限性 ?自动装配的局限性是：

重写：你仍需用配置来定义依赖，意味着总要重写自动装配。
基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。
模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。

29、你可以在 Spring 中注入一个 null 和一个空字符串吗？可以。
30、有几种不同类型的自动代理？
BeanNameAutoProxyCreator
DefaultAdvisorAutoProxyCreator
Metadata autoproxying

拦截器和过滤器的区别过滤器（filter）：

过滤器处于客户端与Web资源（Servlet、JSP、HTML）之间，客户端与Web资源之间的请求和响应都要通过过滤器进行过滤。举例：在过滤器中定义了禁止访问192.10.10.1这个地址，那么当客户端发出访问192.10.10.1的请求时，经过过滤器后，客户端得到的响应是出现该IP禁止访问的提示。
在java web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的 action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者 struts的action前统一设置字符集，或者去除掉一些非法字符

**拦截器（interceptor）:**，

拦截器是一种面向方面&#x2F;切面编程（AOP Aspect-Oriented Programming）.
面向切面就是将多个模块的的通用服务进行分离，如权限管理、日志服务，他们在多个模块中都会用到，就可以将其各自封装为一个可重用模块。而这些通用服务的具体实现是通过拦截器来完成，比如用户客户端访问一些保密模块都应先通过权限审查的拦截器来进行权限审查，确定用户是否具有该项操作的权限后方能向下执行。
在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。

两者的区别

拦截器是基于java反射机制的，而过滤器是基于函数回调。
拦截器不依赖于Servlet容器，而过滤器依赖于servlet容器。
拦截器只能对action请求起作用，而过滤器可以对几乎所以的请求起作用。
拦截器可以访问action上下文，值栈里的对象，而过滤器不能。
在Action的生命周期周，拦截器可以被多次调用，而过滤器只能在容器初始化的时候被调用一次。

执行顺序 ：过滤前 - 拦截前 - Action处理 - 拦截后 - 过滤后。个人认为过滤是一个横向的过程，首先把客户端提交的内容进行过滤(例如未登录用户不能访问内部页面的处理)；过滤通过后，拦截器将检查用户提交数据的验证，做一些前期的数据处理，接着把处理后的数据发给对应的Action；Action处理完成返回后，拦截器还可以做其他过程(还没想到要做啥)，再向上返回到过滤器的后续操作。
拦截器 ：是在面向切面编程的就是在你的service或者一个方法前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。
过滤器：是在java web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的 action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者 struts的action前统一设置字符集，或者去除掉一些非法字符.
Java 中，嵌套公共静态类与顶级类有什么不同？类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。
Java 中，Serializable 与 Externalizable 的区别？Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。
Java 中，DOM 和 SAX 解析器有什么不同？DOM 解析器将整个 XML 文档加载到内存来创建一棵 DOM 模型树，这样可以更快的查找节点和修改 XML 结构，而 SAX 解析器是一个基于事件的解析器，不会将整个 XML 文档加载到内存。由于这个原因，DOM 比 SAX 更快，也要求更多的内存，不适合于解析大 XML 文件。
说出 JDK 1.7 中的三个新特性？虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如

try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。
Fork-Join 池某种程度上实现 Java 版的 Map-reduce。
允许 Switch 中有 String 变量和文本。
菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。
另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。

说出 5 个 JDK 1.8 引入的新特性？Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：

Lambda 表达式,允许像对象一样传递匿名函数
Stream API,充分利用现代多核 CPU，可以写出很简洁的代码
Date 与 Time API,最终，有一个稳定、简单的日期和时间库可供你使用
扩展方法，现在，接口中可以有静态、默认方法。
重复注解，现在你可以将相同的注解在同一类型上使用多次。

8、&amp;和&amp;&amp;的区别？&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。
区别：

&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式以及后面的表达式。(如果遇到true就一直向下判断条件直到遇到false的表达式返回)

&amp;不具有短路的功能,逻辑运算表达式条件都会执行。


9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。
11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？switch可作用于char byte short int
switch可作用于char byte short int对应的包装类
switch不可作用于long double float boolean，包括他们的包装类
13、数组有没有 length()方法？String 有没有 length()方法？数组没有length()这个方法，有length的属性。String有length()这个方法。
int a[];a.length; //返回a的长度String s;s.length(); //返回s的长度

14、在 Java 中，如何跳出当前的多重嵌套循环？一、标号方式在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号break语句，即可跳出外层循环。
例如：
ok:for (int i = 0; i &lt; 10; i++) &#123;    for (int j = 0; j &lt; 10; j++) &#123;        System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);        if (j == 5) break ok;    &#125;&#125;

二、break跳出当前循环，通过内部跳出条件控制跳出外部循环
for (int i = 0; i &lt; 4; i++) &#123;    for (int j = 0; j &lt; 5; j++) &#123;        System.out.println(&quot;i=&quot; + i + &quot;; j=&quot; + j);        if (j == 3) &#123;            i = 4;            break;        &#125;    &#125;&#125;

三、抛出异常也可以跳出多重循环
try &#123;    for (int i = 0; i &lt; 4; i++) &#123;        for (int j = 0; j &lt; 5; j++) &#123;            System.out.println(&quot;i=&quot; + i + &quot;; j=&quot; + j);            if (j == 3) &#123;                throw new Exception();            &#125;        &#125;    &#125;&#125; catch (Exception e) &#123;    System.out.println(&quot;e&quot;);&#125;

通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。
int arr[][] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6, 7&#125;, &#123;9&#125;&#125;;boolean found = false;for (int i = 0; i &lt; arr.length &amp;&amp; !found; i++) &#123;    for (int j = 0; j &lt; arr[i].length; j++) &#123;        System.out.println(&quot;i=&quot; + i + &quot;,j=&quot; + j);        if (arr[i][j] == 5) &#123;            found = true;            break;        &#125;    &#125;&#125;

18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？是值传递。Java编程语言中只有由值传递参数的。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。
19、String 和 StringBuilder、StringBuffer 的区别？都是final类，都不允许被继承；
String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；
StringBuffer类是线程安全的，StringBuilder不是线程安全的。
20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。
重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；
重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。
重载对返回类型没有特殊的要求。
21、描述一下 JVM 加载 class 文件的原理机制？Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。
类装载方式，有两种：

隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，
显式装载：通过调用ClassLoader加载class对象，比如Class.forName(String name)和this.getClass().getClassLoader().loadClass()加载类。

Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。
Java的类加载器有三个，对应Java的三种类:

Bootstrap Loader  ：启动类加载器，是虚拟机自身的一部分。负责将存放在\lib目录中的类库加载到虚拟机中。其无法被Java程序直接引用。 负责加载系统类 (指的是内置类，像是String，对应于C#中的System类和C&#x2F;C++标准库中的类)
ExtClassLoader  ： 负责加载扩展类(就是继承类和实现类)
AppClassLoader  ：负责加载用户类路径（ClassPath）上所指定的类库(程序员自定义的类)

三个加载器各自完成自己的工作，但它们是如何协调工作呢？哪一个类该由哪个类加载器完成呢？为了解决这个问题，Java采用了委托模型机制。
委托模型机制的工作原理很简单：当类加载器需要加载类的时候，先请示其Parent(即上一层加载器)在其搜索路径载入，如果找不到，才在自己的搜索路径搜索该类。这样的顺序其实就是加载器层次上自顶而下的搜索，因为加载器必须保证基础类的加载。之所以是这种机制，还有一个安全上的考虑：如果某人将一个恶意的基础类加载到jvm，委托模型机制会搜索其父类加载器，显然是不可能找到的，自然就不会将该类加载进来。
我们可以通过这样的代码来获取类加载器:
ClassLoader loader = ClassName.class.getClassLoader();ClassLoader ParentLoader = loader.getParent();

注意一个很重要的问题，就是Java在逻辑上并不存在BootstrapKLoader的实体！因为它是用C++编写的，所以打印其内容将会得到null。
前面是对类加载器的简单介绍，它的原理机制非常简单，就是下面几个步骤:

装载：查找和导入class文件;
连接：
检查：检查载入的class文件数据的正确性;
准备：为类的静态变量分配存储空间;
解析：将符号引用转换成直接引用(这一步是可选的)
初始化：初始化静态变量，静态代码块。这样的过程在程序调用类的静态成员的时候开始执行，所以静态方法main()才会成为一般程序的入口方法。类的构造器也会引发该动作。

22、char 型变量中能不能存贮一个中文汉字，为什么？在Java中，char类型占2个字节，而且Java默认采用Unicode编码，一个Unicode码是16位，所以一个Unicode码占两个字节，Java中无论汉字还是英文字母都是用Unicode编码来表示的。所以，在Java中，char类型变量可以存储一个中文汉字。
24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。
而通常的内部类(Inner Class)需要在外部类实例化后才能实例化。
25、Java 中会存在内存泄漏吗，请简单描述。内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。Java使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的
java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。
举个例子：

如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。

当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。


26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰？都不能。
抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。
本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。
synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。
27、阐述静态变量和实例变量的区别。在语法定义上的区别：
静态变量前要加static关键字，而实例变量前则不加。
在程序运行时的区别：
实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。
静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。
总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。
28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？不可以。
静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。
29、如何实现对象克隆？两种不同的克隆方法，浅克隆(ShallowClone)和深克隆(DeepClone)。
在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。

浅克隆
在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。


在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆。
深克隆
在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。


在Java语言中，如果需要实现深克隆，可以通过覆盖Object类的clone()方法实现，也可以通过序列化(Serialization)等方式来实现。

克隆有两种方式：

实现Cloneable接口并重写Object类中的clone()方法；


clone()方法是定义在java.lang.Object类中，该方法是一个protected的方法，所以重载时要把clone()方法的属性设置为public，这样其它类才能调用这个clone类的clone()方法
实现Cloneable接口：Cloneable接口是不包含任何方法的！其实这个接口仅仅是一个标志，而且这个标志也仅仅是针对Object类中clone()方法的，如果clone类没有实现Cloneable接口，并调用了Object的clone()方法（也就是调用了super.Clone()方法），那么Object的clone()方法就会抛出 CloneNotSupportedException异常。


实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆；

30、GC 是什么？为什么要有 GC？GC是垃圾收集的意思（Gabage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。
GC是垃圾收集器。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：

System.gc()
Runtime.getRuntime().gc()

Java是由C++发展来的。
它摈弃了C++中一些繁琐容易出错的东西。其中有一条就是这个GC。
写C&#x2F;C++程序，程序员定义了一个变量，就是在内存中开辟了一段相应的空间来存值。内存再大也是有限的，所以当程序不再需要使用某个变量的时候，就需要释放这个内存空间资源，好让别的变量来用它。在C&#x2F;C++中，释放无用变量内存空间的事情要由程序员自己来解决。就是说当程序员认为变量没用了，就应当写一条代码，释放它占用的内存。这样才能最大程度地避免内存泄露和资源浪费。
但是这样显然是非常繁琐的。程序比较大，变量多的时候往往程序员就忘记释放内存或者在不该释放的时候释放内存了。而且释放内存这种事情，从开发角度说，不应当是程序员所应当关注的。程序员所要做的应该是实现所需要的程序功能，而不是耗费大量精力在内存的分配释放上。
Java有了GC，就不需要程序员去人工释放内存空间。当Java虚拟机发觉内存资源紧张的时候，就会自动地去清理无用变量所占用的内存空间。当然，如果需要，程序员可以在Java程序中显式地使用System.gc()来强制进行一次立即的内存清理。
因为显式声明是做堆内存全扫描，也就是 Full GC，是需要停止所有的活动的（Stop The World Collection），你的应用能承受这个吗？而其显示调用System.gc()只是给虚拟机一个建议，不一定会执行，因为System.gc()在一个优先级很低的线程中执行。
33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。
34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？可以。
抽象类的匿名内部类：
abstract class Person &#123;    public abstract void eat();&#125; public class Demo &#123;    public static void main(String[] args) &#123;        Person p = new Person() &#123;            @Override  //此处方法重载 说明是实现父类  即内部类可以继承其他类 而且是必须            public void eat() &#123;                System.out.println(&quot;eat something&quot;);            &#125;        &#125;;        p.eat();    &#125;&#125;

接口类的匿名内部类：
interface Person &#123;    public void eat();&#125; public class Demo &#123;    public static void main(String[] args) &#123;        Person p = new Person() &#123;            @Override  //此处方法重载 说明是实现父类  即内部类可以实现其他类 而且是必须            public void eat() &#123;                System.out.println(&quot;eat something&quot;);            &#125;        &#125;;        p.eat();    &#125;&#125;

35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？完全可以。

静态内部类：它是用static修饰的，在访问限制上它只能访问外部类中的static所修饰的成员变量或者是方法：

成员内部类：成员内部类是最普通的内部类，它可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。
当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：

外部类.this.成员变量

外部类.this.成员方法



局部内部类：局部内部类是定义在外围类的方法中的，在访问的时候它可以直接访问外围类的所有成员！但是不能随便访问局部变量，除非这个局部变量被final修饰。

匿名内部类：匿名内部类其实就是局部内部类的简写格式，只能使用一次。


39、如何实现字符串的反转及替换？使用递归实现字符串反转，代码如下所示：
public static String reverse(String originStr) &#123;     if(originStr == null || originStr.length() &lt;= 1)         return originStr;     return reverse(originStr.substring(1)) + originStr.charAt(0); &#125;

每次取第一个字符拼到字符串最后，依次递归，如图所示：


40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？String s1 = &quot;你好&quot;;try &#123;    String s2 = new String(s1.getBytes(&quot;GB2312&quot;), &quot;ISO-8859-1&quot;);&#125; catch (UnsupportedEncodingException e) &#123;    e.printStackTrace();&#125;

42、打印昨天的当前时刻。public class test &#123;    public static void main(String[] args) &#123;        Calendar cal = Calendar.getInstance();        cal.add(Calendar.DATE, -1);        System.out.println(cal.getTime());    &#125;   &#125;

43、比较一下 Java 和 JavaSciprt。Java与JavaScript是两个公司开发的不同的两个产品。Java是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。
下面对两种语言间的异同作如下比较：

基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。
解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）。
强类型变量和弱类型变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。
代码格式不一样。

44、什么时候用断言（assert）？断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、最关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。
注意：断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。
断言可以有两种形式：

assert Expression1;

assert Expression1 : Expression2;
Expression1表示一个boolean表达式；
Expression2表示一个基本类型、表达式或者是一个Object，用于在失败时输出错误信息，它是一个传到AssertionError构造函数的值，如果断言失败，该值被转化为它对应的字符串


要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。
45、Error 和 Exception 有什么区别？

异常发生的原因有很多，通常包含以下几大类：

用户输入了非法数据。
要打开的文件不存在。
网络通信时连接中断，或者JVM内存溢出。

异常主要分三种类型：

检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。
运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。
错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。

Java异常又可以分为不受检查异常（Unchecked Exception）和检查异常（Checked Exception）。
下面将详细讲述这些异常之间的区别与联系：

Error：Error类对象由 Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如，Java虚拟机运行错误（VirtualMachineError），当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在Java中，错误通常是使用Error的子类描述。
Exception：在Exception分支中有一个重要的子类RuntimeException（运行时异常），该类型的异常自动为你所编写的程序定义ArrayIndexOutOfBoundsException（数组下标越界）、NullPointerException（空指针异常）、ArithmeticException（算术异常）、MissingResourceException（丢失资源）、ClassNotFoundException（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；而RuntimeException之外的异常我们统称为非运行时异常，类型上属于Exception类及其子类，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。



47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。
一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；
try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；
throw语句用来明确地抛出一个异常；
throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；
finally为确保一段代码不管发生什么异常状况都要被执行；
try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。
48、运行时异常与受检异常有何异同？异常表示程序运行过程中可能出现的非正常状态。
运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。
受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。
Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：

不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）
对可以恢复的情况使用受检异常，对编程错误使用运行时异常
避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）
优先使用标准的异常
每个方法抛出的异常都要有文档
保持异常的原子性
不要在catch中忽略掉捕获到的异常

49、列出一些你常见的运行时异常？
ArithmeticException（算术异常）
ClassCastException （类转换异常）
IllegalArgumentException （非法参数异常）
IndexOutOfBoundsException （下标越界异常）
NullPointerException （空指针异常）
SecurityException （安全异常）

50、阐述 final、finally、finalize 的区别。
final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味 着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将 变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须 在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方 法也同样只能使用，不能在子类中被重写。
finally：通常放在 try…catch…的后面构造总是执行代码块，这就意味着 程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以 将释放外部资源的代码写在 finally 块中。
finalize：Object 类中定义的方法，Java 中允许使用 finalize()方法在垃 圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize()方法可以整理系统资源或者执行其他清理工作。

52、List、Set、Map 是否继承自 Collection 接口？List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别， 而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。
53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的 数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉 及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由 于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存 储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索 引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更 高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中 提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非 线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。
54、Collection 和 Collections 的区别？答： Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个 工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、 排序、线程安全化等等。
55、List、Map、Set 三个接口存取元素时，各有什么特点？List 以特定索引来存取元素，可以有重复元素。
Set 不能存放重复元素（用对象的 equals()方法来区分元素是否重复）。
Map 保存键值对（key-value pair）映射， 映射关系可以是一对一或多对一。
Set 和 Map 容器都有基于哈希存储和排序树的 两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树 版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达 到排序和去重的效果。
56、TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。
TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。
Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入 的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。
57、Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复。
wait()是 Object 类的方法，调用对象的 wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或 notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。
58、线程的 sleep()方法和 yield()方法有什么区别？
sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；
线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；
sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；
sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。

59、当一个线程进入一个对象的 synchronized 方法A之后， 其它线程是否可进入此对象的 synchronized 方法B？不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池）中等待对象的锁。
68、Java 中如何实现序列化，有什么意义？序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。
69、Java 中有几种类型的流？字节流和字符流。字节流继承于 InputStream、OutputStream，字符流继承Reader、Writer。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于 Java 的 I&#x2F;O 需要注意的有两点：一是两种对称性（输入和输出的对 称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。
73、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？
XML 文档定义分为 DTD 和 Schema 两种形式，二者都是对 XML 语法的约束。
其本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且 可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。

对 XML 的解析主 要有 DOM（文档对象模型，Document Object Model）、SAX（Simple API foXML）和 StAX（Java 6 中引入的新的解析 XML 的方式，Streaming API for XML）。

其中 DOM 处理大型文件时其性能下降的非常厉害，这个问题是由 DOM 树结构用的内存较多造成的，而且 DOM 解析方式必须在解析文件之前把整个文档装入内存，适合对 XML 的随机访问（典型的用空间换取时间的策略）。

SAX 是事件驱动型的 XML 解析方式，它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件， 用户通过事件回调代码来处理 XML 文件，适合对 XML 的顺序访问。

顾名思义， StAX 把重点放在流上，实际上 StAX 与其他解析方式的本质区别就在于应用程能够把 XML 作为一个事件流来处理。将 XML 作为一组事件来处理的想法并不新颖（SAX 就是这样做的），但不同之处在于 StAX 允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。




75、阐述 JDBC 操作数据库的步骤。
加载驱动。
创建连接。
创建语句。
执行语句。
处理结果。
关闭资源。

关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、 再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection，虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。
76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？
PreparedStatement 接口代表预编译的语句，它主要的优势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可 能性）；
PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；
当批量处理 SQL 或频繁执行相同的查询时， PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的 SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。

补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接 口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数 （如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦， 因为每种数据库的存储过程在书写上存在不少的差别。
77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）
要提升更新数据的性能 可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。
78、在进行数据库编程时，连接池有什么作用？由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在 Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的 开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等
补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。
79、什么是 DAO 模式？DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。
在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共 API 中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。
DAO 模式实际上包含了两个模式，一是 Data Accessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。
81、JDBC 中如何进行事务处理？Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置手动提交事务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中发生异常则通过 rollback()进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。


82、JDBC 能否处理 Blob 和 Clob？答： Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象（Character Large Object），因此其中 Blob 是为存储大的二进制数据而设计的，而 Clob 是为存储大的文本数据而设计的。JDBC 的 PreparedStatement 和 ResultSet 都提供了相应的方法来支持 Blob 和 Clob 操作。
85、获得一个类的类对象有哪些方式？
方法 1：类型.class，例如：String.class
方法 2：对象.getClass()，例如：”hello”.getClass()
方法 3：Class.forName()，例如：Class.forName(“java.lang.String”)

86、如何通过反射创建对象？
方法 1：通过类对象调用 newInstance()方法，例如： String.class.newInstance()
方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor() 方法获得构造器（Constructor）对象并调用其 newInstance()方法创建对象， 例如：String.class.getConstructor(String.class).newInstance(“Hello”);

87、Java 中能创建 volatile 数组吗？能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。
88、volatile 能使得一个非原子操作变成原子操作吗？一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。
89、volatile 修饰符的有过什么实践？一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是 64 位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。
简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（writebarrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。
90、volatile 类型变量提供什么保证？volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT 为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。
91、10 个线程和 2 个线程的同步代码，哪个更容易写？从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。
92、你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：
// The standard idiom for using the wait methodsynchronized (obj) &#123;	while (condition does not hold)	obj.wait();	// (Releases lock, and reacquires on wakeup)	... // Perform action appropriate to condition&#125;

93、什么是多线程环境下的伪共享（false sharing）？伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行。
94、什么是 Busy spin？我们为什么要使用它？Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他 CPU 上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。
95、Java 中怎么获取一份线程 dump 文件？在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用 Tomcat。
96、Swing 是线程安全的？不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。
97、什么是线程局部变量？线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。
98、用 wait-notify 写一段代码来解决生产者-消费者问题？只要记住在同步块中调用 wait() 和 notify() 方法 ，如果阻塞，通过循环来测试等待条件。
99、用 Java 写一个线程安全的单例模式（Singleton）？一步一步创建一个线程安全的 Java 单例类。当我们说线程安全时，意思是即使初始化是在多线程环境中，仍然能保证单个实例。Java 中，使用枚举作为单例类是最简单的方式来创建线程安全单例模式的方式。
100、Java 中 sleep 方法和 wait 方法的区别？虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。
101、什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer 及其它包装类。
102、我们能创建一个包含可变对象的不可变对象吗？是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。数据类型和 Java 基础面试问题
103、Java 中应该使用什么数据类型来代表价格？如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的double 类型。
103、怎么将 byte 转换为 String？可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。
104、Java 中怎样将 bytes 转换为 long 类型？bytes[] 到数字类型的转换是个经常用到的代码,解决方式也不止一种。
java代码实现
如果不想借助任何已经有的类，完全可以自己实现这段代码，如下：
/** * 将字节数组转为long&lt;br&gt; * 如果input为null,或offset指定的剩余数组长度不足8字节则抛出异常 * * @param input * @param offset       起始偏移量 * @param littleEndian 输入数组是否小端模式 * @return */public static long longFrom8Bytes(byte[] input, int offset, Boolean littleEndian) &#123;    long value = 0;    // 循环读取每个字节通过移位运算完成long的8个字节拼装    for (int count = 0; count &lt; 8; ++count) &#123;        int shift = (littleEndian ? count : (7 - count)) &lt;&lt; 3;        value |= ((long) 0xff &lt;&lt; shift) &amp; ((long) input[offset + count] &lt;&lt; shift);    &#125;    return value;&#125;

借助java.nio.ByteBuffer实现
java.nio.ByteBuffer 本身就有getLong、getInt，getFloat….方法，只要将byte[]转换为ByteBuffer就可以实现所有primitive类型的数据读取，参见javadoc。
/**     * 利用 &#123;@link java.nio.ByteBuffer&#125;实现byte[]转long     * @param input     * @param offset      * @param littleEndian 输入数组是否小端模式     * @return     */public static long bytesTolong(byte[] input, int offset, Boolean littleEndian) &#123;	// 将byte[] 封装为 ByteBuffer 	ByteBuffer buffer = ByteBuffer.wrap(input,offset,8);	if(littleEndian)&#123;		// ByteBuffer.order(ByteOrder) 方法指定字节序,即大小端模式(BIG_ENDIAN/LITTLE_ENDIAN)		// ByteBuffer 默认为大端(BIG_ENDIAN)模式 		buffer.order(ByteOrder.LITTLE_ENDIAN);	&#125;	return buffer.getlong();&#125;

借助java.io.DataInputStream实现
java.io.DataInputStream 同样提供了 readLong，readLong，readLong….方法，只要将byte[]转换为DataInputStream就可以实现所有primitive类型的数据读取,参见javadoc。
105、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。
106、存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为C 么？如 C &#x3D; (C) B；这属于强制类型转换，如果被转换的B实例不是C类型，会有异常
比如你的ABC分别对应动物，猫，黑猫。
向上转型就是比如
C c &#x3D; new C();
B b &#x3D; c;
你把c转型为B，黑猫是猫吗？是啊，所以这是ok的。
但是反过来
B b &#x3D; new B();
C c &#x3D; (C)b;
这就不ok了，只知道这个b是一只猫，他不一定是黑猫。
但如果这个b已经确定是一只黑猫了，那就可以转型了
B b &#x3D; new C();
C c &#x3D; (C)b;
这里的b本来就是黑猫啊。
107、哪个类包含 clone 方法？是 Cloneable 还是 Object？java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。
108、Java 中 ++ 操作符是线程安全的吗？不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。
109、a &#x3D; a + b 与 a +&#x3D; b 的区别+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是
byte a = 127;byte b = 127;b = a + b;// error : cannot convert from int to byteb += a;// ok


（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte就会编译出错）
110、我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。
111、3 * 0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？false，因为有些浮点数不能完全精确的表示出来。
112、int 和 Integer 哪个会占用更多的内存？Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。
113、为什么 Java 中的 String 是不可变的（Immutable）？Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。
114、我们能在 Switch 中使用 String 吗？从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。
115、Java 中的构造器链是什么？当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。
116、64 位 JVM 中，int 的长度是多数？Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在32位和64位的java虚拟机中，int 类型的长度是相同的。
117、Serial 与 Parallel GC 之间的不同之处？Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。
118、32 位和 64 位的 JVM，int 类型变量的长度是多数？32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4个字节。
119、Java 中 WeakReference 与 SoftReference 的区别？虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。
120、WeakHashMap 是怎么工作的？WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key&#x2F;value 将会被回收。
121、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过-XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。
122、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。
123、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约3GB。64 位 JVM 允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。
124、JRE、JDK、JVM 及 JIT 之间有什么不同？JRE 代表 Java 运行 时（Java run-time），是 运 行 Java 引用所必须的。
JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java编译器，它也包含 JRE。
JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。
JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。
125、解释 Java 堆空间及 GC？当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。
126、你能保证 GC 执行吗？不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC的执行。
127、怎么获取 Java 程序使用的内存？堆使用的百分比？可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory()方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。
128、Java 中堆和栈有什么区别？JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。
129、“a &#x3D;&#x3D; b”和”a.equals(b)”有什么区别？如果 a 和 b 都是对象，则 a&#x3D;&#x3D;b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。
130、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap 等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。
131、final、finalize 和 finally 的不同之处？final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。
132、Java 中的编译期常量是什么？使用它又什么风险？公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。
133、poll() 方法和 remove() 方法的区别？poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。
134、Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。
135、ArrayList 与 LinkedList 的区别？最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。
136、用哪两种方式来实现集合的排序？你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。
137、Java 中怎么打印数组？你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println()方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。
138、Java 中的 LinkedList 是单向链表还是双向链表？是双向链表，你可以检查 JDK 的源码。
139、Java 中的 TreeMap 是采用什么树实现的？Java 中的 TreeMap 是使用红黑树实现的。
140、Hashtable 与 HashMap 有什么不同之处？这两个类有许多不同的地方，下面列出了一部分：
a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。
b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。
c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。
141、Java 中的 HashSet，内部是如何工作的？HashSet 的内部采用 HashMap 来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的key，只允许有一个 null key，意思就是 HashSet 中只允许存储一个 null 对象。
142、写一段代码在遍历 ArrayList 时移除一个元素？该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。
143、我们能自己写一个容器类，然后使用 for-each 循环码？可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。
144、ArrayList 和 HashMap 的默认大小是多数？在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16 个元素（必须是 2 的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：
// from ArrayList.java JDK 1.7private static final int DEFAULT_CAPACITY = 10;//from HashMap.java JDK 7static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;// aka 16

145、有没有可能两个不相等的对象有有相同的 hashcode？有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的 hashcode 值，但是没有关于不相等对象的任何规定。
146、两个相同的对象会有不同的的 hash code 吗？不能，根据 hash code 的规定，这是不可能的。
147、我们可以在 hashcode() 中使用随机数字吗？不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。
148、Java 中，Comparator 与 Comparable 有什么不同？Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。
Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。
149、为什么在重写 equals 方法的时候需要重写 hashCode 方法？因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。
150、在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？这个需要看你是并行处理还是串行处理了。
151、Java 中怎么创建 ByteBuffer？byte[] bytes = new byte[10];ByteBuffer buf = ByteBuffer.wrap(bytes);

152、Java 中，怎么读写 ByteBuffer ？153、Java 采用的是大端还是小端？154、ByteBuffer 中的字节序是什么？ByteBuffer类中的order(ByteOrder bo) 方法可以设置 ByteBuffer 的字节序。
其中的ByteOrder是枚举：
ByteOrder BIG_ENDIAN 代表大字节序的 ByteOrder 。
ByteOrder LITTLE_ENDIAN 代表小字节序的 ByteOrder 。
ByteOrder nativeOrder() 返回当前硬件平台的字节序。
155、Java 中，直接缓冲区与非直接缓冲器有什么区别？非直接缓冲区：通过allocate()分配缓冲区，将缓冲区建立在JVM的内存中
直接缓冲区：通过allocateDirect()分配直接缓冲区，将缓冲区建立在物理内存中，可以提高效率
156、Java 中的内存映射缓存区是什么？157、socket 选项 TCP NO DELAY 是指什么？158、TCP 协议与 UDP 协议有什么区别？TCP协议和UDP协议特性区别总结：

TCP协议在传送数据段的时候要给段标号；UDP协议不

TCP协议可靠；UDP协议不可靠

TCP协议是面向连接；UDP协议采用无连接

TCP协议负载较高，采用虚电路；UDP采用无连接

TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）

TCP协议采用窗口技术和流控制


159、Java 中，ByteBuffer 与 StringBuffer 有什么区别？160、Java 中，编写多线程程序的时候你会遵循哪些最佳实践？a）给线程命名，这样可以帮助调试。
b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。
c）如果可以，更偏向于使用 volatile 而不是 synchronized。
d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semaphore。
e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。
161、说出几点 Java 中使用 Collections 的最佳实践a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是Vector。
b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。
c）使用接口代表和访问集合，如使用 List 存储 ArrayList，使用 Map 存储HashMap 等等。
d）使用迭代器来循环集合。
e）使用集合的时候使用泛型。
162、说出至少 5 点在 Java 中使用线程的最佳实践。这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：
a）对线程命名
b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。
c）使用线程池
163、说出 5 条 IO 的最佳实践IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：
a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。
b）使用 NIO 和 NIO2
c）在 finally 块中关闭流，或者使用 try-with-resource 语句。
d）使用内存映射文件获取更快的 IO。
164、列出 5 个应该遵循的 JDBC 最佳实践有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：
a）使用批量的操作来插入和更新数据
b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。
c）使用数据库连接池
d）通过列名来获取结果集，不要使用列的下标来获取。
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/posts/5205ee75/</url>
    <content><![CDATA[redis线程模型
单线程，NIO，异步事件处理



rabbitmq集群架构


rabbitmq引入的问题好处：异步、解耦、削峰
坏处：
重复消息（幂等性保障）

设置唯一消息主键
redis setnx 命令（redis分布式锁）

消息丢失

备份交换机
死信队列
mandantory &#x3D; true + ReturnListener 保证消息不丢失

消息积压

增加消费者的消费能力，或者临时增加

顺序消费怎么解决

单一消费者

zookeeperzookeeper分布式锁
监听回调、临时节点
分布式事务
如果超时就会出现分布式事务问题。

二阶段提交atomikos框架实现二阶段提交，可以做到重试机制，日志记录等逻辑，但是无法解决微服务中跨JVM的问题。
可靠消息最终一致性方案可以通过自定义一个消息信息体Message，给消息设置INIT，SEND，END三种状态，然后搭建一个独立的消息服务来补偿消息发送过程可能出现异常的问题，或者是因为网络超时导致消息状态没有修改成功，定时的调用业务系统的相关接口，比如订单是否成功生成，库存是否成功减掉来修复消息本身的状态，进而对操作消息的下一步执行过程。

TCC与XA&#x2F;JTA对比

XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁
TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁


TCC的开源框架实现
 Atomikos，tcc-transaction，ByteTcc，支付宝GTS


可靠消息最终一致性方案

TCC(Try-Confirm-Cancel)两阶段补偿型方案

秒杀系统spring session实现分布式session
zookeeper节点通过watcher机制保证本地ConcurrentHashMap中的当前商品库存数量一致，防止超卖问题
redis setnx分布式锁保证接口多次请求只有一次能成功，类似于占位标识，一个用户只能有一个订单的请求，搭配rabbitmq中间件异步消费订单消息，消费成功后解除占位标识，同时在redis中生成订单信息
通过redis的incr实现限流防刷
详情页优化使用动态化渲染，用nginx+lua实现页面动态化，nginx层面做了两层，一层通过hash取模实现负载转发，一层用于缓存热点数据以减少redis缓存的压力

缓存失效
由于大量的key设置相同的过期时间导致，可以采用随机数来设置过期时间避免大量缓存同一时间失效。

缓存击穿
打个比方，某个黑客想要攻击网站，那么他通过URL访问一个不存在的商品来跳过nginx的本地缓存，web应用里面的ecache缓存和redis缓存来直接访问数据库，造成数据库压力暴涨导致系统直接宕机；这个可以通过在redis里面设置某个商品的键值对为&lt;key ,null&gt;来避免直接访问数据库，如果查询到一个值为null的key，直接返回商品不存在的提示信息。

缓存雪崩
缓存雪崩是因为大量的并发请求流入，超过了服务器的负载能力，直接压爆了nginx缓存和redis缓存以及各种缓存从而直接导致系统瘫痪，本质上没法根本解决，为了避免缓存雪崩可以通过水平扩展nginx机器增加nginx缓存或者增加redis cluster内的机器，响应更多的并发请求。


计算机所能处理的最小的数据项位。
优化Hibernate所鼓励的7大措施：
尽量使用many-to-one，避免使用单项one-to-many

灵活使用单向one-to-many

不用一对一，使用多对一代替一对一

配置对象缓存，不使用集合缓存

一对多使用Bag 多对一使用Set

继承使用显示多态 HQL:from object polymorphism&#x3D;”exlicit” 避免查处所有对象

消除大表，使用二级缓存


JSP内置对象一共有9个内置对象

pageContext javax.servlet.jsp.PageContext
request javax.servlet.http.HttpServletRequest
response javax.servlet.http.HttpServletResponse
session javax.servlet.http.HttpSession
application javax.servlet.ServletContext
config javax.serlvet.ServletConfig
exception java.lang.Throwable
page java.lang.Object
out javax.servlet.jsp.JspWriter

作用：

pageContext 表示页容器 EL表达式、 标签 、上传

request 服务器端取得客户端的信息：头信息 、Cookie 、请求参数 ，最大用处在MVC设计模式上

response 服务器端回应客户端信息：Cookie、重定向

session 表示每一个用户，用于登录验证上

application 表示整个服务器

config 取得初始化参数，初始化参数在web.xml文件中配置

exception 表示的是错误页的处理操作

page 如同 this 一样，代表整个 jsp 页面自身

out 输出，但是尽量使用表达式输出


怎样使JAVA栈内存快速溢出？方法区和堆所有线程共享。虚拟机栈和本地方法栈和程序计数器每个线程独享。  每个线程的栈大小可以通过  参数 ：-Xss512k 来决定每新启动一个线程分配的栈大小。
如果方法迭代度过深就会出现栈内存溢出。 每一个方法在执行的同时会创建一个栈帧（用来存储局部变量，操作数栈，动态链接，动态出口等信息。）从调用到执行完成的过程就对应着
一个栈帧在虚拟机中入栈到出栈的过程。（方法执行完成后会释放所有的局部变量）
堆内存则是绝大部分用来存储生成的对象。 创建对象过多或强引用使GC无法回收则会报堆内存不足的异常。 （GC主要关注区域）
方法区\元空间\永久代  : 用来存储被虚拟机加载的类信息，常量，静态变量。（jdk8取消了这部分内存区域，一部分放入heap中）
运行时常量池： 用来存储编译器生成的各种字面量和符号引用。  字面量（new String(“你好”） 你好就是字面量
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>黑苹果安装教程</title>
    <url>/posts/479c48ec/</url>
    <content><![CDATA[目录镜像下载macOS Monterey 12.6.3 (21G419) 正式版 ISO、IPSW、PKG 下载
BIOS 设置官方建议OpenCore 官方建议的 10 代 CPU 架构的 BISO 调整如下：
禁用

Fast Boot
Secure Boot
Serial&#x2F;COM Port
Parallel Port
VT-d (如果设置了 DisableIoMapper 为 YES，则可以打开这个选项)
CSM
Thunderbolt (建议关闭雷电，第一次安装可能出现玄学问题)
Intel SGX
Intel Platform Trust
CFG Lock

开启

VT-x
Above 4G decoding
Hyper-Threading
Execute Disable Bit
EHCI&#x2F;XHCI Hand-off
OS type: Windows 8.1&#x2F;10 UEFI Mode
DVMT Pre-Allocated(iGPU Memory): 64MB
SATA Mode: AHCI

ASUS-11th
disable igpu（Otherwise, you will not be able to sleep normally）
disable Intel Rapid Storage Technology 最后需要按键盘上的F10键保存退出即可.

ASUS-10th
Disabe
Fast Boot
VT-d
CSM
Intel SGX
CFG Lock
Enable
VT-x (no option in BIOS, it’s enabled by default)
Above 4G decoding
Hyper-Threading
EHCI&#x2F;XHCI Hand-off
OS type: Windows UEFI Mode (Clear Secure Boot Keys or choose Other type)
DVMT Pre-Allocated(iGPU Memory): 64MB 最后需要按键盘上的F10键保存退出即可.

MSI-10th
Boot – Fast Boot -&gt; Disabled
Advanced – PCH Sorage Configuration – SATA Mode Selection -&gt; AHCI
Boot – CSM(Compatibility Support Module) -&gt; Disabled
Ai Tweaker – Ai Overclock Tuner -&gt; XMP
Advanced – CPU configuration – Intel Virtualization Technology -&gt; Disabled
Advanced – System Agent (SA) Configuration – VT-D -&gt; Disabled
Advanced – System Agent (SA) Configuration – Above 4G Decoding -&gt; Disabled
Advanced – System Agent (SA) Configuration – Graphics Configuration – Primary Display -&gt; CPU Graphics 集成显卡配置1
Advanced – System Agent (SA) Configuration – Graphics Configuration – iGPU Multi-Monitor -&gt; Disabled 集成显卡配置2
Advanced – PCH configruation - IOAPIC 24-119 Entries -&gt; Enabled
Advanced – PCH-FW Configuration – TPM Device Selection -&gt; Discrete TPM
Advanced – APM Configuration – ErP Ready -&gt; Disabled
Advanced – Network Stack Configuration – Network Stack -&gt; Disabled
Boot – Secure Boot – OS Type – Other OS 最后需要按键盘上的F10键保存退出即可.

MSI-11th
Boot – Fast Boot -&gt; Disabled
Advanced – PCH Sorage Configuration – SATA Mode Selection -&gt; AHCI
Boot – CSM(Compatibility Support Module) -&gt; Disabled
Ai Tweaker – Ai Overclock Tuner -&gt; XMP
Advanced – CPU configuration – Intel Virtualization Technology -&gt; Disabled
Advanced – System Agent (SA) Configuration – VT-D -&gt; Disabled
Advanced – System Agent (SA) Configuration – Above 4G Decoding -&gt; Disabled
Advanced – System Agent (SA) Configuration – Graphics Configuration – Primary Display -&gt; PCIE 独立显卡配置 1
Advanced – System Agent (SA) Configuration – Graphics Configuration – iGPU Multi-Monitor -&gt; Enabled 独立显卡配置 2
Advanced – PCH configruation - IOAPIC 24-119 Entries -&gt; Enabled
Advanced – PCH-FW Configuration – TPM Device Selection -&gt; Discrete TPM
Advanced – APM Configuration – ErP Ready -&gt; Disabled
Advanced – Network Stack Configuration – Network Stack -&gt; Disabled
Boot – Secure Boot – OS Type – Other OS 最后需要按键盘上的F10键保存退出即可.

USB 定制1、从仓库下载 「Windows.exe」到 Windows 平台，双击即可运行
 
2、输入D然后回车来探测电脑上的端口
 
3、分别在各个 USB 接口插入USB2.0和USB 3.X的设备，每插入一次停留 5 秒钟，如果有Type-C设备的话，正反都要分别插入记录都挨个插一遍后，输入 B 回车即可返回主菜单
 
4、回到主菜单，输入S来查看端口探测的结果，此时结果查看感觉没问题的话，输入K回车，即可导出UTBMap.kext文件（一般情况下会保存在当前程序的同级目录下） 
5、除了上述生成的UTBMap.kext文件以外，我们还需要配合USBToolBox.kext使用（仓库）将上述两个 Kext 放到 OC 的 Kexts 文件夹下面并加载，去除 usbport.kext
 
6、重启即可生效，至此你的 USB 基本上定制完了，尽情使用吧。
蓝牙配置
2021 年 6 月初的 WWDC2021 上，苹果发布了下一代 macOS，代号 Monterey（蒙特雷），大版本号 12.0。爱折腾爱尝鲜的黑苹果小伙伴们已经通过各种折腾安装上了新版 macOS。但是很快出现了各种各样的驱动问题，其中比较突出的是蓝牙掉驱动并且卡跑码问题。Monterey 大幅精简了蓝牙框架，原因是 macOS 12.0 砍掉了 2015 年之前机型的支持，另外可能也是为通用控制做准备。
很快，OC 团队做出反应添加了解决方案。说起来也简单，就是新加一个驱动：BlueToolFixup.kext，然后在 macOS 12.0 取消蓝牙 injector（注入器）的加载。
「注意」

BlueToolFixup.kext 目前是 BrcmPatchRAM 文件包中的一部分，新版本发布会直接包括这个文件，英特尔蓝牙也需要这个驱动；
使用奋威 T919 或其它免驱动型网卡的，无需担心蓝牙兼容性问题，在 Monterey 里依旧无需任何驱动。




解决方法
将 Lilu 升级到 1.5.7 及以上；
博通卡：将 BrcmPatchRAM 升级到 2.6.1 及以上；
英特尔：将 IntelBluetoothFirmware 升级到 2.0.1 及以上；
关闭 OpenCore 的 XhciPortLimit，位于 config → Kernel → Quirks 区域，在升级或安装 macOS Monterey 之前，建议定制好 USB 接口；
将 BlueToolFixup.kext 放到 Clover&#x2F;OpenCore 对应的 kext 目录
OpenCore：&#x2F;EFI&#x2F;OC&#x2F;Kexts&#x2F;
Clover：&#x2F;EFI&#x2F;CLOVER&#x2F;Kexts&#x2F;Other&#x2F;


最后，按照下一章节的说明修改 config.plist 文件。

Clover 方法Clover 使用文件夹名称来区别各个系统加载的 kext，所以可以这么操作：

博通卡：把 BrcmBluetoothInjector.kext 从 &#x2F;EFI&#x2F;CLOVER&#x2F;Kexts&#x2F;Other&#x2F; 挪到 &#x2F;EFI&#x2F;CLOVER&#x2F;Kexts&#x2F;11.0&#x2F;，将 BlueToolFixup.kext 放到 &#x2F;EFI&#x2F;CLOVER&#x2F;Kexts&#x2F;12.0&#x2F;
英特尔：把 IntelBluetoothInjector.kext 从 &#x2F;EFI&#x2F;CLOVER&#x2F;Kexts&#x2F;Other&#x2F; 挪到 &#x2F;EFI&#x2F;CLOVER&#x2F;Kexts&#x2F;11.0&#x2F;，将 BlueToolFixup.kext 放到 &#x2F;EFI&#x2F;CLOVER&#x2F;Kexts&#x2F;12.0&#x2F;

如果没有 11.0&#x2F;12.0 的文件夹，自己新建就可以。这样一来 Clover 在引导 11.0 时会加载 Injector，但是引导 12.0 时则不会加载 Injector，会加载 BlueToolFixup.kext 。其它 Kext 文件继续放在 Other 目录无影响。
「注意」以上方法如果不起作用，那么在迁移到 Monterey 时，需要手动从 Kext 目录移除 Injector 文件。「提示」如果你没有从 12.0 切换到低版本 macOS 的需求，xxxxInjector .kext 可以直接删除（无论博通和英特尔都一样），无需设置文件夹；
OpenCore 方法OpenCore 用户推荐使用另一种方法，利用 OpenCore 的最小内核（MinKernel）和最大内核（MaxKernel）特性，给 injector 设置最大内核 20.99.99，也就是对应 macOS Big Sur 11.0，给 BlueToolFixup.kext 设置最小内核 21.0.0，对应 macOS Monterey 12.0。
「提示」如果你没有从 12.0 切换到低版本 macOS 的需求，xxxxInjector .kext 可以直接删除（无论博通和英特尔都一样），也无需设置最大最小内核；
可以直接看图操作：
博通免驱网卡
升级 macos 12 方式：
使用 BlueToolFixup.kext 替代掉 BrcmBluetoothInjector.kext 即可。
最终使用驱动如下：

BlueToolFixup.kext
BrcmFirmwareData.kext
BrcmPatchRAM3.kext




Intel无线网卡
升级 macos 12 方式：
使用 BlueToolFixup.kext 替代掉 IntelBluetoothInjector.kext 即可。
BlueToolFixup.kext 可以从这里下载：https://github.com/acidanthera/BrcmPatchRAM/releases
最终使用驱动如下：

BlueToolFixup.kext
IntelBluetoothFirmware.kext




完成后，记得保存然后重启，如果无效，请关机冷启动，清除 Kext 缓存，或尝试重置 NVRAM。
设置启动参数
下面是 macOS 系统可以使用的启动参数列表，功能解释同时列出，使用要点有两个：

参数之间以空格分隔开；
在一个参数中，- 和 &#x3D; 只会同时存在一个，例如：debug&#x3D;0x100，-xcpm。即：有了 &#x3D; 号就不会有 - 号，反之亦然，新手请务必牢记。


参数说明一览：



常用
参数
作用



*
agdpmod&#x3D;pikera
Navi 核心避免黑屏使用，其它显卡如 RX400&#x2F;500，Vega56&#x2F;64 无需此参数


*
keepsyms&#x3D;1
辅助上一个参数


*
debug&#x3D;0x100 或 debug&#x3D;0x200
防止自动重启，禁用五国图直接输出错误信息


*
-v
用于安装前期启动时显示代码界面，在安装macOS时，应添加此参数以获取明确的错误信息。



-x
安全启动模式，类似 Windows 的安全模式。此模式下 macOS 会尽可能少的加载 Kext 文件。



-s
单用户模式。这一模式将会启动终端模式，可以用这种方式修复你的系统。



-f
关闭 Kext 缓存模式，等于强制重建 Kext 缓存。



-l
在系统日志中输出内存泄漏的相关记录。



arch&#x3D;x86_64
该参数会强制 macOS 以 64 位内核模式启动，在 10.15 及以上没有什么作用。对应的是 arch&#x3D;i386，将强制以 32 位模式启动。



iog&#x3D;0x0
此参数将强制 MacBook 机型在合盖后，接入外部显示器和键盘时系统保持开启状态；但同时，此参数会在接入外部显示器时关闭笔记本的内屏，这可能对保护屏幕以及省电有帮助。



platform&#x3D;X86PC
此参数将强制禁用 ACPI 电源管理。而 platform&#x3D;ACPI 将强制启用 ACPI 电源管理。



idlehalt&#x3D;1
强制 CPU 进入低功耗模式。



debug&#x3D;0x100
此参数用于禁用五国图，把 Kernel Panic（内核崩溃）的相关数据直接输出在屏幕上，可用于禁止发生内核崩溃时自动重启，这将对排查错误有助益，这一参数还可以用于 Core Dump。其它可用值还有：0x200，这可以在内核崩溃后使用快捷键（C 继续、R 重启、K 进入 KDB）；0x400 可用于触发内核崩溃后自动进行 Core Dump；0x2000 将只生成并发送 Kernel Panic 日志，不包括完整的 Core Dump。除此之外还有很多其他值，但一般以上几个已经足够安装 macOS 时使用。



keepsyms&#x3D;1
此参数可以为 debug&#x3D;0xN 提供更多错误信息。



dart&#x3D;0
此参数会关闭 64 位硬件上的系统 PCI 地址映射器（DART）。DART 在拥有 2GB 以上物理内存的机器上是必需的，在默认情况下 DART 都是加载的。当使用 Clover 引导系统且 BIOS 无法关闭 VT-d 时可尝试此参数。gg



darkwake&#x3D;0
在拥有完全定制好的 USB 接口时完全不必使用此参数，除非你真的需要操控 HID Tickle 行为。darkwake 是 XNU 的一部分，XNU 是一个混合内核，是 Darwin 系统的一部分（macOS 和 iOS 均使用了 Darwin ）。因启动参数仅用于按位计算，所以可能的值有 0、1、2、3、256、257、258、259 等等以此类推，也因此 darkwake&#x3D;8 实际等于 darkwake&#x3D;0；darkwake&#x3D;10 实际等于 darkwake&#x3D;2，XNU 自 2782.1.97 起删除了这两个值（8 和 10），故这两个值在 Yosemite 及更高版本 macOS 中已失效。黑苹果建议关闭电能小憩，使用 pmset 命令调试休眠。如果实在需要使用，可尝试 darkwake&#x3D;0 或 3。更多信息可参考外网这篇文章。



nvda_drv&#x3D;1
用于启用英伟达显卡驱动，包括开启 NVIDIA Web Driver


*
nv_disable&#x3D;1
关闭英伟达显卡驱动，请勿与 nvda_drv&#x3D;1 同时使用。



-no_compat_check
用于禁用 macOS 兼容性检查。例如，macOS 11.0 BigSur 不再支持 iMac 2014 年之前推出的机型，此时可使用此参数以禁止兼容性检查，以达到安装目的。



kext-dev-mode&#x3D;1
开启 Kext 开发模式，将允许加载未签名的 Kext。在 Yosemite 及更高版本 macOS 中，默认情况下出于安全原因，只会加载已签名的 Kext。此参数可以在 Yosemite 更改此设置，允许加载未签名的 Kext。在比 Yosemite 更新的 macOS 版本（El Capitan）中，引入了另一种安全机制，即系统完整性保护（SIP，也称为 Rootless），该系统会防止修改系统文件，加载未签名的 Kext 等。SIP 可以通过注入正确的 CSR NVRAM 变量来禁用，也可以通过恢复分区运行命令行禁用它。总之，在 10.11 及以后的系统中，已无需此参数。



cpus&#x3D;1
CPU单核模式，用于限制系统中活动 CPU 的数量。苹果的开发者工具有一个选项用于启用或禁用系统中的一些 CPU，但你也可以通过这个参数指定要使用的 CPU 数量。在某些情况下，这也许有助于省电，或者你正在调试 X86 电源驱动。



-xcpm
用于强制开启 xcpm 以实现 CPU 原生电源管理，一般用于较老架构的 CPU，例如 Ivy Bridge。



-gux_no_idle
用于终止英特尔芯片的空闲模式（idle-mode）功能。



slide&#x3D;N
用于引导系统时分配系统内核在内存中的位置，Clover 在一排加号处卡住可以尝试 slide&#x3D;0，其它参考：Slide 值的说明。



rootless&#x3D;0
使用 Rootless 模式，请勿在 El Capitan 及更高版本的 macOS 上使用，因为从 El Capitan 起引入了 SIP（系统完整性保护）机制。一般情况下关闭 SIP 即可达成你的目的。



-disablegfxfirmware
在 WhateverGreen.kext 出现之前，该参数用于关闭苹果的 iGPU firmware 以正确驱动 Intel 核显，在 macOS 10.13 及更高版本中已不使用。



npci&#x3D;0x2000 或 npci&#x3D;0x3000
AMD 系统没有开启 Above 4G Decoding 时使用；此参数会禁用某些与 kIOPCIConfiguratorPFM64 相关的 PCI 调试，另一个相似的选择是 npci&#x3D;0x3000，后者还会禁用与 gIOPCITunnelledKey 相关的调试。当 X299 卡在 PCI Start Configuration 时，应使用此参数，因为存在与 PCI 通道有关的 IRQ 冲突。


*
brcmfx-aspm
解决蓝牙连线问题，结合 AirportBrcmFixup.kext 使用



igfxonln&#x3D;1
使用 HDMI 接口每次开机&#x2F;重启都需要重新插拔才能显示的，添加启动参数 igfxonln&#x3D;1


*
-wegnoegpu
禁用独显（针对笔记本机型）


切换到 NVRAM 选项卡，右侧找到 7C436110-AB2A-4BBB-A880-FE41995C9F82，启动参数即显示在右方面板，目前配置情况如下：


agdpmod=pikera keepsms=1 brcmfx-aspm

设置默认启动项
config.plist 勾上仿冒苹果快捷键 PollAppleHotKey，在启动选择界面，先选中要启动的项，然后按键盘的 Ctrl + Enter 进入系统即可


也有看到说在 设置-启动磁盘 可选择默认启动项,修改后重启


更新 OC
下载最新版本OCAT(https://github.com/ic005k/OCAuxiliaryTools/releases)
挂载你的efi分区（也叫esp分区） [
挂载后先不要着急打开，先把OCAT（即OCAuxiliaryTools）同步一下再打开 [
然后再打开Config.plist。首先点击全选，然后检查kext更新，更新kext，后点击选择opencore版本，选择最新版，获取opencore，后点击同步 保存即可 [

生成三码1、同步完不必急着关闭OCAT，切换到PL选项卡

2、首先点击生成生成三码，然后点击生成生成rom，保存``重启即可
参考文章黑苹果启动参数都是做什么用的？如何添加或删除？
更新macOS Monterey后遇到的各种Bug及解决方法合集（持续更新）
黑苹果修复博通&#x2F;英特尔蓝牙在macOS Monterey 12.0 正式版中失效的方法
macOS 12 蓝牙
驱动英特尔核显，让黑苹果流畅运行「OpenCore专门篇」
国光黑苹果入门安装教程
【黑苹果】手把手黑苹果安装教程-基于 OpenCore（持续更新中）
【黑苹果】macOS 12 Monterey 原版 OC 引导安装教程
国光 2021 年中的黑苹果组装方案以及驱动分享
minisforum HX80G&#x2F;HX90G&#x2F;HX99G兼Ventura安装教程
EFI 下载hackintosh-with-B560-msi-asus
ASUS-MSI-10-11-HACKINTOSH-OPENCORE
AsRock-Z490-Steel-Legend-i7-10700
国光 3k 元不到的 i9 极致性能的 ITX 黑苹果方案分享
国光 微星 B560M Big Sur 黑苹果记录体验
10400 msi b560黑苹果
【黑苹果安装教程】i7 10700+微星B460M 迫击炮 WIFI
]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title>黑苹果常用配置</title>
    <url>/posts/4a49b547/</url>
    <content><![CDATA[目录macOS 开启或关闭 SIP
参考链接：https://sspai.com/post/55066

SIP 全称为「System Integrity Protection」即「系统完整性保护」，是 OS X El Capitan 时开始采用的一项安全技术，SIP 将一些文件目录和系统应用保护了起来。但这会影响我们一些使用或设置，比如：更改系统应用图标、终端操作系统目录文件提示「Operation not permitted」、Finder 无法编辑系统目录里的文件。
关闭 SIP因为 SIP 是系统级的权限操作，我们无法直接关闭它，需要前往「macOS 恢复功能」下进行。将 Mac 开机，立即在键盘上按住 Command ⌘ + R，直到看到 Apple 标志或旋转的地球时松开。看到「实用工具」窗口时，恢复功能启动即完成。


在上方的菜单栏点击「实用工具」选择「终端」。


在终端中，输入「csrutil disable」后回车。
回车后会提示「成功关闭了系统完整性保护，请重启机器」
点击菜单栏  标志，选择「重新启动」。


就此我们关闭了 SIP。
打开 SIPSIP 是避免软件任意修改或覆盖任意系统文件或应用，日常还是建议保持开启状态的。仍然是进入到「macOS 恢复功能」，但这次在终端输入的是「csrutil enable」开启 SIP，重启 Mac 即可。
和之前不同，这次输入的是「csrutil enable」

查看 SIP 当前状态csrutil status



opencore 重置 nvram在 OpenCore 中，重置 NVRAM 的方法有以下几种：

在 OpenCore 引导界面中，按下 Command + Option + P + R 键。这将在重启电脑后重置 NVRAM。
使用 Terminal 命令重置 NVRAM。在 Terminal 中输入 sudo nvram -c 并回车。这将立即清除 NVRAM 中的所有设置。
通过 OpenCore Configurator 清除 NVRAM。在 OpenCore Configurator 中选择 NVRAM 中的“Reset NVRAM”按钮。

请注意，重置 NVRAM 将清除所有自定义设置，并将需要重新配置。
查看错误日志pmset -g log

引导进入 Recovery 分区OpenCore配置文件中勾选

 UEFI -&gt; APFS -&gt; JumpstartHotPlug


]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title>黑苹果常见错误</title>
    <url>/posts/42c32bc5/</url>
    <content><![CDATA[目录解决 App Store 无法登录打开终端，输入命令：
sudo nvram -cPassword:nvram: Error clearing firmware variables: (iokit/common) not permitted

输入用户密码，然后回车，不必理会提示信息，然后重启
BIOS 未禁用 CFG LOCK 选项相关错误信息：

卡在 [EB|#LOG:EXITBS:START]

某些用户会忘记或无法禁用BIOS中的CFG-Lock(特别是与用于电源管理的锁定0xE2 MSR位有关，显然更安全地关闭CFG-Lock)。**&#x3D;&#x3D;请注意，这仅适用于Intel用户，不适用于AMD&#x3D;&#x3D;。**发生这种情况时，有几个可能的解决方法：
开OpenCore的配置文件config.plist，勾选如下三个选项：

Kernel -&gt; Quirks
AppleCpuPmCfgLock
AppleXcpmCfgLock


UEFI -&gt; Quirks
IgnoreInvalidFlexRatio







BIOS 重设或重启 &#x2F; 关机后发送到安全模式AppleRTC 的问题，很简单的解决方法：

打开 Config.plist 配置文件：
Kernel -&gt; Quirks -&gt; DisableRtcChecksum



注意：如果仍然有问题，则需要使用 RTCMemoryFixup.kext 并排除范围。
参考链接Big Sur安装常见问题
]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title>黑苹果装机配置</title>
    <url>/posts/f0e37cbf/</url>
    <content><![CDATA[目录电脑配置


类型
型号
价格
渠道



网卡
T919 BCM94360CD
150
闲鱼


显卡
蓝宝石 RX460 4GB 超白金版
229
闲鱼


内存条
镁光 3200 DDR4 32G
790
闲鱼


散热
雅浚 B3 PRO 4 热管 ARGB 神光同步
74.01
闲鱼


SSD 固态硬盘
西数 SN570 1T
350
闲鱼


主板
MSI MAG-B560M-MORTAR-WIFI
580
闲鱼


机箱
爱国者 T9 机箱
83.6
闲鱼


电源
爱国者 G7 全模组 700W
238
闲鱼


风扇
爱国者 冰魄彩虹 V1 * 6
56
闲鱼


CPU
i7-10700
1091
淘宝


螺丝
风扇铁黑&#x2F;镀镍螺丝
3.43
淘宝


转接线
大 4pin 一分五扩展线
12.99
淘宝


转接线
大 4pin 转 6 pin，显卡用
5.79
淘宝


硅脂
信越 7921 导热硅脂
20.90
淘宝


合计

3475.72



参考链接台式装机全程攻略
2022年黑苹果macOS Big Sur&#x2F;Monterey显卡支持列表，持续更新中。
黑苹果无线网卡购买&amp;安装&amp;使用指南2022年版
]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title>黑苹果驱动下载地址</title>
    <url>/posts/84c0ab93/</url>
    <content><![CDATA[目录kext其他


名称
适用版本
用途
下载地址
备注



Lilu.kext
通用
很多其他著名 kext 的依赖，没有这个其他都跑不了
https://github.com/acidanthera/Lilu/releases
必须得使用


VirtualSMC.kext
通用
模拟在真实 mac 上找到的 SMC 芯片，没有这个 macOS 将无法启动
https://github.com/acidanthera/VirtualSMC/releases
必须得使用


AppleALC.kext
通用
用于 AppleHDA 修补，支持大多数板载声卡
https://github.com/acidanthera/AppleALC/releases
强烈建议用


LucyRTL8125Ethernet.kext
通用
Realtek 的 2.5Gb 网卡驱动，需要 10.15 +
https://github.com/Mieze/LucyRTL8125Ethernet/releases
更多网卡参考


NVMeFix.kext
通用
改善与非 Apple SSD 的兼容性，有助于主动电源管理
https://github.com/acidanthera/NVMeFix/releases
可以试试看


SMCProcessor.kext
通用
用于监控 CPU 温度，AMD 不适用
https://github.com/acidanthera/VirtualSMC/releases
很有必要用


SMCSuperIO.kext
通用
用于监控风扇速度，AMD 不适用
https://github.com/acidanthera/VirtualSMC/releases
很有必要用


WhateverGreen.kext
通用
所有 GPU 都受益于这个 kext，必备插件
https://github.com/acidanthera/WhateverGreen/releases
必须得使用


USBPorts.kext
通用
参考这个文章：使用 Hackintool 定制黑苹果 USB 驱动

需要自定义


博通蓝牙
BrcmPatchRAM 需要按系统版本进行选择：

BrcmPatchRAM3 用于 macOS 10.14 及更高版本，必须搭配 BrcmBluetoothInjector 使用；
BrcmPatchRAM2 用于 macOS 10.11 到 10.14；
BrcmPatchRAM 用于 OS X 10.10 或更老的版本；

如果您有非 PatchRAM 设备（或者不确定），请安装 macOS 版本的 BrcmNonPatchRAM.kext 或 BrcmNonPatchRAM2.kext 之一，请不要同时安装两者。




名称
适用版本
用途
下载地址



AirportBrcmFixup.kext
通用
将旧的 Broadcom 卡注入较新版本的 macOS 的附加功能
https://github.com/acidanthera/AirportBrcmFixup/releases


BlueToolFixup.kext
Monterey
修复系统设置内的蓝牙开关
https://github.com/acidanthera/BrcmPatchRAM/releases


BrcmBluetoothInjector.kext
bigsur
修复系统设置内的蓝牙开关
https://github.com/acidanthera/BrcmPatchRAM/releases


BrcmBluetoothInjectorLegacy.kext
-

https://github.com/acidanthera/BrcmPatchRAM/releases


BrcmFirmwareData.kext
通用
上传固件
https://github.com/acidanthera/BrcmPatchRAM/releases


BrcmFirmwareRepo.kext
-
安装到 &#x2F;System&#x2F;Library&#x2F;Extensions（在10.11及更高版本上为 &#x2F;Library&#x2F;Extensions）。 该 kext 的内存效率比 BrcmFirmwareData.kext 略高，但是不能由引导加载程序注入。
https://github.com/acidanthera/BrcmPatchRAM/releases


BrcmNonPatchRAM.kext
-

https://github.com/acidanthera/BrcmPatchRAM/releases


BrcmNonPatchRAM2.kext
-

https://github.com/acidanthera/BrcmPatchRAM/releases


BrcmPatchRAM.kext
-

https://github.com/acidanthera/BrcmPatchRAM/releases


BrcmPatchRAM2.kext
-

https://github.com/acidanthera/BrcmPatchRAM/releases


BrcmPatchRAM3.kext
通用

https://github.com/acidanthera/BrcmPatchRAM/releases


intel蓝牙
IntelBluetoothFirmware 是一个用于在 macOS 中启用原生蓝牙的固件上传驱动，固件的二进制文件来自 Linux。
经过数月的测试后，这个驱动已经被证实可以正常稳定工作。目前支持 macOS 10.13 及以上，支持的设备 ID 如下：
0x8087, 0x0a2a0x8087, 0x07dc0x8087, 0x0aa70x8087, 0x00250x8087, 0x0aaa0x8087, 0x00260x8087, 0x00290x8087, 0x0a2b
如果驱动程序有问题，请在终端中运行以下命令：
log show --last boot | grep IntelFirmware




名称
适用版本
用途
下载地址



BlueToolFixup.kext
Ventura，Monterey
修复系统设置内的蓝牙开关
https://github.com/acidanthera/BrcmPatchRAM/releases


IntelBluetoothInjector.kext
bigsur
修复系统设置内的蓝牙开关
https://github.com/OpenIntelWireless/IntelBluetoothFirmware/releases


IntelBluetoothFirmware.kext

上传固件
https://github.com/OpenIntelWireless/IntelBluetoothFirmware/releases


IntelBTPatcher.kext
Ventura

https://github.com/OpenIntelWireless/IntelBluetoothFirmware/releases


网卡


名称
适用版本
用途
下载地址



AirportItlwm.kext
通用
网卡驱动
https://github.com/OpenIntelWireless/itlwm/releases


参考链接BrcmPatchRAM 黑苹果WiFi无线网卡蓝牙驱动
使用 WIFI&#x2F;BlueTooth 擴展卡，在Monterey 藍芽無法驅動的解決方案
]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
      </tags>
  </entry>
  <entry>
    <title>draw.io 基础教程</title>
    <url>/posts/5e3e9b12/</url>
    <content><![CDATA[1. 网页端使用懒得安装的直接使用下面这个链接直接开始绘图：https://www.draw.io
2. 桌面端下载在github项目右侧有个release，这里是作者打包生成好的安装文件，比如现在最新的版本是14.5.1点击进去后，可以看到如下图所示的下载页面。根据你自己的系统以及硬件平台选择合适的安装文件。



3. 语言设置安装完后第一次打开默认界面是英文的，如果想使用中文，可以点击Language接着选择自己喜欢的语言，如果想提升英语的还是默认吧哈哈。
选择简体中文。
设置完语言后记得重启下软件。

4. 开始绘图打开drawio后，点击创建新绘图：


接着会提示你选择一个模板，这里直接创建一个空白框图（可根据自身情况选择)

创建完后，如图所示：




添加元素
选择你需要的元素拖入画布 (左侧有官方提供的各种类型元素，点击左下角更多图形可以找到更多类别)
选中元素后可使用鼠标点击元素边缘上的点对元素进行放大&#x2F;缩小等操作（元素右上角的旋转标志可以选择元素）
双击元素可以输入文字
选中元素后可在右侧的样式中修改元素的样式（颜色等）
在右侧的文本中可以修改文字的字体、大小以及颜色等等
在右侧的调整图形中可以对元素的位置、大小以及角度等进行更加精细的调整



元素对齐当要对齐多个元素时，选择多个元素（可通过ctrl+鼠标左键选择多个目标），然后点击调整图形 -&gt; 对齐 然后选择你想要的对齐方式。


元素等距分布当要等距摆放多个元素时，选择多个元素（可通过ctrl+鼠标左键选择多个目标），然后点击调整图形 -&gt; 等距分布 然后选择你想要的分布方式。


连接元素当把鼠标放置元素上（注意没有点击，只是放置）会出现如下图所示的标识，四个箭头（用红圈标出的部分），16个小叉叉（用绿色的圈圈标出）。如果点击了元素只会显示四个箭头。


连接的操作有很多种，这里只简单讲一种，在刚刚说的 当把鼠标放置元素上 后在元素周围出现各种标识，你可以自己随便选择一个作为连接线的起始位置，鼠标左键按下（不要松）拖动鼠标移至你想连接的位置。


连接后在右侧的样式中可以修改连接线的样式、连接方式、颜色、粗细、线形等等。


添加文字
在通用里拖一个Text元素放到你想放的位置
双击Text元素编辑文字
在右侧的文本中对文字的颜色、字体、大小等进行编辑



添加公式可参考官方给的文档：https://www.diagrams.net/doc/faq/math-typesetting


在使用公式功能之前需要打开数学排版，在其他 -&gt; 数学排版 在点击后会显示一个勾勾，然后就能用了：


现在官方支持三种格式，比如写博文中常用的LaTeX格式。用起来也非常方便，直接把公式复制到Text元素里就行了。
$$\sqrt&#123;3×-1&#125;+(1+x)^2$$


如果不了解LaTeX公式不了解可以看下下面几个连接：帮助文档： https://www.latexlive.com/help在线公式编辑器： https://www.latexlive.com/
添加图片有时，需要使用一些现成的图片，点击上方的加号，再点击图片按钮。


接着你可以通过打开按钮选择自己本地的图片，或者通过网上图片的url直接载入进来。


添加表格点击上方的表格图标，然后拖动鼠标可以选择自己需要的表格大小（行数和列数）。

选中表格，在右侧的调整图形中可以调整表格的大小、位置等属性。


自由绘图有时一些特殊的图案软件中并没有提供，这时可以使用自由绘图功能自己去绘制。点击上方的加号，再点击自由绘图，会弹出一个自由绘图窗口。

点击开始绘图按钮就可以自己用鼠标随便绘制，绘制完后点击结束绘图按钮，刚刚绘制好的图案就会变成一个元素随意使用。


组合元素同时选中多个元素，在元素上点击鼠标反键，再点击组合即可组合成一个元素。


保存元素模板有时一些元素（可能是你自己组合设计的新元素）经常被用到，我们可以将其保存成一个模板方便下次使用。如下图所示，将需要保存的元素用鼠标拖至左侧的 便筏本 中，这样以后都可以使用到。

点击便筏本的铅笔符号可以编辑管理自己的便筏本。


5. 保存保存文件在左上角点击 文件 -&gt; 保存 将绘图文件保存到指定路径。


导出图片在左上角点击 文件 -&gt; 导出为 将绘图文件导出成指定格式，一般为了方便使用会导出成PNG或者JPEG格式等。


比如我要将图片保存成PNG格式的图片，软件会提示是否要透明背景、阴影、网格等。另外还有个边框宽度参数，这个参数代表输出图像时是否需要在图片边缘增加一些空白边缘。默认是0，如果需要可以自己设置。


大家可以简单对比下设置和不设置边缘宽度的区别。


6. 常用快捷键


快捷键
作用



CTRL + C
复制元素


CTRL + X
剪切元素


CTRL + V
粘贴元素


CTRL + Z
撤销操作


CTRL + S
保存绘图（建议经常保存，养成良好习惯）


CTRL + A
选中全部元素


DELETE
删除选中元素


]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>postman 常用配置</title>
    <url>/posts/51f0c4fa/</url>
    <content><![CDATA[参考链接
导入 chrome 请求1. 选择 Copy as cURL（bash）

2. 导入 postmanpostman 左上角点击 Import，选择 Paste Raw Text，去除 –compressed 即可成功导入。


Postman Interceptor 使用1. chrome 启用 Interceptor

2. 设置拦截域名

3. postman 启用拦截

即可即时拦截捕获所有异步请求。
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>v2rayN 配置教程</title>
    <url>/posts/4a137bcb/</url>
    <content><![CDATA[4.12 最新 v2rayN windows 进阶版使用教程 | 附PAC模式路由规则 | 多个自定义路由规则在上篇 v2rayN 使用教程中（点击跳转），已经向大家介绍了最新 v2rayN windows 的重大更新内容以及如何快速使用新版 v2rayN 客户端：

比如，删除了常见PAC 模式; 自定义路由规则集和自由切换多个路由规则集；
系统代理把windows系统部分软件流量（比如浏览器）转到v2ray的http入口、VMESS和VLESS协议 增加SNI属性等
新版 v2rayN 下载地址：https://github.com/2dust/v2rayN/releases/

不少小伙伴，也在上期视频教程下方（点击跳转）留言：
需要详细介绍“自定义路由规则的原理”、“分享一些常用的路由规则”、“能不能如何通过路由规则实现旧版客户端的PAC模式”等等。今天我们就来一起学习吧！
新旧版的不同点旧版的PAC模式是由“本地的PAC文件&#x2F;GFW LIST”对流量先进行分流；然后，再通过v2ray.exe去判断是否走代理出站，并配合”v2ray_privoxy.exe”进行流量转发；这也是为什么使用旧版客户端时， win10 UWP应用能正常工作的原因；新版的路由模式则是直接通过v2ray.exe 程序去分流和判断是否走代理的。（个人理解，如有错误，请帮忙留言指正，谢谢！）
旧版客户端：



新版客户端： 



那旧版PAC 模式消耗的内存更多一点（见下图），自定义灵活度也不高；
新版v2rayN 自定义灵活度高、使用的内存更小、有一定的速度提高，但有学习成本！


常说的 Geo文件是什么？与路由规则和路由规则集的关系是什么？Geo文件即路由规则文件：

“geosite.dat”：提供一个预定义好的 「全球域名」 列表，

“geoip.dat” ：提供一个预定义好的 「全球 ip-地区」 列表。



“.dat文件”里面有无数个分类，比如,中国的域名和IP都在 geosite:cn 和 geoip:cn
gfwlist的网址(也就是经典的PAC)在 geosite:gfw | 点击跳转
广告域名在 geosite:category-ads-all
国外域名在 geosite:geolocation-!cn
本地IP在 geoip:private里;
还有一千多种分类细分，比如 geosite:steam geosite:google 等，
以上内容来自于“网友 ycdm ”，谢谢他的分享。

综上:
geo路由规则文件是”全球域名和 全球地区的 IP 数据库”
路由规则可以采用”数据库内任意域名或者IP的分类”或者”添加一个不在数据库的域名或者IP”，并选择“对应的出站标签”；然后 “xray.exe或者 v2ray.exe “（常说的核心） 自带的路由模式，会根据路由规则中”不同的出站标签”，来决定“出站标签”包含的域名和IP是否走代理出站、直连（本地网络访问）还是禁止访问。
那“路由规则集”就是”包含一个或者多个路由规则的集合”

如何添加&#x2F;自定义路由规则集？添加规则集的目的：不同的路由规则集对应不同的代理模式，可以分别对应“PAC 模式”、“绕过大陆”、“全局代理”等等，来满足自己不同的“科学上网”或者“其他特殊的需求”。
1、下载 Geo 路由规则文件（推荐 V2ray路由加强版）：点击跳转2、普通用户： 直接启用“默认的基础路由规则”，并按照自己的需求和格式要求，在对应的对话框输入内容。

3. 路由规则输入的格式默认的“基础功能”—“一键导入基础规则”
可以在对应的对话框，输入单个网址或者 IP，多个选项，用英文输入方法下的逗号”,” 隔开。比如，在”阻止的Domian或 IP” 输入“domian:jamesdailylife.com”；此时，就不能访问该网址。
启用 “geoip.data” 和 “geosite.data”中，已经包含常用的域名和IP。使用方式：geosite:filename，如 geosite:google 表示对文件内符合 google 内包含的域名，按照自身需求录入到“代理、直连、阻止” ，就行了。

“代理的Domian或 IP”：此对话框的域名或者IP 走代理

“直连的Domian或 IP”：此对话框的域名或者IP 不走代理

“阻止的Domian或 IP”：此对话框的域名或者IP 不能访问




相关域名和IP分类名的解释

category-ads：包含了常见的广告域名。category-ads-all：包含了常见的广告域名，以及广告提供商的域名。cn：相当于 geolocation-cn 和 tld-cn 的合集。apple：包含了 Apple 旗下绝大部分域名。google：包含了 Google 旗下绝大部分域名。microsoft：包含了 Microsoft 旗下绝大部分域名。facebook：包含了 Facebook 旗下绝大部分域名。twitter：包含了 Twitter 旗下绝大部分域名。telegram：包含了 Telegram 旗下绝大部分域名。geolocation-cn：包含了常见的大陆站点域名。geolocation-!cn：包含了常见的非大陆站点域名，同时包含了 tld-!cn。tld-cn：包含了 CNNIC 管理的用于中国大陆的顶级域名，如以 .cn、.中国 结尾的域名。tld-!cn：包含了非中国大陆使用的顶级域名，如以 .hk（香港）、.tw（台湾）、.jp（日本）、.sg（新加坡）、.us（美国）.ca（加拿大）等结尾的域名。
category-games： 包含了 steam、ea、blizzard、epicgames 和 nintendo 等常见的游戏厂商。更多域名类别，请查看 data 目录 。

4. “启用路由高级功能”后，自定义路由规则集的方法有点不同。A. 添加已经编写好&#x2F;在使用的路由规则集：
“从文件中导入规则”： 导入本地的”路由规则集文件”
“从剪贴板中导入规则”： 复制“其他人分享的路由规则集范本”（文章末尾有）
“从订阅Url中导入规则”： 粘贴“别人分享的、含有路由规则集的url链接”

订阅url地址，不是机场的订阅地址，而是含规则集的 url 地址。
除了规则以外的请求，都走“代理”就是白名单模式；都走“直连”就是黑名单模式。
B.添加单个或者多个路由规则：
“Proxy” ： 走代理的域名或者IP
“Direct” ：不走代理的域名或者IP
“Block”： 不能访问的域名或者IP
“Port”：目标端口范围，当目标端口落在此范围内时，此规则生效



5. 特别注意：越靠前的规则，优先级越高；简单来说，优先使用“排在前面的路由规则”对产生的流量进行删选！！！使用加强版 v2ray 路由规则文件，一定特别“设置geoip.dat和geosite.dat文件不跟随core更新”

高级用法v2fly&#x2F;domain-list-community 项目 data 目录中某些列表里的规则会被标记诸如 @cn 的 attribute（如下所示），意为该域名在中国大陆有接入点，可直连。
steampowered.com.8686c.com @cnsteamstatic.com.8686c.com @cn

对于玩 Steam 国区游戏，想要直连的用户，可以设置类别 geosite:steam@cn 为直连，意为将 steam 列表内所有被标记了 @cn attribute 的规则（域名）设置为直连。同理，由于 category-games 列表包含了 steam、ea、blizzard、epicgames 和 nintendo 等常见的游戏厂商。设置类别 geosite:category-games@cn 为直连，即可节省大量服务器流量。

 注意：在 Routing 配置中，类别越靠前（上），优先级越高，所以 geosite:category-games@cn 等所有带有 @cn attribute 的规则都要放置在 geosite:geolocation-!cn 前（上）面才能生效。
category-games 列表内的规则（域名）可能会有疏漏，请留意规则命中情况。如发现遗漏，欢迎到项目 v2fly&#x2F;domain-list-community 提 issue 反馈。

路由规则集范本请先“启用高级路由规则”，按照视频教程添加规则：点击跳转谢谢网友“ANGIANAPR”的分享：点击跳转 GitHub
2dust 大佬分享的白名单和黑名单规则集范例
在4.14、4.13 版客户端中，在电脑能“富强&#x2F;科学上网”的前提下，
才能通过黑白名单范例的 URL 添加规则集！（见下图）

白名单范例：https://raw.githubusercontent.com/2dust/v2rayCustomRoutingList/master/custom_routing_rules_whitelist
黑名单范例：https://raw.githubusercontent.com/2dust/v2rayCustomRoutingList/master/custom_routing_rules_blacklist


1. PAC模式&#x2F;GFW 模式，带广告屏蔽的：
[  &#123;    &quot;outboundTag&quot;: &quot;block&quot;,    &quot;domain&quot;: [      &quot;geosite:category-ads-all&quot;,    ]  &#125;,  &#123;     &quot;outboundTag&quot;: &quot;proxy&quot;,     &quot;ip&quot;: [       &quot;geoip:telegram&quot;     ],     &quot;domain&quot;: [       &quot;geosite:gfw&quot;    ]  &#125;,  &#123;    &quot;port&quot;: &quot;0-65535&quot;,    &quot;outboundTag&quot;: &quot;direct&quot;  &#125;]

2. PAC模式&#x2F;GFW 模式，不带广告屏蔽：
[  &#123;     &quot;outboundTag&quot;: &quot;proxy&quot;,     &quot;ip&quot;: [       &quot;geoip:telegram&quot;     ],     &quot;domain&quot;: [       &quot;geosite:gfw&quot;    ]  &#125;,  &#123;    &quot;port&quot;: &quot;0-65535&quot;,    &quot;outboundTag&quot;: &quot;direct&quot;  &#125;]

3. 全局代理：
[  &#123;    &quot;outboundTag&quot;: &quot;proxy&quot;,    &quot;port&quot;: &quot;0-65535&quot;,  &#125;]

4. “解决Mirosoft Store等UWP软件无法访问”：点击跳转
延伸阅读：什么是路由规则？是将入站数据（用户请求）按需求由不同的出站连接发出，以达到按需求进行代理的目的。
常见用法是分流国内外流量，V2Ray 可以通过内部机制判断不同地区的流量，然后将它们发送到不同的出站代理。
简单地说，先设置相关路由规则， 经过 geo文件来判断目标是否命中相关路由规则，从而决定是否走代理出站(局域网也已绕过)。 

怎么在v2rayN 客户端自定义DNS？

参考链接4.12 最新 v2rayN windows 进阶版使用教程 | 附PAC模式路由规则 | 多个自定义路由规则
V2Ray 路由规则文件加强版  
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>翻墙杂项</title>
    <url>/posts/126dc918/</url>
    <content><![CDATA[目录一级域名yahyav2rayssr.top
namesilo


用户名
邮箱
密码



yahya-yaoyuming
&#54;&#x37;&#50;&#53;&#53;&#52;&#x37;&#56;&#52;&#64;&#113;&#x71;&#x2e;&#x63;&#x6f;&#109;
Yao88219620ko!


cloudflare


邮箱
密码



&#x36;&#x37;&#x32;&#53;&#x35;&#x34;&#x37;&#56;&#x34;&#x40;&#113;&#113;&#46;&#99;&#x6f;&#109;
Yao88219620ko!


端口说明文档参考链接：https://developers.cloudflare.com/fundamentals/get-started/reference/network-ports/
已开放HTTPS端口有：443, 2053, 2083, 2087, 2096, 8443
全局API KEY:
66f6f58b393232b878e6a855ab40944431724

hosteONS
VPS 服务器信息。
IP付款链接： https://my.hosteons.com/viewinvoice.php?id=107772&amp;paymentsuccess=true




邮箱
密码



&#x36;&#x37;&#x32;&#x35;&#x35;&#x34;&#55;&#56;&#x34;&#64;&#113;&#113;&#46;&#x63;&#x6f;&#109;
Yao88219620ko!


x-ui 面板信息


访问地址
用户名
密码



https://194.33.38.170:8443/ 或者 https://vless.yahyav2rayssr.top:8443
admin
7613302589


x-ui 安装
这里采用 centos7-minin 系统。

系统安装证书前置命令：
yum -y install crontabsyum -y install openssl openssl-develcurl https://get.acme.sh | shyum update -y          # Debian/Ubuntu 命令yum install -y curl socat    #Debian/Ubuntu 命令

x-ui 面板安装：
bash &lt;(curl -Ls https://raw.githubusercontent.com/vaxilu/x-ui/master/install.sh) 

]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>parsec 账号信息</title>
    <url>/posts/e7ec76f5/</url>
    <content><![CDATA[账号信息


账号类型
邮箱地址
手机号
密码



主邮箱
&#x36;&#x37;&#50;&#53;&#53;&#x34;&#55;&#x38;&#x34;&#x40;&#113;&#x71;&#x2e;&#x63;&#x6f;&#x6d;
13580367153
Yao8282925ok!


辅助邮箱
&#121;&#97;&#111;&#121;&#x75;&#109;&#105;&#x6e;&#x67;&#x37;&#x35;&#64;&#x67;&#x6d;&#x61;&#105;&#108;&#46;&#99;&#111;&#109;
13580367153
Yao8282925ok!


parsec_backup_codes04855980804001280718903400166003031627442659136389041915238730673248801690064824
]]></content>
      <categories>
        <category>网站账号</category>
      </categories>
      <tags>
        <tag>parsec</tag>
      </tags>
  </entry>
  <entry>
    <title>vps 服务器信息</title>
    <url>/posts/c491f2c3/</url>
    <content><![CDATA[目录HostEONS 服务器信息IP：194.33.38.170
用户名：root
密码：Yahya88219620ko
VNCIP：103.114.160.14
Port: 6198
密码：76133
]]></content>
      <categories>
        <category>网站账号</category>
      </categories>
      <tags>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>zoilr 账号信息</title>
    <url>/posts/6bf18a3f/</url>
    <content><![CDATA[目录网址https://zoilr.com
订单查询https://zoilr.com/user/index/query
账号邮箱：&#x36;&#x37;&#50;&#53;&#53;&#x34;&#55;&#x38;&#x34;&#64;&#x71;&#x71;&#46;&#x63;&#x6f;&#x6d;
查询密码：Yao88219620ko
网易邮箱邮箱：&#x79;&#97;&#x6f;&#x79;&#117;&#109;&#105;&#x6e;&#x67;&#x38;&#x30;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#x6d;
密码：Yao88219620ko
苹果账号
原始账号信息：
苹果账号【&#99;&#106;&#x65;&#x70;&#120;&#104;&#x62;&#x6e;&#100;&#64;&#x68;&#x6f;&#x74;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;】苹果密码【Qqz112211】修改资料教程【www.qtao.ink/f519】收到当日必须按教程修改全部资料包括邮箱，否则一切问题自行承担；生日【1983年1月21日】密保问题答案【朋友的名字：A111，理想的工作：B111，父母在哪认识：C111】禁止登陆iCloud（只要不是AppStore里登录都是错误的）【正确登陆教程：www.qtao.ink/ae07】常见问题（密码错误&#x2F;无法登陆&#x2F;无法更新等）解决方法【www.qtao.ink/WXMs】

用户名：&#121;&#97;&#111;&#121;&#117;&#x6d;&#x69;&#110;&#x67;&#x38;&#x30;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#111;&#109;
密码：Yahya88219620ko
]]></content>
      <categories>
        <category>网站账号</category>
      </categories>
      <tags>
        <tag>zoilr</tag>
      </tags>
  </entry>
  <entry>
    <title>哔哩哔哩私人信息</title>
    <url>/posts/e79f5c74/</url>
    <content><![CDATA[注册时间参考网址，取里面的jointime字段

https://member.bilibili.com/x2/creative/h5/calendar/card?ts=0

https://member.bilibili.com/x2/creative/h5/calendar/event?ts=0

https://api.bilibili.com/x/space/myinfo


实际效果如图所示：


取得的注册时间为：2015年10月11号
个人ID链接：https://account.bilibili.com/account/setting
个人ID：bili_4795208417
]]></content>
      <categories>
        <category>网站账号</category>
      </categories>
      <tags>
        <tag>bilibili</tag>
      </tags>
  </entry>
  <entry>
    <title>vmware 网络配置</title>
    <url>/posts/da1888d/</url>
    <content><![CDATA[目录网卡配置桥接模式参考链接Mac VMware fusion10 Centos7网络配置
如何使VMware ip与本机ip处于同一网段
CentOS 7 在vmware中的网络设置
]]></content>
      <categories>
        <category>运维</category>
        <category>vmware</category>
      </categories>
      <tags>
        <tag>vmware</tag>
      </tags>
  </entry>
  <entry>
    <title>gpedit 常用配置</title>
    <url>/posts/9e487b57/</url>
    <content><![CDATA[关闭 Antimalware Service Executable

Antimalware Service Executable是什么 如何关闭Antimalware Service Executable进程是微软杀毒软件Windows Defender的相关系统进程,是个正常的系统进程，其工作时经常会出现高CPU、高内存与高磁盘的情况。
关闭步骤：1、win键+R，输入“gpedit.msc”，打开“本地组策略编辑器”；2、依次选择“计算机配置”-“管理模板”-“Windows组件”-“Windows Defender防病毒程序”；3、找到“关闭Windows Defender防病毒程序”选项，右键“编辑“，选择“已启用”，确定即可；
]]></content>
      <categories>
        <category>运维</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>gpedit</tag>
      </tags>
  </entry>
  <entry>
    <title>字体替换</title>
    <url>/posts/7e3491fa/</url>
    <content><![CDATA[字体替换1. 方式一1. 替换系统字体
powershell 命令

覆盖文件move-item [源文件] [目标文件] -force

删除文件
delete-item [文件]



重启电脑，进入安全模式，然后打开 CMD 命令行窗口，将需要替换的字体放到下 c:\fonts 目录下，然后执行以下命令：
xcopy C:\fonts C:\Windows\Fonts

2. 方式二（无须进入安全模式，推荐）1. 替换 CMD 默认字体
如果强制覆盖了 SimSun &amp; NSimSun (TrueType) 和 SimSun-ExtB (TrueType)（原始字体分别对应 simsun.ttc 和 simsunb.ttf），会出现重启之后无法打开 CMD 命令行窗口的情况，所以需要对 CMD 命令行的默认字体做切换。

运行 regedit，然后打开如下的键：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Console\TrueTypeFont，如下图所示：


鼠标右键，然后新建字符串值：


输入 0 或者 00 或者 000 或者 0000，每增加一个字体，增加一个0，这里增加的 Consolas-with-Yahei 第四个新的字体，因此使用的是0000，然后选中 0000 这一项，修改，在弹出框中输入字体 Consolas-with-Yahei，如下所示：


这样子就修改完成了，我们需要进入到 CMD 下，然后在窗口标题栏上右键 -&gt; Options -&gt; 打开字体面板， 发现没有出现注册表中的字体，我们需要回到 CMD 下，输入以下命令：
chcp 437

然后会切换字体。这时候再来看字体这里，就会出现新的字体，选择我们需要的字体，然后确定就OK了。
这里附带一个永久修改 Active Code Page 的办法：
有时候，我们的 CMD 的 codepage 和字体等会变化，比如突然由中文变成英文的 codepage（因为一些sh程序的干扰）
下面是修正方法：
进入 HKEY_CURRENT_USER\Console\%SystemRoot%_system32_cmd.exe，编辑 CodePage 项，设置为如下的数值：

数值含义如下：

十六进制 000003a8 或十进制 936，表示 936 (ANSI&#x2F;OEM - 简体中文 GBK)。
十六进制 000001b5 或十进制 437，表示 437 (OEM - 美国)。


效果如下图所示：


2. 替换系统字体键盘上 Windows + R，打开运行后输入 regedit。
找到路径：计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts，如下图所示：




点击后面有默认字样的字体，鼠标右键，修改：Microsoft YaHei &amp; Microsoft YaHei UI (TrueType)，这是系统默认的字体。如下图所示。


点击确定后，再找到 Microsoft YaHei Bold &amp; Microsoft YaHei UI Bold (TrueType)，检查是否一致。


重启电脑，字体生效。
]]></content>
      <categories>
        <category>运维</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 常用命令</title>
    <url>/posts/7101b844/</url>
    <content><![CDATA[目录转换磁盘convert [driver] /fs:ntfs
查看局域网所有IParp -a
CMD临时代理set http_proxy=http://127.0.0.1:1080set https_proxy=http://127.0.0.1:1080
设置IP、DNS、网关netsh interface ip set address name=&quot;本地连接&quot; source=static addr=192.168.132.5 mask=255.255.255.0netsh interface ip set address name=&quot;本地连接&quot; gateway=192.168.132.1 gwmetric=0netsh interface ip set dns name=&quot;本地连接&quot; source=static addr=192.168.132.1 register=PRIMARYnetsh interface ip set wins name=&quot;本地连接&quot; source=static addr=none
查看IP、DNS、网关netsh interface ip show address
清除DNS缓存ipconfig /flushdns

重置Winsock目录netsh winsock reset

tasklist
&#x2F;S     system           指定连接到的远程系统。  
&#x2F;U     [domain]user    指定使用哪个用户执行这个命令。  
&#x2F;P     [password]       为指定的用户指定密码。  
&#x2F;M     [module]         列出调用指定的 DLL 模块的所有进程。如果没有指定模块名，显示每个进程加载的所有模块。  
&#x2F;SVC                   显示每个进程中的服务。  
&#x2F;V                      指定要显示详述信息。  
&#x2F;FI    filter           显示一系列符合筛选器指定的进程。  
&#x2F;FO    format           指定输出格式，有效值: “TABLE”、”LIST”、”CSV”。  
&#x2F;NH                     指定栏标头不应该在输出中显示。只对 “TABLE” 和 “CSV” 格式有效。

taskkill
TASKKILL [&#x2F;S system [&#x2F;U username [&#x2F;P [password]]]]  
{ [&#x2F;FI filter] [&#x2F;PID processid | &#x2F;IM imagename] } [&#x2F;F] [&#x2F;T]

端口转发# 执行命令netsh interface portproxy add v4tov4 listenaddress=[LOCAL_HOST]  listenport=[LOCAL_PORT]  connectaddress=[TARGET_HOST] connectport=[TARGET_PORT]# 例netsh interface portproxy add v4tov4 listenaddress=100.120.9.96  listenport=2222  connectaddress=10.206.230.177 connectport=22# 查看现有的配置netsh interface portproxy show all# 删除原有的端口转发netsh interface portproxy delete v4tov4 listenaddress=[LOCAL_HOST]  listenport=[LOCAL_PORT]# 例netsh interface portproxy delete v4tov4 listenaddress=100.120.9.96  listenport=2222

Diskpart 手动创建 EFI、MSR 引导分区用傲梅分区助手将磁盘转换为GPT格式创建 EFI 分区diskpartlist diskselect disk x   (选择需要的硬盘)create partition efi size=100assign letter=bformat quick fs=FAT32

创建 msr 分区create partition msr size=16  (Win 10 默认是16M) 

创建 Recovery 分区 (WindowsRE)create partition primary size=450format quick fs=ntfs label=&quot;Recovery&quot;assign letter=&quot;R&quot;set id=&quot;de94bba4-06d1-4d40-a16a-bfd50179d6ac&quot;gpt attributes=0x8000000000000001      ( 8 和 1之间有14个0)

IP释放、更新、以及清除 DNS
在桌面上，按Windows键，然后输入CMD。
右键单击“ 命令提示符”，然后选择“以管理员身份运行”。
在命令提示符下输入ipconfig / release。
等待几秒钟可以得到IP地址已释放。
在命令提示符下输入ipconfig /renew。
等待几秒钟可以得到已重新建立IP地址。
在命令提示符下输入ipconfig / flushdns。
关闭命令窗口并尝试建立连接。

]]></content>
      <categories>
        <category>运维</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 常用配置</title>
    <url>/posts/d741411d/</url>
    <content><![CDATA[目录设置U盘插入电脑后自动打开文件夹播放更改媒体或设备的默认设置


选择需要的选项即可，如下图所示：


修改时区方法一
使用「Windows 设置」自动设置时区


使用 Windows + I 快捷键打开「Windows 设置」
打开「时间和语言」——「日期和时间」
启用「自动设置时区」开关



方法二使用「命令提示符」调整时区，执行以下命令以查看当前时区设置：
tzutil /g

如果要调整时区设置，可使用以下命令：
tzutil /s &quot;China Standard Time&quot;



上述是以中国标准时间为例，如果要列出所有可用时区选项，可用：
tzutil /l



方法三
使用 Powershell 调整时区。

使用 Windows + X 快捷键打开快捷菜单——选择 Windows PowerShell（管理员），执行以下命令查看当前时区设置：
Get-TimeZone

执行以下命令列出可用时区列表：
Get-TimeZone -ListAvailable



使用以下命令调整时区设置：
Set-TimeZone -Name &quot;China Standard Time&quot;

解决Windows 10下蓝牙设备无法删除的故障在更换了一张无线网卡（蓝牙适配器跟无线网卡是集成在一起的）后，蓝牙设备全失联了，想要重新配对，可是原有设备无法删除。


蓝牙设备无法删除，折腾了好久啊，最后突然发现了如下方法，打开“计算机管理”中的“设备管理器”节点，在该节点上右击后点“查看”然后勾选“显示隐藏的设备”如下图：


勾选“显示隐藏的设备”， 在右边蓝节节点，找到要删除的蓝牙设备，在其上点右键，选择“卸载设备”。


卸载设备，依次把要删除的多个设备全卸载，问题就解决了。
删除右键菜单 AMD 选项打开 regedit 菜单，进入到 计算机\HKEY_CLASSES_ROOT\Directory\Background\shellex\ContextMenuHandlers\ace 路径，找到默认值，右键删除即可。

]]></content>
      <categories>
        <category>运维</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 常见错误</title>
    <url>/posts/dfcbdf9f/</url>
    <content><![CDATA[目录dll 注册for %1 in (%windir%\system32\*.dll) do regsvr32.exe /s %1for %1 in (%windir%\system32\*.dll) do regasm.exe /s %1

模块xxx已加载，但找不到入口点DllRegisterServer



使用regasm注册.net com组件出现不是有效的.net程序集的解决办法在电脑上装有VS 2008和VS 2010.使用VS 2010编写了一个C# com组件:MyCom（基于.net framework4.0），然后使用VS 2008的命令提示工具运行命令：regasm MyCom，结果提示错误：RegAsm：error RA0000,“MyCOM”不是有效的.net程序集。开始百思不得其解。后来才醒悟到VS 2008的命令提示工具运行的regasm.exe是vs2008版本，它可能注册不了基于.net framework4.0的C# com组件。后来发现确实是这样的。如果一台机子上装有VS 2008和VS 2010，那么它就有两个版本的regasm.exe，分别存放的位置是C:\Windows\Microsoft.NET\Framework\v2.0.50727和C:\Windows\Microsoft.NET\Framework\v4.0.30319.使用VS 2010版本的regasm能注册vs2008编写的C# com组件，但是使用vs2008版本的regasm不能注册基于.net framework4.0的C# com组件。
程序无法正常启动 0xc0000142 解决方法在命令下执行
for %1 in (%windir%\system32\*.dll) do regsvr32.exe /s %1 
完成后重启如果不能解决，继续以管理员身份运行命令提示符中依次执行以下命令
DISM/Online /Cleanup-image /ScanhealthDISM/Online /Cleanup-image /RestorehealthSfc /scannow]]></content>
      <categories>
        <category>运维</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 开启 FTP</title>
    <url>/posts/b7b934f4/</url>
    <content><![CDATA[WIN10开启FTP1.控制面板 –&gt; 程序–&gt; 启用或关闭windows功能

2.左下角搜索栏搜索IIS（iis）3.右键添加FTP站点

4.创建站点名字和目录5.绑定本机IP地址，SSL勾选无SSL4426.身份验证 –&gt;匿名，授权 –&gt; 所有用户，权限 –&gt;读取写入7.控制面板 –&gt; 系统和安全 –&gt; Windows Defender 防火墙 –&gt; 允许应用或功能通过Windows Defender 防火墙 8.更改设置 –&gt; 勾选 FTP 服务器9.设置应用路径（C:\Windows\System32\svchost.exe）10.使用ftp访问（格式为ftp:&#x2F;&#x2F; + 要访问的IP地址）]]></content>
      <categories>
        <category>运维</category>
        <category>windows</category>
      </categories>
      <tags>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title>运维常用命令-常用篇</title>
    <url>/posts/e9ae7850/</url>
    <content><![CDATA[1. ls 系列
-F：根据文件、目录等信息在文件名或目录名最后给予附加数据结构

*  代表可执行文件；
&#x2F;  代表目录
&#x3D;  代表socket文件
|  代表FIFO文件
@  代表连接文件


1. 只显示文件类型，排除目录方法一：
^[^d] 是一个正则表达式，[^d] 表示字符串含有一个不是 d 的字符， ^d 表示以 d 开头，^[^d] 表示不以 d 开头

ls -l | grep ^[^d]

所以只显示文件夹的写法为：
ls -l | grep ^d

方法二：ls -l | grep -v ^d

如果文件名包含空格，可以用下面命令：
ls -l | grep -v [/$]


2. sed 系列1. 替换字符串sed &#x27;s/old/new/g&#x27;

3. rm 系列1. 删除带有指定字符串的文件方法一：
注意字符串如果含有特殊字符，必须做转义处理，否则默认会删除当前目录下的所有文件。

rm -f *字符串*

方法二：find -type f -name &#x27;*字符串*&#x27; -delete

4. awk 系列1. 获取某一行中指定字符后的内容比如有个xxx.txt文件，里面有很多行内容，其中有行内容为ro.xxx&#x3D;123，要想获取到123这个值，可以如下处理
#!/bin/shNAME=`cat xxx.txt | grep &#x27;ro.xxx&#x27; | awk -F &#x27;=&#x27; &#x27;&#123;print $2&#125;&#x27;`echo $NAME

5. $(cd dirname $0;pwd)cd &quot;$(dirname &quot;$0&quot;)&quot;;pwd 等同于 $(dirname $(readlink -f &quot;$0&quot;))
# 在/home/admin/test/下新建test.sh内容如下：cd `dirname $0`echo `pwd` # 然后返回到/home/admin/执行sh test/test.sh # 运行结果:/home/admin/test

6. basename1. basename打印除上层路径外的基础文件名；当文件名后存在后缀时，除去后面的后缀，如 # basename include&#x2F;stdio.h .h 只会打印出 stdio
2. basename -s-s参数后面指定要去除的后缀字符，即：# basename -s .h include&#x2F;stdio.h 同 # basename include&#x2F;stdio.h .h 一样只会打印出 stdio
3. basename -a-a参数可追加执行多个文件路径，取每一个路径的基础文件名并打印。用法如下图：


7. pwd1. pwd -L打印出环境变量 $PWD 的值，如果 PWD 赋值为当前工作路径，pwd 默认同 pwd -L
2. pwd -P打印真实路径，不打印链接的路径，区别如图：


8. watch命令参数：
-n 或 –interval watch 缺省每2秒运行一下程序，可以用 -n 或 -interval 来指定间隔的时间。
-d 或 –differences 用 -d 或 –differences 选项 watch 会高亮显示变化的区域。 而 -d&#x3D;cumulative 选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。
-t 或-no-title 会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。
示例：
watch -n 1 -d &quot;&lt;command&gt;&quot;

9. grep


元字符
功能
例子
匹配什么



^
锚定行的开始
&#x2F;^love&#x2F;
匹配所有以love开头的行


$
锚定行的结束
&#x2F;love$&#x2F;
匹配所有以love 结束的行


.
匹配一个字符
&#x2F;l..e&#x2F;
匹配这样的行，这些行包含这样的字符：第一个字符是l,紧跟着两个字符，然后是e


*
代表0个或多个先前字符
&#x2F;*love&#x2F;
匹配所有这样的行，有0个或多个空格，空格后跟着love


[]
匹配字符组中的一个字符
&#x2F;[Ll]ove&#x2F;
匹配所有包含love或者Love的行


[^]
匹配一个不在范围内的字符
&#x2F;[^A-Z]ove&#x2F;



&lt;
锚定单词的开始
&lt;love
匹配所有这样的行，这些行包含以love开头的单词（vi和grep支持这个功能）


&gt;
锚定单词的结束
Love&gt;
匹配所有这样的行，这些行包含以love结束的单词（vi和grep支持这个功能）


(..)
标记后面用到的匹配字符
&#x2F;(love)able1rs&#x2F;
最多可以使用9个标签。第一个标签是模板最左边的部分。在本例子中，模板love保存的标签为1，后面的1指得就是love；本例子搜索的是这样的行，这些行包含这样的字符，在Loveabel后面跟着lovers


x{m}
M次复制字符x




x{m,}
至少m次复制字符x




x{m,n}
至少m次，至多n次复制字x




w
文字和数字字符，[A-Za-z0-9]
Lw*e
匹配一个l字符，紧跟着0个或多个文字或数字字符，然后是e


W
同上




b
单词分界线
bloveb
仅仅匹配单词love


递归查找某个文本内容
R 表示递归，就是在当前目录找不到就去子目录找 
E 表示把文件名也打印出来 
n 打印此行在文件中的位置。

示例：
# 这句可以显示在哪个文件里包含3306grep -Rl &quot;3306&quot;# 可以显现文件名，行数grep -REn &quot;3306&quot;

查找替换内容# sed -i &quot;s/[原字符串]/[新字符串]/g&quot; `grep &#x27;[原字符串]&#x27; -rl /opt/kubernetes`# 示例：替换/opt/kubernetes下所有文件内容为242的换成245sed -i &quot;s/242/245/g&quot; `grep &#x27;242&#x27; -rl /opt/kubernetes`

10. 查看端口占用查看那些程序使用tcp的80端口$fuser -v -n tcp 80$fuser -v 80/tcp  

]]></content>
      <categories>
        <category>运维</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title>运维常用命令-常用配置篇</title>
    <url>/posts/c3218428/</url>
    <content><![CDATA[禁止pingLinux默认是允许Ping响应的，系统是否允许Ping由2个因素决定的：A、内核参数，B、防火墙，需要2个因素同时允许才能允许Ping，2个因素有任意一个禁Ping就无法Ping。
内核参数设置允许PING设置
临时允许PING操作的命令为：echo 0 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all

永久允许PING配置方法。
&#x2F;etc&#x2F;sysctl.conf 中增加一行
  net.ipv4.icmp_echo_ignore_all=0

如果已经有net.ipv4.icmp_echo_ignore_all这一行了，直接修改&#x3D;号后面的值即可的（0表示允许，1表示禁止）。
修改完成后执行以下命令，使新配置生效。
sysctl -p

防火墙设置
注：此处的方法的前提是内核配置是默认值，也就是没有禁止Ping。

以Iptables防火墙为例
允许PING设置iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPTiptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT

或者也可以临时停止防火墙操作的。
service iptables stop

禁止PING设置iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROP

]]></content>
      <categories>
        <category>运维</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>运维配置</tag>
      </tags>
  </entry>
  <entry>
    <title>运维常用命令-时间篇</title>
    <url>/posts/c72fbcb5/</url>
    <content><![CDATA[linux 查看系统当前时间，修改时间，查看文件时间查看时间和日期date

设置时间和日期例如：将系统日期设定成2018年6月8日的命令
date -s 06/08/2018

将系统时间设定成下午10点46分03秒的命令
date -s 10:46:03

查看时区date -R

查询系统当前日期date +&quot;%Y-%m-%d&quot;

查询系统当前时间date +&quot;%H-%M-%S&quot;

查看文件时间ls -l 或者 ll


要显示秒（实际更精确），可以用 --full-time 参数


要显示更多信息，用 stat 命令：
]]></content>
      <categories>
        <category>运维</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>运维配置</tag>
      </tags>
  </entry>
  <entry>
    <title>运维常用命令-系统篇</title>
    <url>/posts/85b72ed0/</url>
    <content><![CDATA[设置 hostname
hostname 存放于 /etc/host/hostname

hostnamectl set-hostname [hostname]

查看用户和用户组查看用户列表cat /etc/passwd



查看用户组列表cat /etc/group



查看系统中有哪些用户cut -d : -f 1 /etc/passwd



查看可以登录系统的用户cat /etc/passwd | grep -v /sbin/nologin | cut -d : -f 1



查看用户操作w (root权限)



查看某一用户w &lt;user_name&gt;



查看登录用户who



查看用户登录历史记录last



修改root用户密码passwd



root用户修改其他用户密码passwd &lt;user_name&gt;



重启init 6init 6 基于一系列 /etc/inittab 文件，并且每个应用都会有一个相应 shutdown 脚本。init 6 调用一系列 shutdown 脚本(&#x2F;etc&#x2F;rc0.d&#x2F;K*)来使系统优雅关机。
rebootreboot 并不执行这些过程，reboot更是一个 kernel 级别的命令，不对应用使用 shutdown 脚本。
综上平常推荐使用 init 6 命令，只有在系统出了问题的时候才比较推荐使用 reboot 命令。
]]></content>
      <categories>
        <category>运维</category>
        <category>常用命令</category>
      </categories>
      <tags>
        <tag>运维配置</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab 安装</title>
    <url>/posts/fc8249c5/</url>
    <content><![CDATA[目录安装
gitlab 运行需要较大内存，建议将虚拟机内存设置为 4GB 以上，并保证相关端口不被其他进行占用。

安装相关依赖yum -y install policycoreutils openssh-server openssh-clients postfix

设置 postfix
设置 postfix 为开机自启动，目的：支持 gitlab 邮件发送。

systemctl enable postfix &amp;&amp; systemctl start postfix

rpm 包安装官方参考链接：https://packages.gitlab.com/gitlab/gitlab-ce/install#bash-rpm
使用以下命令进行快速安装：
curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash


EL 是 Red Hat Enterprise Linux 的简写 

EL6 软件包用于在 Red Hat 6.x, CentOS 6.x, and CloudLinux 6.x 的安装。
EL5 软件包用于在 Red Hat 5.x, CentOS 5.x, CloudLinux 5.x 的安装。
EL7 软件包用于在 Red Hat 7.x, CentOS 7.x, and CloudLinux 7.x 的安装。


所以这里我们采用安装 EL7 的模式，安装命令如下：
官方参考链接：https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-15.8.5-ce.0.el7.x86_64.rpm
sudo yum -y install gitlab-ce-15.8.5-ce.0.el7.x86_64

安装完毕后的主体文件都在 /opt/gitlab/ 目录下，可自行翻阅按需修改。
修改 root 密码官方修改密码：(http://docs.gitlab.com/ce/security/reset_root_password.html)
在root用户下，执行
# 老版命令gitlab-rails console production# 新版命令gitlab-rails console -e production

获得用户数据，修改用户密码
[root@svr34 bin]# gitlab-rails console productionLoading production environment (Rails 4.2.5.2)irb(main):001:0&gt; user = User.where(id: 1).first=&gt; #&lt;User id:1 @root&gt;irb(main):002:0&gt; user.password=&quot;7613302589&quot;=&gt; &quot;12345678&quot;irb(main):003:0&gt; user.password_confirmation=&quot;7613302589&quot;=&gt; &quot;12345678&quot;irb(main):004:0&gt; user.save!=&gt; trueirb(main):005:0&gt; quit

修改访问 URL编辑 gitlab.rb 文件。
# vim /etc/gitlab/gitlab.rbexternal_url &#x27;http://192.168.50.245:8138&#x27;


此处注意别使用已被占用的端口！（如8080）



重置并启动 Gitlab重置：

注：第一次预计需要几分钟

gitlab-ctl reconfigure

启动：
gitlab-ctl restart

端口用途一览




端口号
归类
用途



8060
Nginx
用途不明


8138
Nginx
第二个 nginx 的端口，就是 gitlab 实例的主端口，所有外部访问的 http 均通过 gitlab 内置的 nginx 服务器处理，并使用该端口，当然暴露地址为外网0.0.0.0


9121
Redis
redis_exporter 的 9121，是 gitlab 内置 redis 数据库，只向本机暴露


9090
Prometheus
向本机暴露，用途应该是创建和管理时间序列事件的触发，如通知那些功能


9187
PostgreSQL
postgres_expoter 的9187，是 gitlab 内置的 postegres 数据库，向本机暴露


9093
Ruby
config.ru 的 9093，gitlab 使用 ruby 的 unicorn 作为 app server 运行，管理 worker 等功能，比较重要，默认为 8080，由于 8080 比较受欢迎，这个端口基本上都得改，暴露可自行设定；


9168
Ruby
用途不明


9100
NodeJS
node_exporter 的 9100，一个 nodejs 进程，用于实现测量所在的机器的资源状态比如cpu、内存、硬盘等数据的功能


9229
Go
gitlab-workhors 的 9229，一个是用 go 语言写的组件，是 gitlab 发展途中添加进来的用于优化 git over http 的组件，具体历史可以查看这里了解gitlab-workhors的由来


8082
其他
sidekiq 的 8082，是一种多线程后台处理系统，用于实现 gitlab 异步运行任务


9236
其他
gitaly 的9236，是一个能够提供访问 git 仓库的 RPC 远程调用功能的服务，属于 gitlab 的一个托管组件gitlab 的配置文件位于/etc/gitlab/gitlab/gitlab.rb，使用vim等工具可以直接修改，各种参数配置修改可以参考官方文档


nginx 代理关闭 selinux
什么是selinux ？
SELinux：即安全增强型 Linux（Security-Enhanced Linux）
它是一个 Linux 内核模块，也是 Linux 的一个安全子系统
它主要由美国国家安全局开发，主要作用是最大限度地减小系统中服务进程可访问的资源（最小权限原则）
为什么要关闭 selinux ？
有的软件对于 selinux 的安全规则支持不够好，就会建议在安装前把 selinux 先关闭，例如 k8s，本次在启动 nginx 的过程中发现 gitlab 会报 502 的错误，经由使用 journalctl -xe  命令发现有 selinux 的相关错误信息，所以需要把 selinux 做一次人工的手动禁用。
selinux 常用命令：
# 查看审计日志cat /var/log/audit/audit.log# 分析一个文件sealert -a /var/log/audit/audit.log# 查询系统中的布尔型规则及其状态getsebool -a

selinux的三种运行模式:

enforcing: 强制模式，SELinux 正在运行中，已经在限制 domain&#x2F;type
permissive: 宽容模式：SELinux 正在运行中，但仅发出警告信息,并不会实际限制 domain&#x2F;type 的存取（permissive模式可以用在测试环境中供调试规则时使用）
disabled: 关闭，SELinux 没有实际运行。

sestatus -v # 查看当前信息getenforce # 查看当前运行模式

临时关闭# 0: Permissive# 1: Enforcingsetenforce 0

永久关闭# vim /etc/selinux/configSELINUX=disabled

外部 nginx 安装添加 Nginx 到 YUM 源
sudo rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm

安装 nginx
sudo yum install -y nginx

启用 nginx
sudo systemctl enable nginx.service &amp;&amp; sudo systemctl start nginx.service

Nginx 常用配置目录如下：
# 资源文件目录/usr/share/nginx/html/├── 50x.html└── index.html# 配置文件主目录/etc/nginx/├── conf.d│   ├── default.conf│   └── gitlab.conf # gitlab 配置文件├── fastcgi_params├── mime.types├── modules├── nginx.conf # nginx 根目录配置文件├── scgi_params└── uwsgi_params

代理 gitlab 内部 nginxgitlab 服务器主体框架如下：


nginx 配置文件gitlab.conf 配置文件内容如下：
# 主访问入口server &#123;  listen 80;  server_name gitlab.yahya.top;  # 入口反向代理  location / &#123;    proxy_set_header Host $host;    proxy_set_header X-Real-IP $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_redirect off;    # 配置反向代理地址    proxy_pass http://192.168.50.245:8138;    proxy_http_version 1.1;    # 一定记得要配置 body_size    client_max_body_size 1024m;  &#125;&#125;

修改 gitlab.rb 文件

external_url 的配置直接影响到 gitlab 系统中所有 http 入口的地址，比如 git 仓库的 http 地址，gitlab 访问页面的地址，注册回调的地址，邮件验证的地址等。

编辑 gitlab.rb 文件
vim /etc/gitlab/gitlab.rb

配置域名external_url &#x27;http://gitlab.yahya.top&#x27;

修改对外主端口nginx[&#x27;listen_port&#x27;] = 8138

max_body_size 配置gitlab 是可以使用 http 和 ssh 两种方式来进行git操作的，当使用 http 时，是通过post请求发送内容，若 nginx 在代理时没有设置 body_size 时将会收到：413 Request Entity Too Large 的错误，push 不了代码，内外部的 nginx 都需要配置，在 gitlab.rb 中添加：
nginx[&#x27;client_max_body_size&#x27;] = &#x27;1024m&#x27;

认证普通用户
默认情况下注册的用户是需要进行审批，否则在没有审批的情况下登录会报以下的错误：
Your account is pending approval from your GitLab administrator and hence bl

登录 root 用户，点击头像这里


点击 Overview -&gt; Users -&gt; Pending approval，审批需要注册的用户即可。


临时关闭分支保护
git push 报错 pre-receive hook declined，原因为 master 为受保护分支，无法强推代码到 master 分支上。使用 Owner 以及 Admin 角色账号推送都无法成功。

Settings -&gt; Repository -&gt; Protected Branches 临时 Unprotect master 分支(强推成功后一定要重新添加为受保护的分支)


关于 GitLab 访问权限
访问权限 - Visibility Level：
这个是在建立项目时就需要选定的，主要用于决定哪些人可以访问此项目，包含 3 种：

Private - 私有，只有属于该项目成员才有看到
Internal - 内部，用 GitLab 账号的人都看到
Public - 公开，任何人可以看到

开源项目和组设置的是 Internal。
行为权限：
在满足行为权限之前，必须具备访问权限（如果没有访问权限，那就无所谓行为权限了），行为权限是指对该项目进行某些操作，比如提交、创建问题、创建新分支、删除分支、创建标签、删除标签等角色。

官方权限解释文档：https://docs.gitlab.com/ee/user/permissions.html#project-members-permissions


Guest - 访客
可以创建 issue、发表评论，不能读写版本库。

Reporter  - 报告者
可以理解为测试员、产品经理等，一般负责提交 issue 等 可以克隆代码，不能提交，QA、PM 可以赋予这个权限。

Developer - 开发者
可以克隆代码、开发、提交、push，RD 可以赋予这个权限。

Master - 主人
可以创建项目、添加 tag、保护分支、添加项目成员、编辑项目，核心 RD 负责人可以赋予这个权限。

Owner - 拥有者
可以设置项目访问权限 - Visibility Level、删除项目、迁移项目、管理组成员，开发组 Leader 可以赋予这个权限。

Maintainer - 维护者
权限与 Owner 差不多，但无删除项目等权限。


参见错误502 错误：
首先保证Gitlab可用运行内存大于 4G，端口未被占用
再赋予权限：
chmod -R 755 /var/log/gitlab

再重置重启，访问后仍然可能遇到502，不过我刷新2次就一切ok了。
参考文章使用Nginx搭建并代理GitLab服务器
Centos7 搭建Gitlab服务器并配置项目全过程
gitlab配置域名并https访问
linux(centos8):禁用selinux(临时关闭&#x2F;永久关闭)
]]></content>
      <categories>
        <category>运维</category>
        <category>常用安装</category>
      </categories>
      <tags>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 安装</title>
    <url>/posts/9d95a809/</url>
    <content><![CDATA[目录yum 源配置将 yun 源设置成阿里云的，可以大大提高安装速度，推荐使用，所需命令如下。
rm -rf /etc/yum.repos.d/*  # 删除本地repo文件curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo  ## 下载阿里云centos7镜像源yum clean all; yum makecache # 清理缓存、建立缓存

如果担心中途出其他问题先考虑先把原有 /etc/yum.repos.d 目录下的文件做一次备份方便还原。
git 安装yum install -y git

nodejs 安装wget https://nodejs.org/dist/v16.14.2/node-v16.14.2-linux-x64.tar.xztar -vxf node-v16.14.2-linux-x64.tar.xz   # 解压node.js软件压缩软件包mv node-v16.14.2-linux-x64 /usr/local/bin # 移动node到/usr/local/bin目录下cd /usr/local/bin/ # 进入/usr/local/binmv node-v16.14.2-linux-x64/ node # 修改node-v16.14.2-linux-x64 名称为 node

然后修改 /etc/profile 文件，增加以下配置：
export N_PREFIX=/usr/local/bin/node  # 设置node软件家目录的环境变量export PATH=$PATH:$N_PREFIX/bin  # 设置node软件到bin目录下环境变量  实现bin目录下命令的全局使用

最后执行 source /etc/profile 使配置生效，用以下命令验证确认 nodejs 已经安装成功。
node -vnpm -v

n 安装使用 n 可以对 nodejs 进行多版本管理，推荐使用 n 来切换管理 nodejs 版本，安装命令如下：
npm install -g n

常用命令如下：
n stable # 安装最新的稳定版n lts # 安装最新的 LTS 版n &lt;version&gt; # 安装指定的 node 版本

hexo 安装hexo 的安装比较简单，直接按照官网的说明步骤安装即可。首先是基础软件 nodejs 以及 git，这两个都是常用基础软件所以就不介绍细节了，官网直接安装即可。 按照使用了 npm 这个 nodejs 库管理软件，由于默认源在国外经常连接超时，所以首先需要修改成国内的镜像源，这里是改成了淘宝的镜像源。
npm config set registry https://registry.npm.taobao.org

接下来就是使用 npm 命令安装 hexo，推荐使用 cnpm
npm install -g cnpm --registry=https://registry.npm.taobao.orgcnpm install -g hexo-cli

关闭防火墙systemctl stop firewalld; systemctl disable firewalld

关闭 selinux临时关闭# 0: Permissive# 1: Enforcingsetenforce 0

永久关闭# vim /etc/selinux/configSELINUX=disabled

hexo 初始化

站点配置文件：站点目录下的_config.yml，路径为&lt;folder&gt;\_config.yml
主题配置文件：站点目录下的themes文件夹下的，主题文件夹下的_config.yml，路径为&lt;folder&gt;\themes\&lt;主题文件夹&gt;\_config.yml


新建一个目录，作为统一存放 markdown 文件的目录，然后进入到该目录下执行以下命令。
hexo init

markdown 菜单目录生成hexo 文件首部加上 toc: true，就可以在文章左侧生成目录，且可以正常跳转。因此你只用简单的加上toc: true即可，任何其他的操作都是不必要的。
如果你装了hexo的toc插件，请你删除它，它会影响你目录的跳转！使用下面的语句删除toc插件
npm remove hexo-toc --save

图片相对路径配置
hexo-renderer-marked 3.1.0 引入了一个新的选项，其允许你无需使用 asset_img 标签插件就可以在 markdown 中嵌入图片，如需启用，编辑 _config.yml，添加以下配置：

post_asset_folder: truemarked:  prependRoot: true  postAsset: true

安装以下依赖：
npm install https://github.com/7ym0n/hexo-asset-image --save # 解决 &lt;img /&gt; 图片标签相对路径问题npm install hexo-simple-image --save # 解决 ![]() 图片标签相对路径问题

最终效果如下：
├── hexo-asset-image@0.0.3 (git+ssh://git@github.com/7ym0n/hexo-asset-image.git#6c88c98214765112d148850a646ddca379fcdcfe)├── hexo-simple-image@1.0.4

这样子以 &lt;img /&gt; 和 ![]() 包裹的相对路径图片都可以正常显示了。
创建自定义 about 页博客是用的hexo，打算增加一个about页。
根据文档，当然非常简单，只需要：
hexo new page &quot;about&quot;

然后修改所用主题目录下的_config.yml文件，将menu中about前的注释去掉。
menu:  home:  / || home  about:  /about/ || user  tags:  /tags/ || tags  ...

然后修改source/about/目录中的index.md文件即可。
但是，我想要在页面中显示表格，而且不用markdown格式的表格。
经谷歌，可以直接在index.md中写html代码，这太好了。
可是，写好代码，hexo g之后，怪异的现象出现了，about页面中，页顶标题下是许多空白行，表格要下拉到页面最底部才可见。
又搜索之后，找到了答案，将 index.md 改名为 index.html，修改之后，马上显示正常了。
主题方案fluid代码高亮主题选择方案：https://highlightjs.org/static/demo/
使用手册：https://hexo.fluid-dev.com/docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B
next
参考配置：https://blog.csdn.net/as480133937/article/details/100138838

本地搜索NexT 主题自带了一个搜索功能 Local Search，即在编译文件时本地生成一个数据库，放在网站根目录下，用户借助此数据库进行搜索查询。 安装：
npm install hexo-generator-searchdb --save

在 NexT 的配置文件中打开：
local_search:  enable: true

图片懒加载# Vanilla JavaScript plugin for lazyloading images.# For more information: https://github.com/ApoorvSaxena/lozad.jslazyload: true

yilia-plus
参考配置：https://gitee.com/nate-lin/yilia-plus

远程发布github免密关联ssh-keygen

然后将生成的 id_rsa.pub 文件内容关联到 github 的 SSH and GPG Keys 菜单的下的 ssh key 列表


新建仓库仓库名称格式 &lt;你的 GitHub 用户名&gt;.github.io ，站点会通过这个名称实现域名访问

注意：仓库的访问权限需要设置为 public，否则无法通过 .github.io 域名的形式进行访问。



github page 暴露
参考链接：https://docs.github.com/en/pages/quickstart

默认情况下新建的仓库在 github page 是不关联任何分支的，即为 None，所以需要调整 Pages 配置为以下图示效果：


cloudflare 加速经实测 githubpage 在国内很容易被墙，所以决定在现有的 cloudflare 网站上做一层 CNAME 域名重定向访问到 github page 上，解决国内无法直接访问 github page 的问题，操作步骤如下：
创建 CNAME DNS 解析记录，最终访问域名为 https://blog.yahyav2rayssr.top，cloudflare 配置如下：


另外还需要在 github 上面设置自定义域名，填写位置如下：


hexo 远程仓库配置安装发布插件cnpm install hexo-deployer-git --save

修改 hexo 配置增加 github 相关配置，内容如下：
# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy:  type: git  repo: git@github.com:yaoyuming/yaoyuming.github.io.git  branch: master

文件压缩hexo-neat
hexo-neat 主要用来压缩 html，css 以及 js 文件。

安装 hexo-neat在站点根目录下
npm install hexo-neat --save

添加相关配置在站点配置文件 _config.yml 添加相关配置，直接添加到站点配置文件的末尾就可以。可以安装自己的需求去自定义配置，配置内容如下：
# hexo-neat# 博文压缩neat_enable: true# 压缩htmlneat_html:  enable: true  exclude:# 压缩css  neat_css:  enable: true  exclude:    - &#x27;**/*.min.css&#x27;# 压缩jsneat_js:  enable: true  mangle: true  output:  compress:  exclude:    - &#x27;**/*.min.js&#x27;    - &#x27;**/jquery.fancybox.pack.js&#x27;    - &#x27;**/index.js&#x27;  

hexo-neat 插件注意事项在使用hexo-neat插件时，可以在命令窗口中看到各个文件的压缩率，于是可以通过跳过一些文件让效率更高。
跳过压缩文件的正确配置方式

压缩 html 时不要跳过 .md 文件和 .swig 文件
.md 文件就是 markdown 文件，如果跳过压缩 .md 文件，而又刚好在文章中使用到了 tab 标签，那么当 hexo 在生成静态页面时就会发生解析错误。这会导致使用到了 tab 标签的页面生成失败而无法访问。
.swig 文件是模板引擎文件，也就是 hexo 可以通过这些文件来生成对应的页面。如果跳过这些文件，所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。

如果按照官方插件的文档说明来配置exclude，会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。于是需要给这些文件指定正确的路径，万能的配置方式如下：
neat_css:  enable: true  exclude:    - &#x27;**/*.min.css&#x27;

gulp
gulp 主要用来压缩图片。

安装 gulpgulp 全局安装：
npm install --global gulp-cli

gulp 局部安装：
npm install gulp --savenpm install gulp-babel babel-preset-env babel-preset-mobx --savenpm install -D @babel/core @babel/preset-react @babel/preset-env --save

图片压缩安装：
npm install gulp-imagemin --save

最终生成的 package.json 新增内容如下：
&#123;  &quot;scripts&quot;: &#123;    &quot;compile&quot;: &quot;hexo clean &amp;&amp; hexo generate &amp;&amp; gulp minify-images&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,    &quot;babel-preset-mobx&quot;: &quot;^2.0.0&quot;,    &quot;gulp&quot;: &quot;^4.0.2&quot;,    &quot;gulp-babel&quot;: &quot;^8.0.0&quot;,    &quot;gulp-imagemin&quot;: &quot;^7.1.0&quot;,  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;@babel/core&quot;: &quot;^7.8.4&quot;,    &quot;@babel/preset-env&quot;: &quot;^7.8.4&quot;,    &quot;@babel/preset-react&quot;: &quot;^7.8.3&quot;  &#125;&#125;

gulpfile.js 配置新增 gulpfile.js，内容如下：
// 引入需要的模块var gulp = require(&#x27;gulp&#x27;);var imagemin = require(&#x27;gulp-imagemin&#x27;);// 压缩图片gulp.task(&#x27;minify-images&#x27;, function () &#123;    return gulp.src([&#x27;./public/**/*.png&#x27;, &#x27;./public/**/*.jpg&#x27;, &#x27;./public/**/*.gif&#x27;])        .pipe(imagemin(            [imagemin.gifsicle(&#123; &#x27;optimizationLevel&#x27;: 3 &#125;),            imagemin.mozjpeg(&#123; &#x27;progressive&#x27;: true &#125;),            imagemin.optipng(&#123; &#x27;optimizationLevel&#x27;: 5 &#125;),            imagemin.svgo()],            &#123; &#x27;verbose&#x27;: true &#125;))        .pipe(gulp.dest(&#x27;./public&#x27;))&#125;);

制作永久链接hexo 预设永久连结是依照日期，但是这个很容易改动，又不希望永久连结内使用文章标题（因为是中文也有可能改动），所以有必要对链接路径做自定义配置。
安装 abbrlinknpm install hexo-abbrlink --save

设定预设设定hexo的站点配置文件(_config.yml)中
使用 permalink: :year/:month/:day/:title/ 当作永久连结的设定
也就是说文章的永久连接最后会是 年/月/日/标题 这样的格式，详情可以看 hexo永久连结文档
而稍微底下一点有
permalink_defaults:

这个是可以设定自己的参数的。
自定义设定我使用 hexo-abbrlink 对每篇文章生出一个编号
设定 hexo-abbrlink在主题配置文件加上
abbrlink:  alg: crc32  # support crc16(default) and crc32    rep: hex    # support dec(default) and hex  # crc16/crc32: 差别在于编号个数的极限，crc16可以生出65535个  # dec/hex:     差别在于编号生出来是十进制还是十六进制

自定义永久连结格式我想要以作者名字为主，再加上编号来形成永久连结
permalink_defaults:  author_name: yahya   # 新增一个作者名字的参数permalink: :author_name/:abbrlink/    # 结果是：网域/作者名字/abbrlink生成编号

私人文章隐藏当一篇文章被设置为「隐藏」时，它不会出现在任何列表中（包括首页、存档、分类页面、标签页面、Feed、站点地图等），也不会被搜索引擎索引（前提是搜索引擎遵守 noindex 标签）。
只有知道文章链接的人才可以访问被隐藏的文章。
Github 地址：https://github.com/printempw/hexo-hide-posts
安装在站点根目录下执行
npm install hexo-hide-posts --save

配置在站点目录下的_config.yml中如下配置：
# hexo-hide-postshide_posts:  # 可以改成其他你喜欢的名字  filter: hidden  # 指定你想要传递隐藏文章的位置，比如让所有隐藏文章在存档页面可见  # 常见的位置有：index, tag, category, archive, sitemap, feed, etc.  # 留空则默认全部隐藏  public_generators: []  # 为隐藏的文章添加 noindex meta 标签，阻止搜索引擎收录  noindex: true

举个栗子：设置 filter: secret 之后，你就可以在 front-matter 中使用 secret: true 来隐藏文章了。
使用在文章的属性中定义 hidden: true 即可隐藏文章。
---title: &#x27;Hidden Post&#x27;date: &#x27;2021/03/05 21:45:14&#x27;hidden: true---

虽然首页上被隐藏了，但你仍然可以通过 https://hexo.test/lorem-ipsum/ 链接访问它。
你可以在命令行运行 hexo hidden:list 来获取当前所有的已隐藏文章列表。
插件也在 Local Variables 中添加了 all_posts 和 hidden_posts 变量，供自定义主题使用。
推荐主题hexo-theme-fluid
hexo-theme-next
hexo-theme-pure
hexo-theme-yilia-plus
hexo-theme-3-hexo
参考链接Hexo 博客 NexT 主题的安装使用
centos7系统部署hexo博客新手入门
使用cloudflare免费加速github page
Hexo使用Gulp压缩静态资源
使用Gulp压缩Hexo博客静态资源
node.js版本管理工具n无效的原理和解决方法
]]></content>
      <categories>
        <category>运维</category>
        <category>常用安装</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>zsh 安装</title>
    <url>/posts/a1ba4b4f/</url>
    <content><![CDATA[安装zsh配置oh-my-zsh安装了虚拟机，玩了几天，发现自带的shell不太好用。本着折腾的优良作风，配置了oh-my-zsh，本文记录下安装步骤。
查看当前shellecho $SHELL

返回结果:

bin&#x2F;bash

安装zshyum install -y zsh

静候安装完成…
成功后如下所示
681
zsh下载完成
设置默认shellchsh -s /bin/zsh

请在root用户下切换shell
1143
更换shell
返回结果如下，表示切换完成（配置完成后需要重启方能生效，我们先下载oh-my-zsh，稍后重启）
安装git自动和手动安装都需要安装git，执行
yum install -y git

静候安装完成,完成后选择一种oh-my-zsh的安装方式。
安装oh-my-zsh（自动）sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;

使用curl来安装，wget命令执行后不起作用，暂时不知道怎么回事。
出现以下界面，显示安装成功。
2118
oh-my-zsh
手动安装下载源码
git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh

复制配置
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc

修改主题ZSH_THEME 字段就是主题，可以从资料里的主题找
2965
主题配置
完成后，重启生效默认shellreboot

别名配置首先我们看下git的别名
vi ~/.oh-my-zsh/plugins/git/git.plugin.zsh

3716
git别名
很强大有木有，我们还可以自定义别名，在~/.zshrc中，最下面直接写即可。
自定义别名
3921
自定义别名
小技巧1、输入d,就会列出你在这个回话中访问的目录，输入前面的序号，就可以直接跳转 2、可以忽略cd命令, 输入..或者...和当前目录名都可以跳转
资料
oh-my-zsh
oh-my-zsh主题一览
oh-my-zsh配置你的zsh提高shell逼格终极选择

主题修改进入themes的目录
cd ~/.oh-my-zsh/themesll #查看主题 默认主题是 ZSH_THEME=&quot;robbyrussell&quot;

在.zshrc中修改主题vi ~&#x2F;.zshrc

推荐主题：jonathan 或者 rkj-repos

vi ~/.zshrc # 找到ZSH_THEME 修改为你想要的主题即可

]]></content>
      <categories>
        <category>运维</category>
        <category>常用安装</category>
      </categories>
      <tags>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title>常见错误</title>
    <url>/posts/c10f304f/</url>
    <content><![CDATA[目录[解决]&#x2F;bin&#x2F;bash^M: bad interpreter: No such file or directory执行一个脚本full_build.sh 时, 一直是提示我:-bash: .&#x2F;full_build.sh: &#x2F;bin&#x2F;bash^M: bad interpreter: No such file or directory
开始是说我权限不够, 不能执行, 接着我就把权限给改了,  就一直报上面问题.记得几个月前, 就遇到过类似的问题, 当时是在编译Android Framework, 后来打开出错的.xml文件, 很直接的看到很多的^M的标识,  由于负责编译的同事帮忙解决了, 就没有去问为什么, 今天再次遇到, 就上网搜了搜, 才明白了原因.  
出现上面错误的原因之一是脚本文件是DOS格式的, 即每一行的行尾以\r\n来标识, 使用vim编辑器打开脚本, 运行::set ff?可以看到DOS或UNIX的字样. 使用set ff&#x3D;unix把它强制为unix格式的, 然后存盘退出, 即可.
网上也有很多的其他方法, 比如: 执行dos2unix 命令转换编码,  命令为: #dos2unix full_build.sh,  但我没有dos2unix的安装包, 所以就跳过了.  
也有说造成这种问题的原因是在使用vim时不小心按了个: Ctrl+v,  脚本是我从服务器上下的, 不清楚到底怎么会变成了DOS格式的了. 总之解决了就行啦.                      
]]></content>
      <categories>
        <category>运维</category>
        <category>常见错误</category>
      </categories>
      <tags>
        <tag>常见错误</tag>
      </tags>
  </entry>
  <entry>
    <title>杂烩</title>
    <url>/posts/c10d2cc/</url>
    <content><![CDATA[刷新DNS缓存现在很多Linux发行版都没有内置DNS本地缓存，Linux不像Windows那样可以使用ipconfig &#x2F;flushdns来刷新，在Linux下无需刷新，因为本身没有缓存；
当然，如果非要缓存刷新，可以安装nscd，然后刷新这个守护进程。
Ubuntu：
apt-get install -y nscd

CentOS:
yum install -y nscd

使用：
service nscd restart

查看DNS信息[deployer@CBSS-DMZ-19 ~]$ nslookup mall.10010.comServer:         202.106.0.20                                           　　 #这个域名是通过202.106.0.20这个DNS服务器进行解析的.Address:        202.106.0.20#53                                         　　#DNS服务器使用的IP地址和端口号Non-authoritative answer:mall.10010.com  canonical name = mall.10010.com.cdn.dnsv1.com.          　　#mall.10010.com对应的另外的域名mall.10010.com.cdn.dnsv1.commall.10010.com.cdn.dnsv1.com    canonical name = lt.p23.tc.cdntip.com. 　　 #mall.10010.com.cdn.dnsv1.com对应的另外的域名lt.p23.tc.cdntip.comName:   lt.p23.tc.cdntip.comAddress: 123.125.46.202      　　 #域名对应的第1个IP地址Name:   lt.p23.tc.cdntip.comAddress: 121.29.54.199       　　 #域名对应的第2个IP地址Name:   lt.p23.tc.cdntip.comAddress: 121.29.54.195       　　 #域名对应的第3个IP地址[deployer@CBSS-DMZ-19 ~]$ cat /etc/resolv.conf    　　 #LINUX主机在本地配置的域名服务器nameserver 202.106.0.20

防火墙开放端口#查看防火墙某个端口是否开放firewall-cmd --query-port=3306/tcp#开放防火墙端口3306firewall-cmd --zone=public --add-port=3306/tcp --permanent#查看防火墙状态systemctl status firewalld#关闭防火墙systemctl stop firewalld#打开防火墙systemctl start firewalld#开放一段端口firewall-cmd --zone=public --add-port=40000-45000/tcp --permanent#查看开放的端口列表firewall-cmd --zone=public --list-ports

解决SSH连接Linux超时自动断开1. $TMOUT 系统环境变量用以下命令判断是否是否设置了该参数
echo $TMOUT

如果输出空或0表示不超时，大于0的数字n表示n秒没有收入则超时
修改方法：
vi /etc/profile# 将以下900修改为0就是设置不超时export TMOUT=900# 让配置立即生效source /etc/profile

2. sshd 服务配置

ClientAliveInterval指定了服务器端向客户端请求消息的时间间隔, 默认是0, 不发送。设置60表示每分钟发送一次, 然后客户端响应, 这样就保持长连接了。
ClientAliveCountMax表示服务器发出请求后客户端没有响应的次数达到一定值, 就自动断开。正常情况下, 客户端不会不响应，使用默认值3即可。


1. 查看现有配置cd /etc/ssh# 查看sshd_config中关于客户端活动状态的配置grep ClientAlive sshd_config

默认输出如下：
# ----------------------------# ClientAliveInterval 0# ClientAliveCountMax 3# ----------------------------

3. 修改sshd配置# 启用客户端活动检查，每60秒检查一次，3次不活动断开连接sed -i &quot;s/#ClientAliveInterval 0/ClientAliveInterval 60/g&quot; sshd_configsed -i &quot;s/#ClientAliveCountMax 3/ClientAliveCountMax 3/g&quot; sshd_config

4. 重新加载service sshd reload

5. 确认修改情况# 备份原配置文件cp sshd_config sshd_config.bak# 确认修改grep ClientAlive sshd_config# 比较配置文件差异diff sshd_config sshd_config.bak

3. xshell简易配置方式

]]></content>
      <categories>
        <category>运维</category>
        <category>杂烩</category>
      </categories>
      <tags>
        <tag>杂烩</tag>
      </tags>
  </entry>
</search>
