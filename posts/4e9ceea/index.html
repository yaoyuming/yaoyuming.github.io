<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yahya"><meta name="keywords" content=""><meta name="description" content="AOP 详解一、AOP 简介AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP只允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志，事务，安全等。这些功能都是横向应"><meta property="og:type" content="article"><meta property="og:title" content="Spring 基础"><meta property="og:url" content="https://blog.yahyav2rayssr.top/posts/4e9ceea/index.html"><meta property="og:site_name" content="yahya的博客"><meta property="og:description" content="AOP 详解一、AOP 简介AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP只允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志，事务，安全等。这些功能都是横向应"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/4e9ceea/109.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/4e9ceea/207.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/4e9ceea/12546411-497191fff892d42b.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/4e9ceea/f1d0bd023bd44134a7f5536d5789d57dtplv-k3u1fbpfcp-watermark.image"><meta property="article:published_time" content="2023-04-18T15:31:28.060Z"><meta property="article:modified_time" content="2023-04-18T15:31:28.061Z"><meta property="article:author" content="Yahya"><meta property="article:tag" content="spring"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog.yahyav2rayssr.top/posts/4e9ceea/109.jpg"><title>Spring 基础 - yahya的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"blog.yahyav2rayssr.top",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!1,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!1,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:6},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="yahya的博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yahya的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Spring 基础</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-18 23:31" pubdate>2023年4月18日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 12k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 97 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Java" id="heading-d52387880e1ea22817a72d3759213819" role="tab" data-toggle="collapse" href="#collapse-d52387880e1ea22817a72d3759213819" aria-expanded="true">Java <span class="list-group-count">(51)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-d52387880e1ea22817a72d3759213819" role="tabpanel" aria-labelledby="heading-d52387880e1ea22817a72d3759213819"><div class="category-post-list"><a href="/posts/a3b6ed09/" title="Java 常用命令" class="list-group-item list-group-item-action"><span class="category-post">Java 常用命令</span></a></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="JVM" id="heading-18b5a217c4dad25662d3a05edb0e39d7" role="tab" data-toggle="collapse" href="#collapse-18b5a217c4dad25662d3a05edb0e39d7" aria-expanded="false">JVM <span class="list-group-count">(5)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-18b5a217c4dad25662d3a05edb0e39d7" role="tabpanel" aria-labelledby="heading-18b5a217c4dad25662d3a05edb0e39d7"><div class="category-post-list"><a href="/posts/9e0bfe2e/" title="JVM 垃圾收集器" class="list-group-item list-group-item-action"><span class="category-post">JVM 垃圾收集器</span> </a><a href="/posts/5b44aded/" title="JVM 垃圾收集器与内存分配策略" class="list-group-item list-group-item-action"><span class="category-post">JVM 垃圾收集器与内存分配策略</span> </a><a href="/posts/7c42c21b/" title="JVM 指令大全" class="list-group-item list-group-item-action"><span class="category-post">JVM 指令大全</span> </a><a href="/posts/1b362162/" title="JVM 杂项" class="list-group-item list-group-item-action"><span class="category-post">JVM 杂项</span> </a><a href="/posts/703fe08b/" title="JVM 运行时数据区域" class="list-group-item list-group-item-action"><span class="category-post">JVM 运行时数据区域</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Java 基础" id="heading-3c457761d24c20abb3e9682a48e47df6" role="tab" data-toggle="collapse" href="#collapse-3c457761d24c20abb3e9682a48e47df6" aria-expanded="false">Java 基础 <span class="list-group-count">(6)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-3c457761d24c20abb3e9682a48e47df6" role="tabpanel" aria-labelledby="heading-3c457761d24c20abb3e9682a48e47df6"><div class="category-post-list"><a href="/posts/80d2509b/" title="Java IO 流详解" class="list-group-item list-group-item-action"><span class="category-post">Java IO 流详解</span> </a><a href="/posts/fa358471/" title="Java 反射" class="list-group-item list-group-item-action"><span class="category-post">Java 反射</span> </a><a href="/posts/a019e08c/" title="Java 基础" class="list-group-item list-group-item-action"><span class="category-post">Java 基础</span> </a><a href="/posts/74a86a53/" title="Java 数学运算" class="list-group-item list-group-item-action"><span class="category-post">Java 数学运算</span> </a><a href="/posts/23a29293/" title="Java 时间运算" class="list-group-item list-group-item-action"><span class="category-post">Java 时间运算</span> </a><a href="/posts/3aa3d5b8/" title="lambda 表达式用法" class="list-group-item list-group-item-action"><span class="category-post">lambda 表达式用法</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Spring" id="heading-38008dd81c2f4d7985ecf6e0ce8af1d1" role="tab" data-toggle="collapse" href="#collapse-38008dd81c2f4d7985ecf6e0ce8af1d1" aria-expanded="true">Spring <span class="list-group-count">(10)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-38008dd81c2f4d7985ecf6e0ce8af1d1" role="tabpanel" aria-labelledby="heading-38008dd81c2f4d7985ecf6e0ce8af1d1"><div class="category-post-list"><a href="/posts/2ed6c644/" title="Spring AOP 详解" class="list-group-item list-group-item-action"><span class="category-post">Spring AOP 详解</span> </a><a href="/posts/698a4e8e/" title="Spring Validation 校验" class="list-group-item list-group-item-action"><span class="category-post">Spring Validation 校验</span> </a><a href="/posts/940ce4f5/" title="Spring 全局属性转换配置" class="list-group-item list-group-item-action"><span class="category-post">Spring 全局属性转换配置</span> </a><a href="/posts/fac11a47/" title="Spring 单元测试" class="list-group-item list-group-item-action"><span class="category-post">Spring 单元测试</span> </a><a href="/posts/4e9ceea/" title="Spring 基础" class="list-group-item list-group-item-action active"><span class="category-post">Spring 基础</span> </a><a href="/posts/70a6ebcd/" title="Spring 常用注解" class="list-group-item list-group-item-action"><span class="category-post">Spring 常用注解</span> </a><a href="/posts/7be9f3eb/" title="Spring 常见错误" class="list-group-item list-group-item-action"><span class="category-post">Spring 常见错误</span> </a><a href="/posts/b27a891c/" title="SpringCloud 组件概念" class="list-group-item list-group-item-action"><span class="category-post">SpringCloud 组件概念</span> </a><a href="/posts/2547f24d/" title="Springboot 启动流程" class="list-group-item list-group-item-action"><span class="category-post">Springboot 启动流程</span> </a><a href="/posts/fd57e58c/" title="Springboot 常用配置" class="list-group-item list-group-item-action"><span class="category-post">Springboot 常用配置</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="maven" id="heading-402c5d9af6b43711ea070bee5170f74d" role="tab" data-toggle="collapse" href="#collapse-402c5d9af6b43711ea070bee5170f74d" aria-expanded="false">maven <span class="list-group-count">(6)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-402c5d9af6b43711ea070bee5170f74d" role="tabpanel" aria-labelledby="heading-402c5d9af6b43711ea070bee5170f74d"><div class="category-post-list"><a href="/posts/25549297/" title="Maven mvnw 详解" class="list-group-item list-group-item-action"><span class="category-post">Maven mvnw 详解</span> </a><a href="/posts/5c907e7a/" title="Maven 基本安装（windows）" class="list-group-item list-group-item-action"><span class="category-post">Maven 基本安装（windows）</span> </a><a href="/posts/6ff6dc3c/" title="Maven 基础概念" class="list-group-item list-group-item-action"><span class="category-post">Maven 基础概念</span> </a><a href="/posts/c718cdb9/" title="Maven 常用命令" class="list-group-item list-group-item-action"><span class="category-post">Maven 常用命令</span> </a><a href="/posts/615834e0/" title="Maven 常用配置" class="list-group-item list-group-item-action"><span class="category-post">Maven 常用配置</span> </a><a href="/posts/4f5fa1df/" title="Maven 常见问题" class="list-group-item list-group-item-action"><span class="category-post">Maven 常见问题</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="mybatis" id="heading-f0d71b77ac2ea991f39f9dfdd5e985b5" role="tab" data-toggle="collapse" href="#collapse-f0d71b77ac2ea991f39f9dfdd5e985b5" aria-expanded="false">mybatis <span class="list-group-count">(3)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-f0d71b77ac2ea991f39f9dfdd5e985b5" role="tabpanel" aria-labelledby="heading-f0d71b77ac2ea991f39f9dfdd5e985b5"><div class="category-post-list"><a href="/posts/2f2b0963/" title="Mybatis-plus XML 标签用法" class="list-group-item list-group-item-action"><span class="category-post">Mybatis-plus XML 标签用法</span> </a><a href="/posts/f384c0b1/" title="Mybatis-plus 代码用法" class="list-group-item list-group-item-action"><span class="category-post">Mybatis-plus 代码用法</span> </a><a href="/posts/3080fe57/" title="Mybatis-plus 基本配置" class="list-group-item list-group-item-action"><span class="category-post">Mybatis-plus 基本配置</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="多线程" id="heading-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7" role="tab" data-toggle="collapse" href="#collapse-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7" aria-expanded="false">多线程 <span class="list-group-count">(11)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7" role="tabpanel" aria-labelledby="heading-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7"><div class="category-post-list"><a href="/posts/9784837e/" title="AQS 原理" class="list-group-item list-group-item-action"><span class="category-post">AQS 原理</span> </a><a href="/posts/18ad812a/" title="CountDownLatch 应用" class="list-group-item list-group-item-action"><span class="category-post">CountDownLatch 应用</span> </a><a href="/posts/27d2027c/" title="CyclicBarrier 应用" class="list-group-item list-group-item-action"><span class="category-post">CyclicBarrier 应用</span> </a><a href="/posts/e5b78a2e/" title="Java 多线程入门" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程入门</span> </a><a href="/posts/71aa5641/" title="Java 多线程基础" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程基础</span> </a><a href="/posts/ff94c717/" title="Java 多线程基础集合体系概述" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程基础集合体系概述</span> </a><a href="/posts/7c5551ea/" title="Java 多线程常用 API" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程常用 API</span> </a><a href="/posts/4b405cfc/" title="Java 多线程设计模式" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程设计模式</span> </a><a href="/posts/cf2a801/" title="Java 线程池详解" class="list-group-item list-group-item-action"><span class="category-post">Java 线程池详解</span> </a><a href="/posts/bcd2abf0/" title="Semaphore 应用" class="list-group-item list-group-item-action"><span class="category-post">Semaphore 应用</span> </a><a href="/posts/61ccd33e/" title="StampedLock 应用" class="list-group-item list-group-item-action"><span class="category-post">StampedLock 应用</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="工具库" id="heading-de33723f9f63fa412b6071def21565ce" role="tab" data-toggle="collapse" href="#collapse-de33723f9f63fa412b6071def21565ce" aria-expanded="false">工具库 <span class="list-group-count">(5)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-de33723f9f63fa412b6071def21565ce" role="tabpanel" aria-labelledby="heading-de33723f9f63fa412b6071def21565ce"><div class="category-post-list"><a href="/posts/86e940c9/" title="fastjson 常用 API" class="list-group-item list-group-item-action"><span class="category-post">fastjson 常用 API</span> </a><a href="/posts/4e9562ed/" title="fastjson 常见问题" class="list-group-item list-group-item-action"><span class="category-post">fastjson 常见问题</span> </a><a href="/posts/df564e8b/" title="lombok 基础" class="list-group-item list-group-item-action"><span class="category-post">lombok 基础</span> </a><a href="/posts/34954977/" title="swagger 常用注解" class="list-group-item list-group-item-action"><span class="category-post">swagger 常用注解</span> </a><a href="/posts/f5eac37d/" title="工具库杂项" class="list-group-item list-group-item-action"><span class="category-post">工具库杂项</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="数据结构" id="heading-0fea7c47d93da5689f31820ee525b367" role="tab" data-toggle="collapse" href="#collapse-0fea7c47d93da5689f31820ee525b367" aria-expanded="false">数据结构 <span class="list-group-count">(3)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-0fea7c47d93da5689f31820ee525b367" role="tabpanel" aria-labelledby="heading-0fea7c47d93da5689f31820ee525b367"><div class="category-post-list"><a href="/posts/39a12d12/" title="ConcurrentHashMap 详解" class="list-group-item list-group-item-action"><span class="category-post">ConcurrentHashMap 详解</span> </a><a href="/posts/e344884c/" title="HashMap 详解" class="list-group-item list-group-item-action"><span class="category-post">HashMap 详解</span> </a><a href="/posts/c9844e82/" title="Java 数据结构基础" class="list-group-item list-group-item-action"><span class="category-post">Java 数据结构基础</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="设计模式" id="heading-301a19970448f8e4f27ddae7a7d415fe" role="tab" data-toggle="collapse" href="#collapse-301a19970448f8e4f27ddae7a7d415fe" aria-expanded="false">设计模式 <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-301a19970448f8e4f27ddae7a7d415fe" role="tabpanel" aria-labelledby="heading-301a19970448f8e4f27ddae7a7d415fe"><div class="category-post-list"><a href="/posts/fa3d1251/" title="Java 设计模式" class="list-group-item list-group-item-action"><span class="category-post">Java 设计模式</span></a></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Spring 基础</h1><p class="note note-info">本文最后更新于：2023年4月18日 晚上</p><div class="markdown-body"><h1 id="AOP-详解"><a href="#AOP-详解" class="headerlink" title="AOP 详解"></a>AOP 详解</h1><h2 id="一、AOP-简介"><a href="#一、AOP-简介" class="headerlink" title="一、AOP 简介"></a>一、AOP 简介</h2><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP只允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志，事务，安全等。这些功能都是横向应用在业务处理中，而与它们对应的方法与其他代码基本没有联系，如异常处理和透明的持续性也都是如此，不仅增加了大量的代码量，还为程序后期的维护增生很多困难。</p><p>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><h2 id="二、AOP-基本了解和通知方法"><a href="#二、AOP-基本了解和通知方法" class="headerlink" title="二、AOP 基本了解和通知方法"></a>二、AOP 基本了解和通知方法</h2><ol><li><strong>切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。</strong><br>事务管理是J2EE应用中一个关于横切关注点的很好的例子。在spring AOP中，切面可以使用基于模式）或者基于Aspect注解方式来实现。通俗点说就是我们加入的切面类（比如log类），可以这么理解。</li><li><strong>连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。</strong><br>在Spring AOP中，一个连接点总是表示一个方法的执行。通俗的说就是加入切点的那个点</li><li><strong>通知（Advice）：在切面的某个特定的连接点上执行的动作。</strong><br>其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</li><li><strong>切入点（Pointcut）：匹配连接点的断言。</strong><br>通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</li><li><strong>引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type declaration））。</strong><br>Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。</li><li><strong>目标对象（Target Object）： 被一个或者多个切面所通知的对象。</strong><br>也被称做被通知（advised）对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。</li><li><strong>AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。</strong><br>在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li><li><strong>织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。</strong><br>这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li></ol><h3 id="通知方法："><a href="#通知方法：" class="headerlink" title="通知方法："></a>通知方法：</h3><ol><li><p><strong>前置通知（Before advice）：</strong>在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</p></li><li><p><strong>后置通知（After returning advice）：</strong>在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p></li><li><p><strong>异常通知（After throwing advice）：</strong>在方法抛出异常退出时执行的通知。</p></li><li><p><strong>最终通知（After (finally) advice）：</strong>当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p></li><li><p><strong>环绕通知（Around Advice）：</strong>包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。</p><p>它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p></li></ol><h2 id="三、Spring对AOP的支持"><a href="#三、Spring对AOP的支持" class="headerlink" title="三、Spring对AOP的支持"></a>三、Spring对AOP的支持</h2><p>Spring中AOP代理由Spring的IOC容器负责生成，管理，它的依赖关系也有IOC容器负责。因此，AOP代理可以直接使用容器中的其他bean示例作为目标，这种关系可由IOC容器的依赖注入提供(不熟悉依赖注入的可以看看我之前的博文)。Spring创建代理规则为:</p><p>1、默认使用JDK动态代理来创建AOP代理，这样可以为任何接口示例创建代理</p><p>2、当需要代理的类不是代理接口时，Spring会切换为使用CGLIB代理，也可强制使用CGLIB代理。(强制方法：在XML配置中修改 AOP 属性spring.aop.proxy-target-class&#x3D;true或在注释中修改@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true)进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：代理对象的方法&#x3D;增强处理+被代理对象的方法。</p><p>exposeProxy：AOP生成对象时，绑定到ThreadLocal, 可以通过AopContext获取</p><h1 id="IOC（依赖注入）的基本实现方式"><a href="#IOC（依赖注入）的基本实现方式" class="headerlink" title="IOC（依赖注入）的基本实现方式"></a>IOC（依赖注入）的基本实现方式</h1><p>Java中创建一个对象分两步：</p><ol><li>通过关键字<strong>new创建一个对象</strong></li><li>通过<strong>构造函数或setter函数为对象添加初始化参数 （参数可以是基本数据类型 也可以是引用数据类型（比如依赖的类））</strong></li></ol><p>当 Spring 出现后，<strong>对象的创建、成员变量的初始化、对象的销毁均由Spring完成。</strong></p><p>那么，要让Spring帮助我们创建对象，我们首先需要将<strong>要创建的对象的类型</strong>、<strong>初始化的值</strong>告诉Spring，然后Spring会在程序启动的时候根据我们的要求创建对象。我们通过配置文件来告诉Spring要创建哪些对象，并告诉Spring如何创建这些对象。</p><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p><strong>在Spring中，默认情况下bean都是单例。也就是说，当我们向Spring请求一个bean对象时，Spring总给我们返回同一个bean对象。</strong><br><strong>注意：</strong>Spring 中所说的“单例”与Java中的单例稍有不同。Spring中的单例是指：在同一个ApplicationContext中相同名字的bean对象是同一个；而Java中的单例是指：整个JVM中单例的对象只有一个。<br>当然，我们可以通过改变bean标签的scope参数来设置bean的作用域。常用的scope对应的值有：</p><ul><li><p>singleton：在同一个Spring Context中，一个bean只有一个实例对象。(默认)</p></li><li><p>prototype：每次向Spring请求一个bean对象，Spring都会创建一个新的实例。</p></li><li><p><strong>会话（Session）</strong>：在web应用中，为每个会话创建一个bean实例。</p></li><li><p><strong>请求（Request）</strong>：在Web应用中，为每个请求创建一个bean实例。</p></li></ul><p><strong>依赖注入的方式分三种</strong></p><ol><li>构造函数注入</li><li>属性注入</li><li>set方法注入</li></ol><h2 id="自动装配与自动扫描"><a href="#自动装配与自动扫描" class="headerlink" title="自动装配与自动扫描"></a>自动装配与自动扫描</h2><p>简化Spring的配置主要分为两类：</p><ol><li>自动装配</li><li>自动扫描</li></ol><h3 id="自动装配的种类"><a href="#自动装配的种类" class="headerlink" title="自动装配的种类"></a>自动装配的种类</h3><ol><li><p><strong>byName：根据属性的名字自动装配</strong></p><p>在bean标签中添加属性autowire&#x3D;”byName”。当Spring启动时，会寻找<strong>与person中成员变量名字相同的bean</strong>，并将该bean注给person的成员变量。</p></li><li><p><strong>byType：根据属性的类型自动装配</strong><br>在bean标签中添加属性autowire&#x3D;”byType”。当Spring启动时，会寻找<strong>与person中成员变量类型相同的bean</strong>，并将该bean注给person的成员变量。<br><strong>byType的缺点：</strong>如果某一类型的bean有多个，那Spring在通过byType为属性寻找同类型的bean时就会抛出异常。</p></li><li><p><strong>constructor：根据构造器的参数类型自动装配</strong></p></li><li><p><strong>autodetect：最佳自动装配。首先采用constructor自动装配，若没有发现与构造器相匹配的Bean时，采用byType进行自动装配。</strong></p></li></ol><p><strong>@Autowired本质上采用byType进行自动装配，因此也存在与byType一样的问题：若同一类型的bean有多个时，或找不到该类型的bean，Spring就会抛出异常。</strong></p><h4 id="在注解中使用SpEL表达式"><a href="#在注解中使用SpEL表达式" class="headerlink" title="在注解中使用SpEL表达式"></a>在注解中使用SpEL表达式</h4><p>将名为father的bean注入给构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;#&#123;father&#125;&quot;)</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(Father father)</span>&#123;<br>      <span class="hljs-built_in">this</span>.father = father;<br>  &#125;<br></code></pre></td></tr></table></figure><p>将father对象中的id注入给id：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;#&#123;father.id&#125;&quot;)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>&#123;<br>       <span class="hljs-built_in">this</span>.id = id;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="自动检测"><a href="#自动检测" class="headerlink" title="自动检测"></a>自动检测</h2><p><strong>自动装配能够减少bean标签下property标签和constructor-arg标签的数量，而自动检测能降低bean标签的数量。</strong></p><h1 id="classpath-和-classpath-区别："><a href="#classpath-和-classpath-区别：" class="headerlink" title="classpath 和 classpath* 区别："></a>classpath 和 classpath* 区别：</h1><p>classpath：只会到你的class路径中查找找文件;<br>classpath*：不仅包含class路径，还包括jar文件中(class路径)进行查找.</p><h1 id="Spring-注解-Resource-和-Autowired-区别对比"><a href="#Spring-注解-Resource-和-Autowired-区别对比" class="headerlink" title="Spring 注解 @Resource 和 @Autowired 区别对比"></a>Spring 注解 @Resource 和 @Autowired 区别对比</h1><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@<strong>Autowired</strong></h2><p>​	@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。(通过类型匹配找到多个candidate,在没有@Qualifier、@Primary注解的情况下，会使用对象名作为最后的fallback匹配)如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">private</span> UserDao userDao; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a><strong>@Resource</strong></h2><p>​	@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><p>​	@Resourced标签是按照bean的名字来进行注入的，如果我们没有在使用@Resource时指定bean的名字，同时Spring容器中又没有该名字的bean,这时候@Resource就会退化为@Autowired即按照类型注入，这样就有可能违背了使用@Resource的初衷。所以建议在使用@Resource时都显示指定一下bean的名字@Resource(name&#x3D;”xxx”)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br>    <span class="hljs-comment">// 下面两种@Resource只要使用一种即可</span><br>    <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">private</span> UserDao userDao; <span class="hljs-comment">// 用于字段上</span><br>    <br>    <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123; <span class="hljs-comment">// 用于属性的setter方法上</span><br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li><li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li><li>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</li><li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li></ul><h1 id="Spring-中-Bean-的生命周期"><a href="#Spring-中-Bean-的生命周期" class="headerlink" title="Spring 中 Bean 的生命周期"></a>Spring 中 Bean 的生命周期</h1><p>对于普通的 Java 对象，当我们使用<code>new</code>关键字创建对象的时候，如果它没有任何引用，则其会被垃圾回收机制回收。而由 Spring IoC 容器托管的对象，它们的生命周期则是完全由容器控制。在 Spring 中，每个 Bean 的生命周期大致如下：</p><img src="/posts/4e9ceea/109.jpg" srcset="/img/loading.gif" lazyload><h2 id="实例化-Bean"><a href="#实例化-Bean" class="headerlink" title="实例化 Bean"></a>实例化 Bean</h2><p>对于BeanFactory容器来说，当用户向容器请求一个尚未初始化的 Bean 或初始化 Bean 的时候，如果需要注入另一个尚未初始化的依赖，容器就会调用createBean进行实例化；对于ApplicationContext容器来说，当容器启动结束后，便实例化所有的 Bean。</p><p>容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。 实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h2 id="设置对象属性（依赖注入）"><a href="#设置对象属性（依赖注入）" class="headerlink" title="设置对象属性（依赖注入）"></a>设置对象属性（依赖注入）</h2><p>实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。 紧接着，Spring 根据BeanDefinition中的信息进行依赖注入，并且通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><h2 id="注入-Aware-接口"><a href="#注入-Aware-接口" class="headerlink" title="注入 Aware 接口"></a>注入 Aware 接口</h2><p>紧接着，Spring 会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给 Bean：</p><p>如果 Bean 实现了BeanNameAware接口，Spring 将 Bean 的 ID 传递给setBeanName()方法。实现BeanNameAware主要是为了通过 Bean 的引用来获得 Bean 的 ID，一般业务中是很少有用到 Bean 的 ID 的。<br>如果 Bean 实现了BeanFactoryAware接口，Spring 将调用setBeanDactory(BeanFactory bf)方法并把BeanFactory容器实例作为参数传入。实现BeanFactoryAware主要目的是为了获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等。<br>如果 Bean 实现了ApplicationContextAware接口，Spring 容器将调用setApplicationContext(ApplicationContext ctx)方法，把应用上下文作为参数传入，作用与BeanFactory类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用setApplicationContext方法时会把它自己作为setApplicationContext的参数传入，而 Spring 容器在调用setBeanDactory前需要程序员自己指定（注入）setBeanDactory里的参数BeanFactory。</p><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>当经过上述几个步骤后，Bean 对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。 该接口提供了两个函数：</p><p>postProcessBeforeInitialzation(Object bean, String beanName)当前正在初始化的 Bean 对象会被传递进来，我们就可以对这个 Bean 作任何处理。这个函数会先于InitialzationBean执行，因此称为前置处理。 所有Aware接口的注入就是在这一步完成的。<br>postProcessAfterInitialzation(Object bean, String beanName)当前正在初始化的 Bean 对象会被传递进来，我们就可以对这个 Bean 作任何处理。这个函数会在InitialzationBean完成后执行，因此称为后置处理。</p><h2 id="InitializingBean-与-init-method"><a href="#InitializingBean-与-init-method" class="headerlink" title="InitializingBean 与 init-method"></a>InitializingBean 与 init-method</h2><p>当BeanPostProcessor的前置处理完成后就会进入本阶段。 InitializingBean接口只有一个函数：</p><p>afterPropertiesSet()<br>这一阶段也可以在 Bean 正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前 Bean 对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 若要使用它，我们需要让 Bean 实现该接口，并把要增加的逻辑写在该函数中。然后，Spring 会在前置处理完成后检测当前 Bean 是否实现了该接口，并执行afterPropertiesSet函数。</p><p>当然，Spring 为了降低对客户代码的侵入性，给 Bean 的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring 便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。</p><h2 id="DisposableBean-和-destroy-method"><a href="#DisposableBean-和-destroy-method" class="headerlink" title="DisposableBean 和 destroy-method"></a>DisposableBean 和 destroy-method</h2><p>如果 Bean 实现了DispostbleBean接口，Spring 将调用它的destory方法，作用与在配置文件中对 Bean 使用destory-method属性的作用一样，都是在 Bean 实例销毁前执行的方法。</p><p>至此，Spring 中 Bean 的经历了从创建到消耗的整个生命周期的过程。</p><h1 id="Spring-事务传播行为"><a href="#Spring-事务传播行为" class="headerlink" title="Spring 事务传播行为"></a>Spring 事务传播行为</h1><h2 id="什么是事务传播行为？"><a href="#什么是事务传播行为？" class="headerlink" title="什么是事务传播行为？"></a>什么是事务传播行为？</h2><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p><h2 id="Spring中七种事务传播行为"><a href="#Spring中七种事务传播行为" class="headerlink" title="Spring中七种事务传播行为"></a>Spring中七种事务传播行为</h2><table><thead><tr><th><strong>事务传播行为类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><h2 id="REQUIRED-REQUIRES-NEW-NESTED-异同"><a href="#REQUIRED-REQUIRES-NEW-NESTED-异同" class="headerlink" title="REQUIRED, REQUIRES_NEW, NESTED 异同"></a>REQUIRED, REQUIRES_NEW, NESTED 异同</h2><ul><li><p>NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。</p><p>但是REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，</p><p>外围方法事务也将被回滚。而NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。</p></li><li><p>NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。</p><p>但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。</p><p>而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。</p></li></ul><h1 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h1><img src="/posts/4e9ceea/207.png" srcset="/img/loading.gif" lazyload alt="img"><ol><li>开始实例化 person</li><li>设置 name 属性</li><li>Person 实现了 BeanNameAware 接口，Spring 将 Person 的 ID&#x3D;person传递给 setBeanName 方法</li><li>Person 实现了 BeanFactoryAware 接口，Spring 调用 setBeanFactory()方法，将 BeanFactory 容器实例传入</li><li>Person 实现了 ApplicationContextAware 接口，Spring 调用 setApplicationContext()方法，将 person 所在的应用上下文的引用传入进来</li><li>初始化 Person 之前执行的方法（BeanPostProcessor 的 postProcessBeforeInitialization 方法）</li><li>@PostConstruct 调用自定义的初始化方法</li><li>Person 实现了 InitializingBean 接口，Spring 调用它的afterPropertiesSet()方法。类似地，如果 person 使用 init-method 声明了初始化方法，该方法也会被调用</li><li>xml 中声明的 init-method 方法</li><li>初始化 Person 完成之后执行的方法（BeanPostProcessor 的 postProcessAfterInitialization 方法）</li><li>实例化完成使用属性：Person name &#x3D; nasus（main结束方法）</li><li>@PreDestory 调用自定义销毁方法</li><li>Person 实现了 DisposableBean 接口，Spring 调用它的destroy() 接口方法。同样，如果 person 使用 destroy-method 声明了销毁方法，该方法也会被调用</li><li>xml 中声明的 destroy-method 方法</li></ol><h1 id="servlet-执行流程"><a href="#servlet-执行流程" class="headerlink" title="servlet 执行流程"></a>servlet 执行流程</h1><img src="/posts/4e9ceea/12546411-497191fff892d42b.jpg" srcset="/img/loading.gif" lazyload alt="img"><h1 id="Java-SPI-和-Spring-SPI"><a href="#Java-SPI-和-Spring-SPI" class="headerlink" title="Java SPI 和 Spring SPI"></a>Java SPI 和 Spring SPI</h1><p>service provider framework是一个系统， 实现了SPI， 在系统里多个服务提供者模块可以提供一个服务的实现， 系统让客户端可以使用这些实现， 从而实现解耦。</p><p>一个service provider framework有3个主要的组成部分:</p><ol><li>一个服务接口， 供服务提供者实现。</li><li>一个注册API， 系统使用这个API来注册服务接口的实现， 从而让客户端使用。</li><li>一个service access API， 客户端可以选择获取一个服务的实例。</li></ol><h2 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI:"></a>Java SPI:</h2><p>Service Provider Interface(SPI)是一个可以被第三方扩展或实现的API， 它可以用来实现框架扩展和可替换的模块。</p><p>使用步骤：</p><ol><li>服务调用方通过 <code>ServiceLoader.load</code> 加载服务接口的实现类实例</li><li>服务提供方实现服务接口后， 在自己Jar包的META-INF&#x2F;services目录下新建一个接口名全名的文件， 并将具体实现类全名写入。</li></ol><h2 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h2><p>很多开源库中都直接或间接地使用了Java的SPI机制， 如Spring中就有类似的SPI机制， 通过SpringFactoriesLoader代替JDK中的ServiceLoader， 通过META-INF&#x2F;spring.factories文件代替META-INF&#x2F;service目录下的描述文件, 原理都是使用了Java的反射机制。</p><p>Spring提供的SPI只需要且只有一个文件， 就是META-INF&#x2F;spring.factories</p><p>Spring的SPI也更加灵活， 不必要key是接口， 值是实现类， 例如Spring boot使用这种方式来处理自动配置的bean: key是注解(如org.springframework.boot.autoconfig.EnableAutoConfiguration)， 值是被标记@Configuration的类。</p><p>另外Spring中还有converter spi和formatter spi。</p><p>converter可以用做任意两个类型之间的转换， formatter spi用做string类型和其他类型之间的转换。</p><p>Converter和Formatter接口即服务接口</p><p>ConersionService实现了ConverterRegistry接口， 提供服务实现的注册， 同时也提供可访问功能。</p><p>而<code>FormattingConversionService</code> 则实现了FormatterRegistry接口， 实现了formatter实现类的注册和调用。 同时FormattingConversionService也实现了ConversionService接口。</p><h1 id="为什么Spring4-x推荐构造函数注入"><a href="#为什么Spring4-x推荐构造函数注入" class="headerlink" title="为什么Spring4.x推荐构造函数注入"></a>为什么Spring4.x推荐构造函数注入</h1><p>在上面的分析看来，构造函数注入好像并没有显现出来它的优势，但问什么Spring4.x会推翻之前推荐的setter注入，采用构造函数注入呢？官方的理由汇总如下：</p><ul><li>依赖不可变：加入了final来约束修饰Field，这条是很显然的；</li><li>依赖不可为空：在实例化的时候会检查构造函数参数是否为空，如果为空（未找到改类型的实例对象）则会抛出异常。</li><li>单一职责：当使用构造函数注入时，如果参数过多，你会发现当前类的职责过大，需要进行拆分。而使用Field注入时，你并不会意识到此问题。</li><li>更利于单元测试：按照其他两种方式注入，当单元测试时需要初始化整个spring的环境，而采用构造方法注入时，只需要初始化需要的类即可，即可以直接实例化需要的类。</li><li>避免IOC容器以外环境调用时潜在的NPE（空指针异常）。</li><li>避免循环依赖。</li><li>保证返回客户端（调用）的代码的时候是完全初始化的状态。</li></ul><h1 id="静态资源拦截"><a href="#静态资源拦截" class="headerlink" title="静态资源拦截"></a>静态资源拦截</h1><p>说下默认映射的文件夹有：</p><ul><li><p>classpath:&#x2F;META-INF&#x2F;resources</p></li><li><p>classpath:&#x2F;resources</p></li><li><p>classpath:&#x2F;static</p></li><li><p>classpath:&#x2F;public</p></li></ul><p>优先级顺序为：META-INF&#x2F;resources &gt; resources &gt; static &gt; public</p><h1 id="PatchMapping-和-PutMapping-的区别"><a href="#PatchMapping-和-PutMapping-的区别" class="headerlink" title="@PatchMapping 和 @PutMapping 的区别"></a>@PatchMapping 和 @PutMapping 的区别</h1><blockquote><p>http协议明确规定，put、get与delete请求都是具有幂等性的，而post为非幂等性请求，就是说接口被定义为post请求可访问时，说明这个接口对数据库的影响是非幂等性的。</p><p>所以一般插入新数据时，用post方法，更新数据库时，用put方法，以此类推@PostMapping注解是标示接口为非幂等性接口，@PutMapping注解是标示接口为幂等性接口。</p></blockquote><p>Patch方式是对put方式的一种补充，put方式是可以更新，但是更新的是整体，patch是对局部更新。</p><h1 id="application-yml-和-bootStrap-yml-的加载顺序"><a href="#application-yml-和-bootStrap-yml-的加载顺序" class="headerlink" title="application.yml 和 bootStrap.yml 的加载顺序"></a>application.yml 和 bootStrap.yml 的加载顺序</h1><p>若application.yml 和bootStrap.yml 在同一目录下，则bootStrap.yml 的加载顺序要高于application.yml,即bootStrap.yml 会优先被加载。</p><p>原理：bootstrap.yml 用于应用程序上下文的引导阶段， bootstrap.yml 由父Spring ApplicationContext加载。</p><ul><li>bootstrap.yml 可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。</li><li>application.yml 可以用来定义应用级别的，如果搭配 spring-cloud-config 使用 application.yml 里面定义的文件可以实现动态替换。</li></ul><p>脚本里指定了配置文件：spring.config.location&#x3D;.&#x2F;bootstrap.yml, 则配置文件的加载顺序将为：</p><ol><li>cloud-config 仓库里指定的yml 配置；</li><li>.&#x2F;bootstrap.yml</li><li>classpath:&#x2F;bootstrap.yml</li><li>外部 application.yml</li><li>内部 application.yml</li></ol><p>脚本里指定了配置文件：spring.config.location&#x3D;.&#x2F;application.yml, 则配置文件的加载顺序将为：</p><ol><li><p>cloud-config 仓库里指定的yml 配置；</p></li><li><p>.&#x2F;application.yml</p></li><li><p>classpath:&#x2F;application.yml</p></li><li><p>.&#x2F;bootstrap.yml</p></li><li><p>classpath:&#x2F;bootstrap.yml</p></li></ol><h1 id="初始化Bean执行顺序"><a href="#初始化Bean执行顺序" class="headerlink" title="初始化Bean执行顺序"></a>初始化Bean执行顺序</h1><img src="/posts/4e9ceea/f1d0bd023bd44134a7f5536d5789d57dtplv-k3u1fbpfcp-watermark.image" srcset="/img/loading.gif" lazyload alt="img" style="zoom:50%"></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Java/" class="category-chain-item">Java</a> <span>></span> <a href="/categories/Java/Spring/" class="category-chain-item">Spring</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/spring/">#spring</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/9e086c9c/" title="kubernete 系统"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">kubernete 系统</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/15f9c4da/" title="JDK 安装（Windows）"><span class="hidden-mobile">JDK 安装（Windows）</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>