<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yahya的博客</title>
  
  <subtitle>学习笔记</subtitle>
  <link href="https://blog.yahyav2rayssr.top/atom.xml" rel="self"/>
  
  <link href="https://blog.yahyav2rayssr.top/"/>
  <updated>2023-04-16T15:59:52.152Z</updated>
  <id>https://blog.yahyav2rayssr.top/</id>
  
  <author>
    <name>Yahya</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 多线程入门</title>
    <link href="https://blog.yahyav2rayssr.top/posts/e5b78a2e/"/>
    <id>https://blog.yahyav2rayssr.top/posts/e5b78a2e/</id>
    <published>2023-04-16T15:59:52.152Z</published>
    <updated>2023-04-16T15:59:52.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程入门"><a href="#多线程入门" class="headerlink" title="多线程入门"></a>多线程入门</h1><h2 id="并发和并行"><a href="#并发和并行" class="headerlink" title="并发和并行"></a>并发和并行</h2><p><strong>并发：</strong></p><p>讲并发之前，要先看一张图：</p><img src="/posts/e5b78a2e/20160630152045731.png" class alt="这里写图片描述"><ol><li>Concurrency，是并发的意思。并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序（或线程）之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。</li><li>微观角度：所有的并发处理都有排队等候，唤醒，执行等这样的步骤，在微观上他们都是序列被处理的，如果是同一时刻到达的请求（或线程）也会根据优先级的不同，而先后进入队列排队等候执行。</li><li>宏观角度：多个几乎同时到达的请求（或线程）在宏观上看就像是同时在被处理。</li><li>通俗点讲，并发就是只有一个CPU资源，程序（或线程）之间要竞争得到执行机会。图中的第一个阶段，在A执行的过程中B，C不会执行，因为这段时间内这个CPU资源被A竞争到了，同理，第二个阶段只有B在执行，第三个阶段只有C在执行。其实，并发过程中，A，B，C并不是同时在进行的（微观角度）。但又是同时进行的（宏观角度）。</li></ol><hr><p><strong>并行：</strong></p><p>同样，在讲并行之前，要先看一张图：</p><img src="/posts/e5b78a2e/20160630153242623.png" class alt="这里写图片描述"><ol><li>Parallelism，即并行，指两个或两个以上事件（或线程）在同一时刻发生，是真正意义上的不同事件或线程在同一时刻，在不同CPU资源呢上（多核），同时执行。</li><li>并行，不存在像并发那样竞争，等待的概念。</li><li>图中，A，B，C都在同时运行（微观，宏观）。</li></ol><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><img src="/posts/e5b78a2e/image-20200911235701916.png" alt="image-20200911235701916" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200912000034891.png" alt="image-20200912000034891" style="zoom:33%;"><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><img src="/posts/e5b78a2e/image-20200912000610266.png" alt="image-20200912000610266" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200912000948036.png" alt="image-20200912000948036" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200912001054075.png" alt="image-20200912001054075" style="zoom:33%;"><h2 id="Thread和Runnable"><a href="#Thread和Runnable" class="headerlink" title="Thread和Runnable"></a>Thread和Runnable</h2><img src="/posts/e5b78a2e/image-20200912111614371.png" alt="image-20200912111614371" style="zoom:33%;"><h2 id="查看进程线程的方法"><a href="#查看进程线程的方法" class="headerlink" title="查看进程线程的方法"></a>查看进程线程的方法</h2><img src="/posts/e5b78a2e/image-20200912113958106.png" alt="image-20200912113958106" style="zoom:33%;"><h2 id="原理之线程运行"><a href="#原理之线程运行" class="headerlink" title="原理之线程运行"></a>原理之线程运行</h2><img src="/posts/e5b78a2e/image-20200912114438702.png" alt="image-20200912114438702" style="zoom:33%;"><h2 id="线程上下文切换"><a href="#线程上下文切换" class="headerlink" title="线程上下文切换"></a>线程上下文切换</h2><img src="/posts/e5b78a2e/image-20200912120958519.png" alt="image-20200912120958519" style="zoom:33%;"><h2 id="LockSupport-park"><a href="#LockSupport-park" class="headerlink" title="LockSupport.park"></a>LockSupport.park</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;park...&quot;</span>);<br>    <span class="hljs-comment">// 默认为false。interrupt会置为true，park失效</span><br>    LockSupport.park();<br>    log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>    log.debug(<span class="hljs-string">&quot;打断状态：&#123;&#125;&quot;</span>, Thread.currentThread().interrupted()); <span class="hljs-comment">// 打断标记设置为false</span><br>    <br>    <span class="hljs-comment">// 打断标记为false才就会生效，阻塞执行下面的逻辑</span><br>    LockSupport.park();<br>    log.debug(<span class="hljs-string">&quot;unpark...&quot;</span>);<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>t1.start();<br><br><br>sleep(<span class="hljs-number">0.5</span>);<br>t1.interrupt();<br></code></pre></td></tr></table></figure><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><img src="/posts/e5b78a2e/image-20200912222802490.png" alt="image-20200912222802490" style="zoom:33%;"><h2 id="原理之wait-x2F-notify"><a href="#原理之wait-x2F-notify" class="headerlink" title="原理之wait&#x2F;notify"></a>原理之wait&#x2F;notify</h2><img src="/posts/e5b78a2e/image-20200913160059010.png" alt="image-20200913160059010" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200913161400450.png" alt="image-20200913161400450" style="zoom:33%;"><h2 id="原理之Park-x2F-Unpark"><a href="#原理之Park-x2F-Unpark" class="headerlink" title="原理之Park&#x2F;Unpark"></a>原理之Park&#x2F;Unpark</h2><img src="/posts/e5b78a2e/image-20200915173151554.png" alt="image-20200915173151554" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200915173803809.png" alt="image-20200915173803809" style="zoom:33%;"><h2 id="线程转换状态"><a href="#线程转换状态" class="headerlink" title="线程转换状态"></a>线程转换状态</h2><img src="/posts/e5b78a2e/image-20200915174333003.png" alt="image-20200915174333003" style="zoom:33%;"><h2 id="活跃性"><a href="#活跃性" class="headerlink" title="活跃性"></a>活跃性</h2><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><h4 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h4><p>（1） <strong>互斥条件</strong>：一个资源每次只能被一个进程使用。  </p><p>（2） <strong>请求与保持条件</strong>：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  </p><p>（3） <strong>不剥夺条件</strong>:进程已获得的资源，在末使用完之前，不能强行剥夺。  </p><p>（4） <strong>循环等待条件</strong>:若干进程之间形成一种头尾相接的循环等待资源关系。</p><img src="/posts/e5b78a2e/image-20200915181849369.png" alt="image-20200915181849369" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">A</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">B</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (A) &#123;<br>        log.debug(<span class="hljs-string">&quot;lock A&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">synchronized</span> (B) &#123;<br>            log.debug(<span class="hljs-string">&quot;lock B&quot;</span>);<br>            log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">synchronized</span> (B) &#123;<br>        log.debug(<span class="hljs-string">&quot;lock B&quot;</span>);<br>        sleep(<span class="hljs-number">0.5</span>);<br>        <span class="hljs-keyword">synchronized</span> (A) &#123;<br>            log.debug(<span class="hljs-string">&quot;lock A&quot;</span>);<br>            log.debug(<span class="hljs-string">&quot;操作...&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br>t1.start();<br>t2.start();<br></code></pre></td></tr></table></figure><p>jstack打印结果</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs smali">Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;t2&quot;</span>:<br>  waiting to lock<span class="hljs-built_in"> monitor </span>0x000000002174fed8 (object 0x0000000741c9e3d8, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;t1&quot;</span><br><span class="hljs-string">&quot;t1&quot;</span>:<br>  waiting to lock<span class="hljs-built_in"> monitor </span>0x0000000021752348 (object 0x0000000741c9e3e8, a java.lang.Object),<br>  which is held by <span class="hljs-string">&quot;t2&quot;</span><br><br>Java stack information for the threads listed above:<br></code></pre></td></tr></table></figure><h4 id="哲学家问题"><a href="#哲学家问题" class="headerlink" title="哲学家问题"></a>哲学家问题</h4><img src="/posts/e5b78a2e/image-20200915183934459.png" alt="image-20200915183934459" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDeadLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;4&quot;</span>);<br>        <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;5&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c1, c5).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Philosopher&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Chopstick left;<br>    Chopstick right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//　尝试获得左手筷子</span><br>            <span class="hljs-keyword">synchronized</span> (left) &#123;<br>                <span class="hljs-comment">// 尝试获得右手筷子</span><br>                <span class="hljs-keyword">synchronized</span> (right) &#123;<br>                    eat();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">0.5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> &#123;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test23&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test23</span> &#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;4&quot;</span>);<br>    <span class="hljs-type">Chopstick</span> <span class="hljs-variable">c5</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Chopstick</span>(<span class="hljs-string">&quot;5&quot;</span>);<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;苏格拉底&quot;</span>, c1, c2).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;柏拉图&quot;</span>, c2, c3).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;亚里士多德&quot;</span>, c3, c4).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;赫拉克利特&quot;</span>, c4, c5).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Philosopher</span>(<span class="hljs-string">&quot;阿基米德&quot;</span>, c5, c1).start();<br>&#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Philosopher&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Philosopher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    Chopstick left;<br>    Chopstick right;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Philosopher</span><span class="hljs-params">(String name, Chopstick left, Chopstick right)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">//　尝试获得左手筷子</span><br>            <span class="hljs-keyword">if</span>(left.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 尝试获得右手筷子</span><br>                    <span class="hljs-keyword">if</span>(right.tryLock()) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            eat();<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            right.unlock();<br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    left.unlock(); <span class="hljs-comment">// 释放自己手里的筷子</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;eating...&quot;</span>);<br>        Sleeper.sleep(<span class="hljs-number">0.5</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Chopstick</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>    String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Chopstick</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;筷子&#123;&quot;</span> + name + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h3><img src="/posts/e5b78a2e/image-20200915183900574.png" alt="image-20200915183900574" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestLiveLock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestLiveLock</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望减到 0 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                count--;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 期望超过 20 退出循环</span><br>            <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">20</span>) &#123;<br>                sleep(<span class="hljs-number">0.2</span>);<br>                count++;<br>                log.debug(<span class="hljs-string">&quot;count: &#123;&#125;&quot;</span>, count);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>措施：</p><p>增加随机睡眠时间来避免活锁</p><h3 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h3><img src="/posts/e5b78a2e/image-20200915184559151.png" alt="image-20200915184559151" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200915184749467.png" alt="image-20200915184749467" style="zoom:33%;"><p>顺序加锁容易产生饥饿问题</p><h2 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h2><p>ReentrantLock尽量使用tryLock方法来防止无限制的等待</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test22&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test22</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;尝试获得锁&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (! lock.tryLock(<span class="hljs-number">2</span>, TimeUnit.SECONDS)) &#123;<br>                    log.debug(<span class="hljs-string">&quot;获取不到锁&quot;</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>                log.debug(<span class="hljs-string">&quot;获取不到锁&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br>        lock.lock();<br>        log.debug(<span class="hljs-string">&quot;获得到锁&quot;</span>);<br>        t1.start();<br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;释放了锁&quot;</span>);<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="控制线程启动顺序"><a href="#控制线程启动顺序" class="headerlink" title="控制线程启动顺序"></a>控制线程启动顺序</h2><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test25&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test25</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-comment">// 表示 t2 是否运行过</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">t2runned</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-keyword">while</span> (!t2runned) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br><br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>                t2runned = <span class="hljs-literal">true</span>;<br>                lock.notify();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法2：ReentrantLock实现"><a href="#方法2：ReentrantLock实现" class="headerlink" title="方法2：ReentrantLock实现"></a>方法2：ReentrantLock实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test26&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test26</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LockSupport.park();<br>            log.debug(<span class="hljs-string">&quot;1&quot;</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>);<br>        t1.start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;2&quot;</span>);<br>            LockSupport.unpark(t1);<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test24&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test24</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">room</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasCigarette</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">hasTakeout</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">ROOM</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 等待烟的休息室</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitCigaretteSet</span> <span class="hljs-operator">=</span> ROOM.newCondition();<br>    <span class="hljs-comment">// 等外卖的休息室</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">waitTakeoutSet</span> <span class="hljs-operator">=</span> ROOM.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            ROOM.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);<br>                <span class="hljs-keyword">while</span> (!hasCigarette) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没烟，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        waitCigaretteSet.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                ROOM.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小南&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            ROOM.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);<br>                <span class="hljs-keyword">while</span> (!hasTakeout) &#123;<br>                    log.debug(<span class="hljs-string">&quot;没外卖，先歇会！&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        waitTakeoutSet.await();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                log.debug(<span class="hljs-string">&quot;可以开始干活了&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                ROOM.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;小女&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            ROOM.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                hasTakeout = <span class="hljs-literal">true</span>;<br>                waitTakeoutSet.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                ROOM.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送外卖的&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            ROOM.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                hasCigarette = <span class="hljs-literal">true</span>;<br>                waitCigaretteSet.signal();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                ROOM.unlock();<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;送烟的&quot;</span>).start();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="交替输出"><a href="#交替输出" class="headerlink" title="交替输出"></a>交替输出</h2><h3 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test27&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test27</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">WaitNotify</span> <span class="hljs-variable">wn</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNotify</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            wn.print(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">输出内容       等待标记     下一个标记</span><br><span class="hljs-comment">   a           1             2</span><br><span class="hljs-comment">   b           2             3</span><br><span class="hljs-comment">   c           3             1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotify</span> &#123;<br>    <span class="hljs-comment">// 打印               a           1             2</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, <span class="hljs-type">int</span> waitFlag, <span class="hljs-type">int</span> nextFlag)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">while</span>(flag != waitFlag) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-built_in">this</span>.wait();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>                System.out.print(str);<br>                flag = nextFlag;<br>                <span class="hljs-built_in">this</span>.notifyAll();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 等待标记</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> flag; <span class="hljs-comment">// 2</span><br>    <span class="hljs-comment">// 循环次数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WaitNotify</span><span class="hljs-params">(<span class="hljs-type">int</span> flag, <span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test30</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">AwaitSignal</span> <span class="hljs-variable">awaitSignal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AwaitSignal</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> awaitSignal.newCondition();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;a&quot;</span>, a, b);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;b&quot;</span>, b, c);<br>        &#125;).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            awaitSignal.print(<span class="hljs-string">&quot;c&quot;</span>, c, a);<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        awaitSignal.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始...&quot;</span>);<br>            a.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            awaitSignal.unlock();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AwaitSignal</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AwaitSignal</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br>    <span class="hljs-comment">//            参数1 打印内容， 参数2 进入哪一间休息室, 参数3 下一间休息室</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Condition current, Condition next)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                current.await();<br>                System.out.print(str);<br>                next.signal();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法3："><a href="#方法3：" class="headerlink" title="方法3："></a>方法3：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test31&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test31</span> &#123;<br><br>    <span class="hljs-keyword">static</span> Thread t1;<br>    <span class="hljs-keyword">static</span> Thread t2;<br>    <span class="hljs-keyword">static</span> Thread t3;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ParkUnpark</span> <span class="hljs-variable">pu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParkUnpark</span>(<span class="hljs-number">5</span>);<br>        t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            pu.print(<span class="hljs-string">&quot;a&quot;</span>, t2);<br>        &#125;);<br>        t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            pu.print(<span class="hljs-string">&quot;b&quot;</span>, t3);<br>        &#125;);<br>        t3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            pu.print(<span class="hljs-string">&quot;c&quot;</span>, t1);<br>        &#125;);<br>        t1.start();<br>        t2.start();<br>        t3.start();<br><br>        LockSupport.unpark(t1);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkUnpark</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">(String str, Thread next)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; loopNumber; i++) &#123;<br>            LockSupport.park();<br>            System.out.print(str);<br>            LockSupport.unpark(next);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> loopNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ParkUnpark</span><span class="hljs-params">(<span class="hljs-type">int</span> loopNumber)</span> &#123;<br>        <span class="hljs-built_in">this</span>.loopNumber = loopNumber;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/e5b78a2e/image-20200915231501631.png" alt="image-20200915231501631" style="zoom:33%;"><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><img src="/posts/e5b78a2e/image-20200917183943394.png" alt="image-20200917183943394" style="zoom:33%;"><h3 id="退不出的循环"><a href="#退不出的循环" class="headerlink" title="退不出的循环"></a>退不出的循环</h3><img src="/posts/e5b78a2e/image-20200917184257178.png" alt="image-20200917184257178" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200917184310494.png" alt="image-20200917184310494" style="zoom:33%;"><h2 id="指令重排序优化"><a href="#指令重排序优化" class="headerlink" title="指令重排序优化"></a>指令重排序优化</h2><img src="/posts/e5b78a2e/image-20200917222909053.png" alt="image-20200917222909053" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200917223317036.png" alt="image-20200917223317036" style="zoom:33%;"><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><img src="/posts/e5b78a2e/image-20200917224742510.png" alt="image-20200917224742510"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JCStressTest</span><br><span class="hljs-meta">@Outcome(id = &#123;&quot;1&quot;, &quot;4&quot;&#125;, expect = Expect.ACCEPTABLE, desc = &quot;ok&quot;)</span><br><span class="hljs-meta">@Outcome(id = &quot;0&quot;, expect = Expect.ACCEPTABLE_INTERESTING, desc = &quot;!!!!&quot;)</span><br><span class="hljs-meta">@State</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrencyTest</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor1</span><span class="hljs-params">(I_Result r)</span> &#123;<br>        <span class="hljs-keyword">if</span>(ready) &#123;<br>            r.r1 = num + num;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            r.r1 = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Actor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">actor2</span><span class="hljs-params">(I_Result r)</span> &#123;<br>        num = <span class="hljs-number">2</span>;<br>        ready = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="volatile禁止重排序"><a href="#volatile禁止重排序" class="headerlink" title="volatile禁止重排序"></a>volatile禁止重排序</h2><img src="/posts/e5b78a2e/image-20200917225716902.png" alt="image-20200917225716902" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200917230709295.png" alt="image-20200917230709295" style="zoom:33%;"><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><ul><li>单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。</li><li>锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。</li><li>volatile的happen-before原则：对一个volatile变量的写操作happen-before对此变量的任意操作(当然也包括写操作了)。</li><li>happen-before的传递性原则：如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。</li><li>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。</li><li>线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。</li><li>线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。</li><li>对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。</li></ul><img src="/posts/e5b78a2e/image-20200919114008329.png" alt="image-20200919114008329" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919114016127.png" alt="image-20200919114016127" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919114303480.png" alt="image-20200919114303480" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919114423652.png" alt="image-20200919114423652" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919114535252.png" alt="image-20200919114535252" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919114704185.png" alt="image-20200919114704185" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919114952263.png" alt="image-20200919114952263" style="zoom:33%;"><h2 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h2><h3 id="AtomicBoolean"><a href="#AtomicBoolean" class="headerlink" title="AtomicBoolean"></a>AtomicBoolean</h3><h3 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h3><h3 id="AtomicLong"><a href="#AtomicLong" class="headerlink" title="AtomicLong"></a>AtomicLong</h3><img src="/posts/e5b78a2e/image-20200919192658877.png" alt="image-20200919192658877" style="zoom:33%;"><p>updateAndGet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test34</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">/*System.out.println(i.incrementAndGet()); // ++i   1</span><br><span class="hljs-comment">        System.out.println(i.getAndIncrement()); // i++   2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        System.out.println(i.getAndAdd(5)); // 2 , 7</span><br><span class="hljs-comment">        System.out.println(i.addAndGet(5)); // 12, 12*/</span><br><br>        <span class="hljs-comment">//             读取到    设置值</span><br><span class="hljs-comment">//        i.updateAndGet(value -&gt; value * 10);</span><br><br>        System.out.println(updateAndGet(i, p -&gt; p / <span class="hljs-number">2</span>));<br><br><span class="hljs-comment">//        i.getAndUpdate()</span><br>        System.out.println(i.get());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">updateAndGet</span><span class="hljs-params">(AtomicInteger i, IntUnaryOperator operator)</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> i.get();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> operator.applyAsInt(prev);<br>            <span class="hljs-keyword">if</span> (i.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">return</span> next;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h2><img src="/posts/e5b78a2e/image-20200919195141609.png" alt="image-20200919195141609" style="zoom:33%;"><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecimalAccountCas</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DecimalAccount</span> &#123;<br>    <span class="hljs-keyword">private</span> AtomicReference&lt;BigDecimal&gt; balance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecimalAccountCas</span><span class="hljs-params">(BigDecimal balance)</span> &#123;<br><span class="hljs-comment">//        this.balance = balance;</span><br>        <span class="hljs-built_in">this</span>.balance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(balance);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> balance.get();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(BigDecimal amount)</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> balance.get();<br>            <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev.subtract(amount);<br>            <span class="hljs-keyword">if</span> (balance.compareAndSet(prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><blockquote><p>带version标记的原子引用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    log.debug(<span class="hljs-string">&quot;main start...&quot;</span>);<br>    <span class="hljs-comment">// 获取值 A</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>    <span class="hljs-comment">// 获取版本号</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> ref.getStamp();<br>    log.debug(<span class="hljs-string">&quot;版本 &#123;&#125;&quot;</span>, stamp);<br>    <span class="hljs-comment">// 如果中间有其它线程干扰，发生了 ABA 现象</span><br>    other();<br>    sleep(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 尝试改为 C</span><br>    log.debug(<span class="hljs-string">&quot;change A-&gt;C &#123;&#125;&quot;</span>, ref.compareAndSet(prev, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AtomicMarkableReference"><a href="#AtomicMarkableReference" class="headerlink" title="AtomicMarkableReference"></a>AtomicMarkableReference</h3><blockquote><p>只判断是否发生过修改，不在乎修改过多少次</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test38&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test38</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">GarbageBag</span> <span class="hljs-variable">bag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GarbageBag</span>(<span class="hljs-string">&quot;装满了垃圾&quot;</span>);<br>        <span class="hljs-comment">// 参数2 mark 可以看作一个标记，表示垃圾袋满了</span><br>        AtomicMarkableReference&lt;GarbageBag&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(bag, <span class="hljs-literal">true</span>);<br><br>        log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>        <span class="hljs-type">GarbageBag</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> ref.getReference();<br>        log.debug(prev.toString());<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            log.debug(<span class="hljs-string">&quot;start...&quot;</span>);<br>            bag.setDesc(<span class="hljs-string">&quot;空垃圾袋&quot;</span>);<br>            ref.compareAndSet(bag, bag, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>            log.debug(bag.toString());<br>        &#125;,<span class="hljs-string">&quot;保洁阿姨&quot;</span>).start();<br><br>        sleep(<span class="hljs-number">1</span>);<br>        log.debug(<span class="hljs-string">&quot;想换一只新垃圾袋？&quot;</span>);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> ref.compareAndSet(prev, <span class="hljs-keyword">new</span> <span class="hljs-title class_">GarbageBag</span>(<span class="hljs-string">&quot;空垃圾袋&quot;</span>), <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>        log.debug(<span class="hljs-string">&quot;换了么？&quot;</span> + success);<br>        log.debug(ref.getReference().toString());<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GarbageBag</span> &#123;<br>    String desc;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GarbageBag</span><span class="hljs-params">(String desc)</span> &#123;<br>        <span class="hljs-built_in">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDesc</span><span class="hljs-params">(String desc)</span> &#123;<br>        <span class="hljs-built_in">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString() + <span class="hljs-string">&quot; &quot;</span> + desc;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h2><h3 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h3><h3 id="AtomicLongArray"><a href="#AtomicLongArray" class="headerlink" title="AtomicLongArray"></a>AtomicLongArray</h3><h3 id="AtomicReferenceArray"><a href="#AtomicReferenceArray" class="headerlink" title="AtomicReferenceArray"></a>AtomicReferenceArray</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test39</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        demo(<br>                ()-&gt;<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">10</span>],<br>                (array)-&gt;array.length,<br>                (array, index) -&gt; array[index]++,<br>                array-&gt; System.out.println(Arrays.toString(array))<br>        );<br><br>        demo(<br>                ()-&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-number">10</span>),<br>                (array) -&gt; array.length(),<br>                (array, index) -&gt; array.getAndIncrement(index),<br>                array -&gt; System.out.println(array)<br>        );<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     参数1，提供数组、可以是线程不安全数组或线程安全数组</span><br><span class="hljs-comment">     参数2，获取数组长度的方法</span><br><span class="hljs-comment">     参数3，自增方法，回传 array, index</span><br><span class="hljs-comment">     参数4，打印数组的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// supplier 提供者 无中生有  ()-&gt;结果</span><br>    <span class="hljs-comment">// function 函数   一个参数一个结果   (参数)-&gt;结果  ,  BiFunction (参数1,参数2)-&gt;结果</span><br>    <span class="hljs-comment">// consumer 消费者 一个参数没结果  (参数)-&gt;void,      BiConsumer (参数1,参数2)-&gt;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">demo</span><span class="hljs-params">(</span><br><span class="hljs-params">            Supplier&lt;T&gt; arraySupplier,</span><br><span class="hljs-params">            Function&lt;T, Integer&gt; lengthFun,</span><br><span class="hljs-params">            BiConsumer&lt;T, Integer&gt; putConsumer,</span><br><span class="hljs-params">            Consumer&lt;T&gt; printConsumer )</span> &#123;<br>        List&lt;Thread&gt; ts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">T</span> <span class="hljs-variable">array</span> <span class="hljs-operator">=</span> arraySupplier.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> lengthFun.apply(array);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-comment">// 每个线程对数组作 10000 次操作</span><br>            ts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>                    putConsumer.accept(array, j%length);<br>                &#125;<br>            &#125;));<br>        &#125;<br><br>        ts.forEach(t -&gt; t.start()); <span class="hljs-comment">// 启动所有线程</span><br>        ts.forEach(t -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.join();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);     <span class="hljs-comment">// 等所有线程结束</span><br>        printConsumer.accept(array);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h2><h3 id="AtomicLongFieldUpdater"><a href="#AtomicLongFieldUpdater" class="headerlink" title="AtomicLongFieldUpdater"></a>AtomicLongFieldUpdater</h3><h3 id="AtomicIntegerFieldUpdater"><a href="#AtomicIntegerFieldUpdater" class="headerlink" title="AtomicIntegerFieldUpdater"></a>AtomicIntegerFieldUpdater</h3><h3 id="AtomicReferenceFieldUpdater"><a href="#AtomicReferenceFieldUpdater" class="headerlink" title="AtomicReferenceFieldUpdater"></a>AtomicReferenceFieldUpdater</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test40&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test40</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">stu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br><br>        <span class="hljs-type">AtomicReferenceFieldUpdater</span> <span class="hljs-variable">updater</span> <span class="hljs-operator">=</span><br>                AtomicReferenceFieldUpdater.newUpdater(Student.class, String.class, <span class="hljs-string">&quot;name&quot;</span>);<br><br>        System.out.println(updater.compareAndSet(stu, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;张三&quot;</span>));<br>        System.out.println(stu);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">volatile</span> String name;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Student&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h2><h3 id="DoubleAccumulator"><a href="#DoubleAccumulator" class="headerlink" title="DoubleAccumulator"></a>DoubleAccumulator</h3><h3 id="DoubleAdder"><a href="#DoubleAdder" class="headerlink" title="DoubleAdder"></a>DoubleAdder</h3><h3 id="LongAccumulator"><a href="#LongAccumulator" class="headerlink" title="LongAccumulator"></a>LongAccumulator</h3><h3 id="LongAdder"><a href="#LongAdder" class="headerlink" title="LongAdder"></a>LongAdder</h3><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><img src="/posts/e5b78a2e/image-20200919221427651.png" alt="image-20200919221427651" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919221630951.png" alt="image-20200919221630951" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919221716492.png" alt="image-20200919221716492" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919221956479.png" alt="image-20200919221956479" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919222309609.png" alt="image-20200919222309609" style="zoom:33%;"><img src="/posts/e5b78a2e/image-20200919222723212.png" alt="image-20200919222723212" style="zoom:33%;"><h5 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">long</span> x)</span> &#123;<br>    Cell[] as; <span class="hljs-type">long</span> b, v; <span class="hljs-type">int</span> m; Cell a;<br>    <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> || !casBase(b = base, b + x)) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">uncontended</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span> (as == <span class="hljs-literal">null</span> || (m = as.length - <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span> ||<br>            (a = as[getProbe() &amp; m]) == <span class="hljs-literal">null</span> ||<br>            !(uncontended = a.cas(v = a.value, v + x)))<br>            longAccumulate(x, <span class="hljs-literal">null</span>, uncontended);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/e5b78a2e/image-20200919223703252.png" alt="image-20200919223703252" style="zoom:33%;"><h5 id="longAccumulate方法"><a href="#longAccumulate方法" class="headerlink" title="longAccumulate方法"></a>longAccumulate方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">longAccumulate</span><span class="hljs-params">(<span class="hljs-type">long</span> x, LongBinaryOperator fn,</span><br><span class="hljs-params">                          <span class="hljs-type">boolean</span> wasUncontended)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">if</span> ((h = getProbe()) == <span class="hljs-number">0</span>) &#123;<br>        ThreadLocalRandom.current(); <span class="hljs-comment">// force initialization</span><br>        h = getProbe();<br>        wasUncontended = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">collide</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;                <span class="hljs-comment">// True if last slot nonempty</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        Cell[] as; Cell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;<br>        <span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>            ...<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>                <span class="hljs-keyword">if</span> (cells == as) &#123;<br>                    Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[<span class="hljs-number">2</span>];<br>                    rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);<br>                    cells = rs;<br>                    init = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                cellsBusy = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (init)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casBase(v = base, ((fn == <span class="hljs-literal">null</span>) ? v + x :<br>                                    fn.applyAsLong(v, x))))<br>            <span class="hljs-keyword">break</span>;                          <span class="hljs-comment">// Fall back on using base</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/e5b78a2e/image-20200919224200033.png" alt="image-20200919224200033" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">Cell[] as; Cell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;<br><span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> ((a = as[(n - <span class="hljs-number">1</span>) &amp; h]) == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span>) &#123;       <span class="hljs-comment">// Try to attach new Cell</span><br>            <span class="hljs-type">Cell</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>(x);   <span class="hljs-comment">// Optimistically create</span><br>            <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">created</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;               <span class="hljs-comment">// Recheck under lock</span><br>                    Cell[] rs; <span class="hljs-type">int</span> m, j;<br>                    <span class="hljs-keyword">if</span> ((rs = cells) != <span class="hljs-literal">null</span> &amp;&amp;<br>                        (m = rs.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>                        rs[j = (m - <span class="hljs-number">1</span>) &amp; h] == <span class="hljs-literal">null</span>) &#123;<br>                        rs[j] = r;<br>                        created = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    cellsBusy = <span class="hljs-number">0</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (created)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">continue</span>;           <span class="hljs-comment">// Slot is now non-empty</span><br>            &#125;<br>        &#125;<br>        collide = <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><img src="/posts/e5b78a2e/image-20200919224817730.png" alt="image-20200919224817730" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java">Cell[] as; Cell a; <span class="hljs-type">int</span> n; <span class="hljs-type">long</span> v;<br><span class="hljs-keyword">if</span> ((as = cells) != <span class="hljs-literal">null</span> &amp;&amp; (n = as.length) &gt; <span class="hljs-number">0</span>) &#123;                <br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!wasUncontended)       <span class="hljs-comment">// CAS already known to fail</span><br>                  wasUncontended = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// Continue after rehash</span><br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (a.cas(v = a.value, ((fn == <span class="hljs-literal">null</span>) ? v + x :<br>                                           fn.applyAsLong(v, x))))<br>                  <span class="hljs-keyword">break</span>;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt;= NCPU || cells != as)<br>                  collide = <span class="hljs-literal">false</span>;            <span class="hljs-comment">// At max size or stale</span><br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!collide)<br>                  collide = <span class="hljs-literal">true</span>;<br>              <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; casCellsBusy()) &#123;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      <span class="hljs-keyword">if</span> (cells == as) &#123;      <span class="hljs-comment">// Expand table unless stale</span><br>                          Cell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cell</span>[n &lt;&lt; <span class="hljs-number">1</span>];<br>                          <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; ++i)<br>                              rs[i] = as[i];<br>                          cells = rs;<br>                      &#125;<br>                  &#125; <span class="hljs-keyword">finally</span> &#123;<br>                      cellsBusy = <span class="hljs-number">0</span>;<br>                  &#125;<br>                  collide = <span class="hljs-literal">false</span>;<br>                  <span class="hljs-keyword">continue</span>;                   <span class="hljs-comment">// Retry with expanded table</span><br>              &#125;<br>              h = advanceProbe(h);<br>      &#125;<br></code></pre></td></tr></table></figure><img src="/posts/e5b78a2e/image-20200919230458646.png" alt="image-20200919230458646" style="zoom:33%;"><h2 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h2><img src="/posts/e5b78a2e/image-20200919232047239.png" alt="image-20200919232047239" style="zoom:33%;"><h3 id="对象属性赋值"><a href="#对象属性赋值" class="headerlink" title="对象属性赋值"></a>对象属性赋值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestUnsafe</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException, IllegalAccessException &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> (Unsafe) theUnsafe.get(<span class="hljs-literal">null</span>);<br><br>        System.out.println(unsafe);<br><br>        <span class="hljs-comment">// 1. 获取域的偏移地址</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">idOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;id&quot;</span>));<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nameOffset</span> <span class="hljs-operator">=</span> unsafe.objectFieldOffset(Teacher.class.getDeclaredField(<span class="hljs-string">&quot;name&quot;</span>));<br><br>        <span class="hljs-type">Teacher</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>();<br>        <span class="hljs-comment">// 2. 执行 cas 操作</span><br>        unsafe.compareAndSwapInt(t, idOffset, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        unsafe.compareAndSwapObject(t, nameOffset, <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">// 3. 验证</span><br>        System.out.println(t);<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">volatile</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模拟实现原子整数"><a href="#模拟实现原子整数" class="headerlink" title="模拟实现原子整数"></a>模拟实现原子整数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.Test42&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test42</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Account.demo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyAtomicInteger</span>(<span class="hljs-number">10000</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAtomicInteger</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> valueOffset;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe UNSAFE;<br>    <span class="hljs-keyword">static</span> &#123;<br>        UNSAFE = UnsafeAccessor.getUnsafe();<br>        <span class="hljs-keyword">try</span> &#123;<br>            valueOffset = UNSAFE.objectFieldOffset(MyAtomicInteger.class.getDeclaredField(<span class="hljs-string">&quot;value&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrement</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.value;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> prev - amount;<br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, valueOffset, prev, next)) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyAtomicInteger</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>        <span class="hljs-built_in">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getBalance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getValue();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(Integer amount)</span> &#123;<br>        decrement(amount);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafeAccessor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Field</span> <span class="hljs-variable">theUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            theUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>            unsafe = (Unsafe) theUnsafe.get(<span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title function_">getUnsafe</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> unsafe;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><img src="/posts/e5b78a2e/image-20200920100801862.png" alt="image-20200920100801862" style="zoom:33%;"><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><img src="/posts/e5b78a2e/image-20200920103340757.png" alt="image-20200920103340757" style="zoom:33%;"><h3 id="String串池"><a href="#String串池" class="headerlink" title="String串池"></a>String串池</h3><h3 id="BigDecimal-BigInteger"><a href="#BigDecimal-BigInteger" class="headerlink" title="BigDecimal BigInteger"></a>BigDecimal BigInteger</h3><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Pool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> pool.borrow();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>));<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                pool.free(conn);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Pool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>    <span class="hljs-comment">// 1. 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br><br>    <span class="hljs-comment">// 2. 连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br><br>    <span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br><br>    <span class="hljs-comment">// 4. 构造方法初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];<br>        <span class="hljs-built_in">this</span>.states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 借连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>                <span class="hljs-comment">// 获取空闲连接</span><br>                <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                        log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                        <span class="hljs-keyword">return</span> connections[i];<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有空闲连接，当前线程进入等待</span><br>            <span class="hljs-comment">// CAS 设置不了状态1会一直空转，这可能会耗尽 CPU 资源，所以要加这个 synchronized 代码块来防止</span><br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;wait...&quot;</span>);<br>                    <span class="hljs-built_in">this</span>.wait();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 6. 归还连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                states.set(i, <span class="hljs-number">0</span>);<br>                <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>                    log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>                    <span class="hljs-built_in">this</span>.notifyAll();<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MockConnection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Connection</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MockConnection</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MockConnection&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/e5b78a2e/image-20200920111849212.png" alt="image-20200920111849212" style="zoom:33%;"><h2 id="final原理"><a href="#final原理" class="headerlink" title="final原理"></a>final原理</h2><img src="/posts/e5b78a2e/image-20200920113000984.png" alt="image-20200920113000984" style="zoom:33%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程入门&quot;&gt;&lt;a href=&quot;#多线程入门&quot; class=&quot;headerlink&quot; title=&quot;多线程入门&quot;&gt;&lt;/a&gt;多线程入门&lt;/h1&gt;&lt;h2 id=&quot;并发和并行&quot;&gt;&lt;a href=&quot;#并发和并行&quot; class=&quot;headerlink&quot; title=&quot;并发和</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程设计模式</title>
    <link href="https://blog.yahyav2rayssr.top/posts/4b405cfc/"/>
    <id>https://blog.yahyav2rayssr.top/posts/4b405cfc/</id>
    <published>2023-04-16T15:55:17.664Z</published>
    <updated>2023-04-16T15:55:17.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程设计模式"><a href="#多线程设计模式" class="headerlink" title="多线程设计模式"></a>多线程设计模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="线程的终止"><a href="#线程的终止" class="headerlink" title="线程的终止"></a>线程的终止</h3><p>Java程序的终止是指除守护进程以外的线程全部终止。</p><h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><p>线程之间由于相互竞争而引起的与预期相反的情况称为数据竞争（data race）或竞态条件（race condition）。</p><h3 id="监视"><a href="#监视" class="headerlink" title="监视"></a>监视</h3><p>线程的互斥机制称为<strong>监视</strong>（monitor）。另外，获取锁有时也叫做“拥有监视”或“持有锁”。</p><p>当前线程是否已获取某一对象的锁可以通过Thread.holdsLock方法来确认。当前线程已获取对象obj的锁时，可使用assert来像下面表示出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">assert</span> Thread.holdsLock(obj)<br></code></pre></td></tr></table></figure><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p>HashTable中的所有方法都采用Single Threaded Execution模式，而ConcurrentHashMap则将内部数据结构分成多段，针对各段操作的线程互不相干，因而也就无需针对其他线程执行互斥处理。这样看来，HashTable更容易发生线程冲突。</p><p><strong><code>java.util.concurrent.CocurrentHashMap</code>接口是通过分割内部数据结构防止线程冲突的Map。</strong></p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore是一种基于计数的信号量。它可以设定一个阈值，基于此，多个线程竞争获取许可信号，做完自己的申请后归还，超过阈值后，线程申请许可信号将会被阻塞。Semaphore可以用来构建一些对象池，资源池之类的，比如数据库连接池，我们也可以创建计数为1的Semaphore，将其作为一种类似互斥锁的机制，这也叫二元信号量，表示两种互斥状态。</p><p>资源的许可个数（permits）将通过Semaphore的构造函数来确定。</p><ul><li>Semaphore的acquire方法用于确保存在可用资源。</li><li>Semephore的release方法用户释放资源。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printLn</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: &quot;</span> + s);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedResource</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore semaphore;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">314159</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BoundedResource</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.semaphore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-keyword">permits</span>);<br>        <span class="hljs-built_in">this</span>.<span class="hljs-keyword">permits</span> = <span class="hljs-keyword">permits</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        semaphore.acquire();<br>        <span class="hljs-keyword">try</span> &#123;<br>            doUse();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            semaphore.release();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doUse</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Log.printLn(<span class="hljs-string">&quot;BEGIN: used = &quot;</span> + (<span class="hljs-keyword">permits</span> - semaphore.availablePermits()));<br>        Thread.sleep(random.nextInt(<span class="hljs-number">500</span>));<br>        Log.printLn(<span class="hljs-string">&quot;END: used = &quot;</span> + (<span class="hljs-keyword">permits</span> - semaphore.availablePermits()));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">26344</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BoundedResource resource;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserThread</span><span class="hljs-params">(BoundedResource resource)</span> &#123;<br>        <span class="hljs-built_in">this</span>.resource = resource;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                resource.use();<br>                Thread.sleep(random.nextInt(<span class="hljs-number">3000</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">BoundedResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoundedResource</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserThread</span>(resource).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Before-x2F-After模式"><a href="#Before-x2F-After模式" class="headerlink" title="Before&#x2F;After模式"></a>Before&#x2F;After模式</h2><p>before&#x2F;After模式主要在于finally的引入。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">()</span> &#123;<br>    lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//业务逻辑</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h2><p>ThreadFactory翻译过来是线程工厂，顾名思义，就是用来创建线程的，它用到了工厂模式的思想。它通常和线程池一起使用，主要用来控制创建新线程时的一些行为，比如设置线程的优先级，名字等等。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> Executors.defaultThreadFactory();<br>        factory.newThread(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Printer</span>(<span class="hljs-string">&quot;Nice!&quot;</span>)).start();<br>        factory.newThread(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Printer</span>(<span class="hljs-string">&quot;Bitch!&quot;</span>)).start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Good&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>单线程程序中使用synchronized方法并不会破坏程序的安全性。但是，调用synchronized方法要比调用一般方法花费时间，这会稍微降低程序性能。</p></blockquote><blockquote><p>long，double的赋值和引用操作并不是原子的。总结如下：</p><ul><li>基本类型、引用类型的赋值和引用是原子操作。</li><li>long和double的赋值和引用是非原子操作。</li><li>long或double在线程间共享时，需要将其放入synchronized中操作，或者声明为volatile。</li></ul></blockquote><blockquote><p>字符串和实例表达式通过运算符“+”连接时，程序会自动调用实例表达式的toString()方法。</p></blockquote><blockquote><p>Thread.yield并不会释放锁。</p></blockquote><h2 id="Single-Threaded-Execution模式"><a href="#Single-Threaded-Execution模式" class="headerlink" title="Single Threaded Execution模式"></a>Single Threaded Execution模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Single Threaded Execution模式主要是用于确保同一时间内只能让一个线程执行处理，说通俗点就是对synchronized的标准化使用方式，这是比较基础的。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>Single Threaded Execution 模式的角色如下：</p><p>SharedResource(共享资源)参与者<br> SharedResource就是多线线程会同时访问的资源类，该类通常具有2类方法：<br> ①SafeMethod——从多个线程同时调用也不会发生问题的方法<br> ②UnsafeMethod——从多个线程同时调用会发生问题，这类方法需要加以防护，指定只能由单线程访问区域，即临界区（critical section）。</p><img src="/posts/4b405cfc/37.jpg" style="zoom:67%;"><h2 id="Immutable模式"><a href="#Immutable模式" class="headerlink" title="Immutable模式"></a>Immutable模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Immutable是“永恒的”“不会改变”的意思。在Immutable Patttern中，有着能够保证实例状态绝不会改变的类（immutable 类）。因为访问这个实例时，可以省去使用共享互斥机制所会浪费的时间，提高系统性能。java.lang.String就是一个Immutable的类。</p><p><strong>模式讲解</strong></p><ul><li>Immutable(不变的)参与者<br>Immutable参与者是一个字段值无法更改的类，也没有任何用来更改字段值的方法。当Immutable参与者的实例建立后，状态就完全不再变化。</li></ul><img src="/posts/4b405cfc/38.jpg" style="zoom: 80%;"><blockquote><p>即便字段是final字段，且不存在setter方法，也有可能不是不可变的。因为即使字段的值不会发生变化，字段引用的实例也有可能会发生变化。</p></blockquote><p>Java标准类库中用到immutable模式</p><ul><li>java.lang.String</li><li>java.math.BigInteger 和 java.math.BigDecimal。（BigInterger表示所有精度的整数，BigDecimal表示所有精度的数）</li><li>java.util.regex.Pattern 正则表达式</li><li>java.lang.Integer等基本类型的包装类</li><li>java.awt.Color</li></ul><blockquote><p>java.lang.Void类不同于其他的包装类，它无法创建实例。该类用于保存表示基本类型void的Class类的实例，用在反射和序列化中。</p></blockquote><h2 id="Guarded-Suspension模式"><a href="#Guarded-Suspension模式" class="headerlink" title="Guarded Suspension模式"></a>Guarded Suspension模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>guarded是“被保护着的”、“被防卫着的”意思，suspension则是“暂停”的意思。当现在并不适合马上执行某个操作时，就要求想要执行该操作的线程等待。</p><h3 id="模式讲解"><a href="#模式讲解" class="headerlink" title="模式讲解"></a>模式讲解</h3><p>角色：<br> Guarded Suspension Pattern 的角色如下：</p><ul><li>GuardedObject  (被防卫的对象)参与者<br> GuardedObject 参与者是一个拥有被防卫的方法（guardedMethod）的类。当线程执行guardedMethod时，只要满足警戒条件，就能继续执行，否则线程会进入wait  set区等待。警戒条件是否成立随着GuardedObject的状态而变化。<br> GuardedObject 参与者除了guardedMethod外，可能还有用来更改实例状态的的方法stateChangingMethod。</li></ul><p>在Java语言中，是使用while语句和wait方法来实现guardedMethod的；使用notify&#x2F;notifyAll方法实现stateChangingMethod。如案例中的RequestQueue 类。</p><img src="/posts/4b405cfc/39.jpg" style="zoom:67%;"><h2 id="Balking模式"><a href="#Balking模式" class="headerlink" title="Balking模式"></a>Balking模式</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><ol><li>我正坐在餐馆中，合计着吃点什么。想好之后，我举起手示意服务员点菜。于是，看到我举手的服务员就向我走来点菜。这时，另一位服务员也看到我举手示意了，但他看到已经有一位服务员走向了我，所以就没有再过来。</li><li>如果现在不适合执行这个操作，或者没必要执行这个操作，就停止处理，直接返回——这就是Balking模式。</li><li>所谓Balk，就是 “停止并返回” 的意思。</li><li>Balking 模式与Guarded Suspension模式一样，也存在守护条件。在Balking模式中，如果守护条件不成立，则立即中断处理。这与Guarded Suspension模式有所不同，因为Guarded Suspension模式是一直等待至可以运行。</li></ol><h3 id="模式详解"><a href="#模式详解" class="headerlink" title="模式详解"></a>模式详解</h3><p>角色：</p><p>GuardedObject（被防护的对象）</p><ol><li>GuardedObject角色是一个拥有被防护的方法（guardedMethod）的类。当线程执行guardedMethod方法时，若守护条件成立，则执行实际的处理。而当守护条件不成立时，则不执行实际的处理，直接返回。守护条件的成立与否，会随着GuardedObject角色的状态变化而发生变化。</li><li>除了guardedMethod之外，GuardedObject角色还有可能有其他来改变状态的方法（stateChangingMethod）。</li></ol><p>类图：</p><img src="/posts/4b405cfc/46.png" style="zoom: 67%;"><img src="/posts/4b405cfc/47.jpg" class><blockquote><p>状态仅变化一次的变量，我们通常称为闭锁（latch，门闩）。这个门闩一旦插上，就再也打不开了</p></blockquote><p>在守护条件成立之前等待一段时间，如果到时条件还未成立，则直接balk。我们将这种处理称为guarded timed 或timeout。</p><p>在java中，我们使用if来检查守护条件。balk处理的执行则是使用return从方法中退出，或者使用throw抛出异常。守护条件的检查处理则是使用synchronized放在临界区中。</p><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.FileWriter;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.Writer;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String filename;<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> changed;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Data</span><span class="hljs-params">(String filename, String content)</span> &#123;<br>        <span class="hljs-built_in">this</span>.filename = filename;<br>        <span class="hljs-built_in">this</span>.content = content;<br>        <span class="hljs-built_in">this</span>.changed = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//修改了数据内容</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">change</span><span class="hljs-params">(String newContent)</span> &#123;<br>        content = newContent;<br>        changed = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//若数据修改过，则保存到文件中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (!changed) &#123;<br>            <span class="hljs-comment">//如果没有修改，就不保存了</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        doSave();<br>        changed = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//将数据内容保存到文件中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSave</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; calls doSave, content =&quot;</span> + content);<br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filename);<br>        writer.write(content);<br>        writer.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChangerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Data data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ChangerThread</span><span class="hljs-params">(String name, Data data)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-literal">true</span>; i++) &#123;<br>                data.change(<span class="hljs-string">&quot;NO.&quot;</span> + i);<span class="hljs-comment">//修改数据</span><br>                Thread.sleep(random.nextInt(<span class="hljs-number">1000</span>));<span class="hljs-comment">//执行其他操作</span><br>                data.save();<span class="hljs-comment">//显示的保存,用户自己点击保存</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaverThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Data data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SaverThread</span><span class="hljs-params">(String name, Data data)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                data.save();<span class="hljs-comment">//要求保存数据</span><br>                Thread.sleep(<span class="hljs-number">1000</span>);<span class="hljs-comment">//休眠约一秒</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;(empty)&quot;</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChangerThread</span>(<span class="hljs-string">&quot;ChangeThread&quot;</span>, data).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">SaverThread</span>(<span class="hljs-string">&quot;SaverThread&quot;</span>, data).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="java-util-cocurrent中的超时"><a href="#java-util-cocurrent中的超时" class="headerlink" title="java.util.cocurrent中的超时"></a>java.util.cocurrent中的超时</h3><h4 id="通过异常通知超时"><a href="#通过异常通知超时" class="headerlink" title="通过异常通知超时"></a>通过异常通知超时</h4><p>当发生超时抛出异常时，返回值并不适合用于表示超时，需要使用java.util.concurrent.TimeoutException异常。</p><ul><li><strong>java.util.concurrent.Future接口的get方法</strong></li><li><strong>java.util.concurrent.Exchanger类的exchange方法</strong></li><li><strong>java.util.concurrent.Cyclicarrier类的await方法</strong></li><li><strong>java.util.concurrent.CountDownLatch类的await方法</strong></li></ul><h4 id="通过返回值通知超时"><a href="#通过返回值通知超时" class="headerlink" title="通过返回值通知超时"></a>通过返回值通知超时</h4><p>当执行多次try时，则不使用异常，而是使用返回值来表示超时。</p><ul><li><p><strong>java.util.concurrent.BlockingQueue接口</strong></p><p>当offer方法的返回值为false，或poll方法的返回值为null时，表示发生了超时。</p></li><li><p><strong>java.util.concurrent.Semaphore类</strong></p><p>当tryAcquire方法的返回值为false时，表示发生了超时。</p></li><li><p><strong>java.util.concurrent.locks.lock接口</strong></p><p>当tryLock方法的返回值为false时，表示发生了超时。</p></li></ul><h2 id="Producer-Consumer模式"><a href="#Producer-Consumer模式" class="headerlink" title="Producer-Consumer模式"></a>Producer-Consumer模式</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>Producer-Consumer Pattern就是生产者-消费者模式。<br>生产者和消费者在为不同的处理线程，生产者必须将数据安全地交给消费者，消费者进行消费时，如果生产者还没有建立数据，则消费者需要等待。<br>一般来说，可能存在多个生产者和消费者，不过也有可能生产者和消费者都只有一个，当双方都只有一个时，我们也称之为Pipe模式。</p><h3 id="模式讲解-1"><a href="#模式讲解-1" class="headerlink" title="模式讲解"></a>模式讲解</h3><p>Producer-Consumer模式的角色如下：</p><ul><li>Data(数据)参与者<br>Data代表了实际生产或消费的数据。</li><li>Producer(生产者)参与者<br>Producer会创建Data，然后传递给Channel参与者。</li><li>Consumer(消费者)参与者<br>Consumer从Channel参与者获取Data数据，进行处理。</li><li>Channel(通道)参与者<br>Channel从Producer参与者处接受Data参与者，并保管起来，并应Consumer参与者的要求，将Data参与者传送出去。为确保安全性，Producer参与者与Consumer参与者要对访问共享互斥。</li></ul><img src="/posts/4b405cfc/48.jpg" class><blockquote><p>在Swing（JFC）框架中，事件处理部分使用的就是这种方法（多个Producer角色对应一个Comsumer角色）。执行Swing事件处理的线程称为事件分发线程。这个线程相当于从Channel角色的事件队列取出事件并进行处理的Comsumer角色。事件分发线程只有一个。</p></blockquote><h3 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">concurrent</span>.<span class="hljs-property">ArrayBlockingQueue</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用 queue</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueueTable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">ArrayBlockingQueue</span>&lt;<span class="hljs-title class_">String</span>&gt; &#123;<br><br>    public <span class="hljs-title class_">BlockingQueueTable</span>(int size) &#123;<br>        <span class="hljs-variable language_">super</span>(size);<br>    &#125;<br><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span>(final <span class="hljs-title class_">String</span> cakeName) throws <span class="hljs-title class_">InterruptedException</span> &#123;<br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">put</span>(cakeName);<br>    &#125;<br><br>    public <span class="hljs-title class_">String</span> <span class="hljs-title function_">take</span>() throws <span class="hljs-title class_">InterruptedException</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">take</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> BlockingQueueTable 可以被这个替换</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Table</span> &#123;<br><br>    private <span class="hljs-title class_">String</span>[] cakeArray;<br><br>    private int head;<br><br>    private int tail;<br><br>    private int count;<br><br>    private final int size;<br><br>    public <span class="hljs-title class_">Table</span>(int size) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">size</span> = size;<br>        cakeArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[size];<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">head</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tail</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    public synchronized <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span>(final <span class="hljs-title class_">String</span> cakeName) throws <span class="hljs-title class_">InterruptedException</span> &#123;<br>        <span class="hljs-keyword">while</span> (count &gt;= size) &#123;<br>            <span class="hljs-title function_">wait</span>();<br>        &#125;<br><br>        cakeArray[tail] = cakeName;<br>        count++;<br>        tail = (tail + <span class="hljs-number">1</span>) % size;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">getName</span>() + <span class="hljs-string">&quot; put cake &quot;</span> + cakeName);<br><br>        <span class="hljs-title function_">notifyAll</span>();<br>    &#125;<br><br>    public synchronized <span class="hljs-title class_">String</span> <span class="hljs-title function_">take</span>() throws <span class="hljs-title class_">InterruptedException</span> &#123;<br>        <span class="hljs-keyword">while</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-title function_">wait</span>();<br>        &#125;<br><br>        <span class="hljs-title class_">String</span> result = cakeArray[head];<br>        head = (head + <span class="hljs-number">1</span>) % size;<br>        count--;<br><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">currentThread</span>().<span class="hljs-title function_">getName</span>() + <span class="hljs-string">&quot; take cake &quot;</span> + result);<br>        <span class="hljs-title function_">notifyAll</span>();<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Random</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerCakeThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Thread</span> &#123;<br><br>    private <span class="hljs-title class_">String</span> name;<br><br>    private final <span class="hljs-title class_">Table</span> table;<br><br>    public <span class="hljs-title class_">ConsumerCakeThread</span>(<span class="hljs-title class_">String</span> name, <span class="hljs-title class_">Table</span> table) &#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = table;<br>    &#125;<br><br>    @<span class="hljs-title class_">Override</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Random</span> random = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(1000L);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(random.<span class="hljs-title function_">nextInt</span>(<span class="hljs-number">1000</span>));<br>                table.<span class="hljs-title function_">take</span>();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Random</span>;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProducerCakeThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Thread</span> &#123;<br><br>    private final <span class="hljs-title class_">Table</span> table;<br><br>    private <span class="hljs-keyword">static</span> int id = <span class="hljs-number">0</span>;<br><br>    public <span class="hljs-title class_">ProducerCakeThread</span>(<span class="hljs-title class_">String</span> name, <span class="hljs-title class_">Table</span> table) &#123;<br>        <span class="hljs-variable language_">super</span>(name);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">table</span> = table;<br>    &#125;<br><br>    @<span class="hljs-title class_">Override</span><br>    public <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">Random</span> random = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(1000L);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-title class_">String</span> cakeName = <span class="hljs-title function_">getName</span>() + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-title function_">genId</span>();<br>                <span class="hljs-title class_">Thread</span>.<span class="hljs-title function_">sleep</span>(random.<span class="hljs-title function_">nextInt</span>(<span class="hljs-number">1000</span>));<br>                table.<span class="hljs-title function_">put</span>(cakeName);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) &#123;<br>            e.<span class="hljs-title function_">printStackTrace</span>();<br>        &#125;<br>    &#125;<br><br>    private <span class="hljs-keyword">static</span> synchronized int <span class="hljs-title function_">genId</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> id++;<br>    &#125;<br>&#125;<br><br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">Table</span> table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Table</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsumerCakeThread</span>(<span class="hljs-string">&quot;ConsumerCake&quot;</span>, table).<span class="hljs-title function_">start</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProducerCakeThread</span>(<span class="hljs-string">&quot;ProducerCake&quot;</span>, table).<span class="hljs-title function_">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Read-Write-Lock模式"><a href="#Read-Write-Lock模式" class="headerlink" title="Read-Write Lock模式"></a>Read-Write Lock模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>Read-Write Lock Pattern将读取与写入分开处理，在读取数据之前必须获取用来读取的锁定，而写入的时候必须获取用来写入的锁定。因为读取时实例的状态不会改变，所以多个线程可以同时读取；但是，写入会改变实例的状态，所以当有一个线程写入的时候，其它线程既不能读取与不能写入。</p><h3 id="模式详解-1"><a href="#模式详解-1" class="headerlink" title="模式详解"></a>模式详解</h3><p>Read-Write Lock模式的角色如下：</p><ul><li><strong>Reader(读取者)参与者</strong><br>Reader参与者会对SharedResource进行读。</li><li><strong>Writer(写入者)参与者</strong><br>Writer参与者会对SharedResource进行写。</li><li><strong>SharedResource(共享资源)参与者</strong><br>SharedResource代表Reader和Writer所共享的资源对象，SharedResource提供不改变内部状态的read操作，以及会改变内部状态的write操作。</li><li><strong>ReadWriteLock(读写锁)参与者</strong><br>ReadWriteLock提供了对SharedResource参与者进行read操作和write操作时需要的锁定。</li></ul><img src="/posts/4b405cfc/49.jpg" class><img src="/posts/4b405cfc/50.jpg" class><p>总结<br>SharedResource角色提供了read和write两个操作。read不会改变其状态，而write会，当Reader角色在read时，Writer角色必须等，而当Writer角色正在write时，Reader角色和其他Writer角色也必须等待。于是引入了ReadWriteLock角色，该角色提供分别用于read和write的锁，来执行上述的互斥处理，这样，确保了SharedResource角色的安全性，当read操作特别繁重时，程序性能能大大提高，在实现时，必须充分考虑执行互斥处理时采用的Guarded Suspension模式的守护条件。使用finally防止忘记释放锁，这就是Read Write Lock模式。</p><h3 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span>[] buffer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">//这个其实是java.util.concurrent.locks写好的读写锁类,可以直接调用 不用自己写啦.</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> lock.readLock(); <span class="hljs-comment">// 读锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> lock.writeLock(); <span class="hljs-comment">// 写锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReadWriteLock</span> <span class="hljs-variable">readWriteLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadWriteLock</span>();<span class="hljs-comment">//我们自己实现的读写锁类</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Data</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>        <span class="hljs-built_in">this</span>.buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[size];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buffer.length; i++) &#123;<br>            buffer[i] = <span class="hljs-string">&#x27;*&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">char</span>[] read() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        readWriteLock.readLock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> doRead();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.unReadLock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        readWriteLock.writeLock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            doWrite(c);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            readWriteLock.unWriteLock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span>[] doRead() &#123;<br>        <span class="hljs-type">char</span>[] newbuf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[buffer.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; newbuf.length; i++) &#123;<br>            newbuf[i] = buffer[i];<br>        &#125;<br>        slowly();<br>        <span class="hljs-keyword">return</span> newbuf;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">slowly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWrite</span><span class="hljs-params">(<span class="hljs-type">char</span> c)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; buffer.length; i++) &#123;<br>            buffer[i] = c;<br>            slowly();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReaderThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Data data;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReaderThread</span><span class="hljs-params">(Data data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">char</span>[] read = data.read();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; reads &quot;</span> + String.valueOf(read));<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriterThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Data data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String filler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">WriterThread</span><span class="hljs-params">(Data data, String filler)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.filler = filler;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> nextchar();<br>                data.write(c);<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; write &quot;</span> + c);<br>                Thread.sleep(random.nextInt(<span class="hljs-number">3000</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> handle exception</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">char</span> <span class="hljs-title function_">nextchar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> filler.charAt(index);<br>        index++;<br>        <span class="hljs-keyword">if</span> (index &gt;= filler.length()) &#123;<br>            index = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> c;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">readingReaders</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 正在读取的线程数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">writingWriters</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 正在写入的线程数量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readLock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (writingWriters &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果有线程在执行写入,等待.</span><br>            wait();<br>        &#125;<br>        readingReaders++;  <span class="hljs-comment">// 实际在读取的线程+1</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unReadLock</span><span class="hljs-params">()</span> &#123;<br>        readingReaders--;  <span class="hljs-comment">// 实际读取线程-1</span><br>        notifyAll();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeLock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (writingWriters &gt; <span class="hljs-number">0</span> || readingReaders &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果有线程正在写入,或者在读取 等待</span><br>            wait();<br>        &#125;<br>        writingWriters++; <span class="hljs-comment">// 正在写入的线程+1</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unWriteLock</span><span class="hljs-params">()</span> &#123;<br>        writingWriters--; <span class="hljs-comment">// 正在写入的线程-1</span><br>        notifyAll();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Data</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderThread</span>(data).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderThread</span>(data).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderThread</span>(data).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderThread</span>(data).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderThread</span>(data).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderThread</span>(data).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriterThread</span>(data, <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriterThread</span>(data, <span class="hljs-string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReentrantReadWriteLock特点"><a href="#ReentrantReadWriteLock特点" class="headerlink" title="ReentrantReadWriteLock特点"></a><strong>ReentrantReadWriteLock特点</strong></h3><ul><li><p>公平性</p><p>当创建ReentrantReadWriteLock类的实例时，我们可以选择锁的获取顺序是否要设为公平的。如果创建的实例是公平的，那么等待时间久的线程可以优先获取锁。</p></li><li><p>可重入性</p><p>ReentrantReadWriteLock类的锁是可重入的。也就是说，Reader角色的线程可以获取“用于写入的锁”，Writer角色的线程也可以获取“用于读取的锁”。</p></li><li><p>锁降级</p><p>ReentrantReadwriteLock类可以按如下顺序将“用于写入的锁”降级为“用于读取的锁”。</p><ul><li><p>获取用于写入的锁</p></li><li><p>获取用于读取的锁</p></li><li><p>释放用于写入的锁</p></li></ul><p>但是，“用于读取的锁”不可以升级为“用户写入的锁”。</p></li><li><p>便携方法</p><p>ReentrantReadWriteLock类提供了获取等待中的线程的个数的方法getQueueLength，以及检查是否获取了用于写入的锁的方法isWriteLocked等便携方法。</p></li></ul><h2 id="Thread-per-Message模式"><a href="#Thread-per-Message模式" class="headerlink" title="Thread-per-Message模式"></a>Thread-per-Message模式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>Thread-Per-Message模式是说为每个请求都分配一个线程，由这个线程来执行处理，使得消息能够并发（但是注意：线程的创建是有限的，可以使用线程池来处理，超过数量则加入等待队列），这里包含两个角色，请求的提交线程和请求的执行线程。</p><h3 id="模式详解-2"><a href="#模式详解-2" class="headerlink" title="模式详解"></a>模式详解</h3><ul><li>Client（委托人）<br>Client角色会向Host角色发出请求（request），但是并不知道Host角色是如何实现该请求的。</li><li>Host<br>Host角色收到Client角色的请求（request）之后，会新创建并启动一个线程。新创建的线程将使用Helper角色来 “处理”（handle）请求。</li><li>Helper（助手）<br>Helper角色为Host角色提供请求处理的功能。Host角色创建的新线程会利用Helper角色。</li></ul><img src="/posts/4b405cfc/53.png"><img src="/posts/4b405cfc/54.jpg" style="zoom: 80%;"><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><strong>提高响应性，缩短延迟时间</strong><br>Thread-Per-Message模式能够提高与Client角色对应的Host角色的响应性，降低延迟时间。尤其是当handle操作非常耗时，或者handle操作需要等待输入&#x2F;输出时，效果非常明显。<br>在Thread-Per-Message模式下，Host角色会启动新的线程。由于启动线程也会花费时间，所以想要提高响应性时，是否使用Thread-Per-Message模式取决于 “handle操作花费的时间” 和 “线程启动花费的时间” 之间的均衡。</li><li><strong>适用于操作顺序没有要求时</strong><br>在Thread-Per-Message模式中，handle方法并不一定是按request方法的调用顺序来执行的。因此，当操作要按某种顺序执行时，Thread-Per-Message模式并不适用。</li><li><strong>适用于不需要返回值时</strong><br>在Thread-Per-Message模式中，request方法并不会等待handle方法执行结束。所以request得不到handle的运行结果。因此，Thread-Per-Message模式适用于不需要获取返回值的情况。例如通知某个事件时。</li><li><strong>应用于服务器</strong><br>为了使服务器可以处理多个请求，我们可以使用Thread-Per-Message模式。服务器本身的线程接收客户端的请求，而这些请求的实际处理则交由其他线程来执行，服务器本身的线程则返回，去等待客户端的其他请求。</li></ol><h3 id="Factory-Method模式"><a href="#Factory-Method模式" class="headerlink" title="Factory Method模式"></a><strong>Factory Method模式</strong></h3><p>使用new创建Thread实例时，代码依赖于java.lang.Thread类。这时，我们无法控制创建线程的部分，可复用性较低。假如我们用字段threadFactory来保存ThreadFactory对象，用threadFactory.newThread(…)来替代new Thread(…)。这样一来，只要替换赋给threadFactory的ThreadFactory对象，我们便可以控制线程创建了。这就是Factory Method模式。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Helper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">char</span> c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;handle begin&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            slowly();<br>            System.out.print(c);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;handle end&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">slowly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Host</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Helper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Helper</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory threadFactory;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Host</span><span class="hljs-params">()</span> &#123;<br>        threadFactory = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Host</span><span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>        <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> count, <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;request begin [&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;] begin&quot;</span>);<br>        threadFactory.newThread(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                helper.handle(count, c);<br>            &#125;<br>        &#125;).start();<br>        System.out.println(<span class="hljs-string">&quot;request begin [&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;] end&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main begin&quot;</span>);<br><br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Host</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Host</span>(threadFactory);<br>        host.request(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>        host.request(<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<br>        host.request(<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&quot;main End&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="java-util-concurrent-Executor接口"><a href="#java-util-concurrent-Executor接口" class="headerlink" title="java.util.concurrent.Executor接口"></a><strong>java.util.concurrent.Executor接口</strong></h3><p>Executor接口将某些“处理的执行”抽象化了，参数传入的Runnable对象表示“执行的处理”的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Helper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">char</span> c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;handle begin&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            slowly();<br>            System.out.print(c);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;handle end&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">slowly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Host</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Helper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Helper</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor executor;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Host</span><span class="hljs-params">(Executor executor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.executor = executor;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> count, <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;request begin [&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;] begin&quot;</span>);<br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                helper.handle(count, c);<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;request begin [&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;] end&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main begin&quot;</span>);<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Executor</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> &#123;<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r).start();<br>            &#125;<br>        &#125;;<br>        <span class="hljs-type">Host</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Host</span>(executor);<br>        host.request(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>        host.request(<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<br>        host.request(<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>        System.out.println(<span class="hljs-string">&quot;main End&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="java-util-concurrent-ExecutorService接口"><a href="#java-util-concurrent-ExecutorService接口" class="headerlink" title="java.util.concurrent.ExecutorService接口"></a><strong>java.util.concurrent.ExecutorService接口</strong></h4><p>ExecutorService接口对可以反复execute的服务进行了抽象化。线程一直在后台运行着，每当调用execute方式时，在ExecutorService接口后面，线程是一直在运行着，所以ExecutorService接口<strong>提供了shutdown方法</strong>来结束服务。</p><p><strong>示例代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main begin&quot;</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>        <span class="hljs-type">Host</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Host</span>(executorService);<br>        <span class="hljs-keyword">try</span> &#123;<br>            host.request(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>            host.request(<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<br>            host.request(<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            executorService.shutdown();<br>            System.out.println(<span class="hljs-string">&quot;main End&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>java.util.concurrent.ScheduledExecutorService类</strong></p><p>java.util.concurrent.ScheduledExecutorService接口是ExecutorService的子接口，用于推迟操作的执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Helper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">char</span> c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;handle begin&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            slowly();<br>            System.out.print(c);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;handle end&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">slowly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-comment">// TODO Auto-generated catch block</span><br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Host</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Helper</span> <span class="hljs-variable">helper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Helper</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService scheduledExecutorService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Host</span><span class="hljs-params">(ScheduledExecutorService scheduledExecutorService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.scheduledExecutorService = scheduledExecutorService;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> count, <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;request begin [&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;] begin&quot;</span>);<br>        scheduledExecutorService.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                helper.handle(count, c);<br>            &#125;<br>        &#125;, <span class="hljs-number">3L</span>, TimeUnit.SECONDS);<br>        System.out.println(<span class="hljs-string">&quot;request begin [&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;] end&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main begin&quot;</span>);<br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduledExecutorService</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Host</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Host</span>(scheduledExecutorService);<br>        <span class="hljs-keyword">try</span> &#123;<br>            host.request(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>            host.request(<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<br>            host.request(<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            scheduledExecutorService.shutdown();<br>            System.out.println(<span class="hljs-string">&quot;main End&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/4b405cfc/55.png" style="zoom: 50%;"><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Client 角色调用Host角色的request方法发来的请求，该请求的实际处理则交给Helper的handle去执行，然而，如果Client直接从request中调用handle方法，那么直到实际操作结束之前，都无法从handle方法返回（request返回），这样一来request的响应性能就下降了，因此，Host角色会启动用于处理来自Client角色请求的新线程，并让该线程来调用handle，这样一来发出请求的线程便可以立即从handle中返回。这就是Thread-Per-Message模式。</p><h2 id="Worker-Thread模式"><a href="#Worker-Thread模式" class="headerlink" title="Worker Thread模式"></a>Worker Thread模式</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>Worker的意思是工作的人、劳动者。在Worker Thread模式中，工人线程会逐个取回工作并进行处理。当所有工作全部完成后，工人线程会等待新的工作到来。</p><p>Worker Thread模式也被称为Background Thread（背景线程）模式。另外，如果从“保存多个工人线程的场所”这一点来看，我们也可以称这种模式为Thread Pool（线程池）模式。</p><h3 id="模式详解-3"><a href="#模式详解-3" class="headerlink" title="模式详解"></a>模式详解</h3><img src="/posts/4b405cfc/57.png" style="zoom:50%;"><img src="/posts/4b405cfc/56.png" style="zoom: 50%;"><img src="/posts/4b405cfc/58.png" style="zoom:50%;"><p><strong>角色</strong></p><ul><li><p>Client（委托者）</p><p>Client角色创建表示工作请求的Request角色并将其传递给Channel角色。在示例程序中，由ClientThread类扮演此角色。</p></li><li><p>Channel（通信线路）</p><p>Channel角色接受来自于Client角色的Request角色，并将其传递给Worker角色。在示例程序中，由Channel类扮演此角色。</p></li><li><p>Worker（工人）</p><p>Worker角色从Channel角色中获取Request角色，并进行工作。当一项工作完成后，它会继续去获取另外的Channel角色。在示例程序中，由WorkerThread类扮演此角色。</p></li><li><p>Request（请求）</p><p>Request角色是表示工作的角色。Request角色中保存了进行工作所必需的信息。在示例程序中，由Request角色扮演此角色。</p></li></ul><img src="/posts/4b405cfc/59.png" style="zoom:50%;"><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li><p><strong>提高响应速度</strong></p><p>调用和执行分离。执行完调用处理的一方可以先继续执行其他处理，这样就可以提高响应速度。</p></li><li><p><strong>控制执行顺序（调度）</strong></p><p>如果调用和执行不可分离，那么在调用后就必须开始执行。</p><p>但是如果将调用和执行分离，执行就可以不再受调用调用顺序的制约。我们可以通过<strong>设置Request角色的优先级，并控制Channel角色将Request角色传递给Worker角色的顺序来实现上述处理。这种处理称为请求调度（scheduling）</strong>。</p></li><li><p><strong>可以取消和反复执行</strong></p><p>将调用和执行分离后，还可以实现“即使调用了也可以被取消执行”这种功能。</p><p>由于调用的是Request对象，所以既可以将Request角色保存，又可以反复的执行。</p></li><li><p><strong>通往分布式之路</strong></p><p>将调用和执行分离后，可以将负责调用的计算机与负责执行的计算机分离开来，然后通过网络将扮演Request角色的对象从一台计算机传递至另外一台计算机。</p></li></ul><h2 id="Future模式"><a href="#Future模式" class="headerlink" title="Future模式"></a>Future模式</h2><h3 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h3><p>Future模式是多线程开发中非常常见的一种设计模式。它的核心思想是异步调用。当我们需要调用一个函数方法时。如果这个函数执行很慢,那么我们就要进行等待。但有时候,我们可能并不急着要结果。因此,我们可以让被调用者立即返回,让他在后台慢慢处理这个请求。对于调用者来说,则可以先处理一些其他任务,在真正需要数据的场合再去尝试获取需要的数据。</p><blockquote><p>由于Future角色是”只能被赋值一次的变量“，所以可以把它看作一种闭锁（latch）。</p></blockquote><h3 id="模式详解-4"><a href="#模式详解-4" class="headerlink" title="模式详解"></a>模式详解</h3><table><thead><tr><th>名字</th><th>说明</th></tr></thead><tbody><tr><td>Main</td><td>向Host发出请求并获取数据的类</td></tr><tr><td>Host</td><td>向请求返回FutureData的实例的类</td></tr><tr><td>Data</td><td>表示访问数据的方法的接口。由FutureData和RealData实现该接口</td></tr><tr><td>FutureData</td><td>表示RealData的“提货单”的类。其他线程会创建RealData的实例。</td></tr><tr><td>RealData</td><td>表示实际数据的类。构造函数的处理会花费很长时间</td></tr></tbody></table><p><strong>类图</strong></p><img src="/posts/4b405cfc/60.png" style="zoom:50%;"><p><strong>时序图</strong></p><img src="/posts/4b405cfc/61.png" style="zoom:50%;"><p><strong>角色</strong></p><ul><li><p>Client（请求者）</p><p>Client角色向Host角色发出，并会立即接收到请求的处理结果——VirtualData角色。</p></li><li><p>Host</p><p>Host角色会创建新的线程，并开始在新线程中创建RealData角色。同时，它会将Future角色（当做VirtualData角色）返回给Client角色。</p></li><li><p>VirtualData</p><p>VirtualData角色是让Future角色和RealData角色具有一致性的角色。</p></li><li><p>RealData</p><p>RealData角色是表示真实数据的角色。</p></li><li><p>Future</p><p>Future角色是RealData角色的”提货单“，由Host角色传递给Client角色。</p></li></ul><h3 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span> &#123;<br>    String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">RealData</span> <span class="hljs-variable">realData</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRealData</span><span class="hljs-params">(RealData realData)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ready) &#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// balk</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;setting content = &quot;</span>+ realData.getContent());<br>        <span class="hljs-built_in">this</span>.realData = realData;<br>        <span class="hljs-built_in">this</span>.ready = <span class="hljs-literal">true</span>;<br>        notifyAll();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!ready) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> realData.getContent();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String content;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RealData</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">char</span> c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;    making RealData(&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;) BEGIN&quot;</span>);<br>        <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[count];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            buffer[i] = c;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;    making RealData(&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;) END&quot;</span>);<br>        <span class="hljs-built_in">this</span>.content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Host</span> &#123;<br>    <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">request</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> count, <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;    request(&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;) BEGIN&quot;</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">FutureData</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureData</span>();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">RealData</span> <span class="hljs-variable">realData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealData</span>(count, c);<br>                future.setRealData(realData);<br>            &#125;<br>        &#125;).start();<br><br>        System.out.println(<span class="hljs-string">&quot;    request(&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;) END&quot;</span>);<br>        <span class="hljs-keyword">return</span> future;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main BEGIN&quot;</span>);<br>        <span class="hljs-type">Host</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Host</span>();<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">data1</span> <span class="hljs-operator">=</span> host.request(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">data2</span> <span class="hljs-operator">=</span> host.request(<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<br>        <span class="hljs-type">Data</span> <span class="hljs-variable">data3</span> <span class="hljs-operator">=</span> host.request(<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;main otherJob BEGIN&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;main otherJob END&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;data1 = &quot;</span> + data1.getContent());<br>        System.out.println(<span class="hljs-string">&quot;data2 = &quot;</span> + data2.getContent());<br>        System.out.println(<span class="hljs-string">&quot;data3 = &quot;</span> + data3.getContent());<br>        System.out.println(<span class="hljs-string">&quot;main END&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="java-util-concurrent-示例程序"><a href="#java-util-concurrent-示例程序" class="headerlink" title="java.util.concurrent 示例程序"></a>java.util.concurrent 示例程序</h3><p><strong>Callable、Future、FutureTask的类图</strong></p><img src="/posts/4b405cfc/62.png" style="zoom: 67%;"><p><strong>示例程序时序图</strong></p><img src="/posts/4b405cfc/63.png" alt="image-20200705214631291" style="zoom: 50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Data</span> &#123;<br>    String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureData</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FutureTask</span>&lt;RealData&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureData</span><span class="hljs-params">(Callable&lt;RealData&gt; callable)</span> &#123;<br>        <span class="hljs-built_in">super</span>(callable);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            get().getContent();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> string;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Data</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String content;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RealData</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">char</span> c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;    making RealData(&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;) BEGIN&quot;</span>);<br>        <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[count];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            buffer[i] = c;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;    making RealData(&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;) END&quot;</span>);<br>        <span class="hljs-built_in">this</span>.content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getContent</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Host</span> &#123;<br>    <span class="hljs-keyword">public</span> FutureData <span class="hljs-title function_">request</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> count, <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> c)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;    request(&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;) BEGIN&quot;</span>);<br><br>        <span class="hljs-type">FutureData</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureData</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;RealData&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> RealData <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealData</span>(count, c);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 启动一个新线程，用于创建RealData的实例。</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(future).start();<br><br>        System.out.println(<span class="hljs-string">&quot;    request(&quot;</span> + count + <span class="hljs-string">&quot;, &quot;</span> + c + <span class="hljs-string">&quot;) END&quot;</span>);<br>        <span class="hljs-keyword">return</span> future;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main BEGIN&quot;</span>);<br>        <span class="hljs-type">Host</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Host</span>();<br>        <span class="hljs-type">FutureData</span> <span class="hljs-variable">data1</span> <span class="hljs-operator">=</span> host.request(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;A&#x27;</span>);<br>        <span class="hljs-type">FutureData</span> <span class="hljs-variable">data2</span> <span class="hljs-operator">=</span> host.request(<span class="hljs-number">20</span>, <span class="hljs-string">&#x27;B&#x27;</span>);<br>        <span class="hljs-type">FutureData</span> <span class="hljs-variable">data3</span> <span class="hljs-operator">=</span> host.request(<span class="hljs-number">30</span>, <span class="hljs-string">&#x27;C&#x27;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;main otherJob BEGIN&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;main otherJob END&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;data1 = &quot;</span> + data1.get().getContent());<br>            System.out.println(<span class="hljs-string">&quot;data2 = &quot;</span> + data2.get().getContent());<br>            System.out.println(<span class="hljs-string">&quot;data3 = &quot;</span> + data3.get().getContent());<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;main END&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Two-Phase-Termination模式"><a href="#Two-Phase-Termination模式" class="headerlink" title="Two-Phase Termination模式"></a>Two-Phase Termination模式</h2><h3 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h3><p>该模式的名字直译是“分两阶段终止”的意思，它是一种先执行完终止处理再终止线程的模式。</p><img src="/posts/4b405cfc/64.jpg" class><p>我们称线程在进行正常处理时的状态为“操作中”，在要停止该线程时，会发出“终止请求”，这样，线程不会突然终止，而是会先开始进行“打扫工作”，称为“终止处理中”，是线程终止的第一阶段。</p><p>在“终止处理中”状态下，线程不会在进行正常操作，它虽然仍在运行，但是只会进行终止处理，终止处理完成后，就会真正地终止线程，是线程终止的第二阶段。</p><p>该模式的要点如下。</p><ul><li>安全的终止线程。</li><li>必定会进行终止处理。</li><li>发出终止请求后尽快进行终止处理。</li></ul><h3 id="模式详解-5"><a href="#模式详解-5" class="headerlink" title="模式详解"></a>模式详解</h3><ul><li><p>TerminationRequester（终止请求发出者）<br>TerminationRequester角色负责向Terminator角色发出终止请求，是示例程序中的Main类。</p></li><li><p>Terminator（终止者）<br>Terminator负责接收终止请求，并实际执行终止处理，提供了表示终止请求的shutdownRequest方法。</p><p>当shutdownRequest方法被调用后，Terminator角色会在考虑了安全性的基础上，进入“终止处理中”状态，接着，当终止处理结束后，Terminator角色就会终止自己。</p></li></ul><p>Two-Phase Termination模式的类图</p><img src="/posts/4b405cfc/67.jpg" style="zoom:150%;"><blockquote><p><strong>NIO与多线程</strong></p><p>java.nio.channels.Channel接口以及实现了该接口的类群的设计中考虑了多线程的问题。</p><p>例如，当一个线程在Channel上发生I&#x2F;O阻塞的时候，其他线程可以close该Channel。这时，发生I&#x2F;O阻塞的线程会接收到AsynchronousCloseException异常。</p><p>另外，当一个线程在Channel上发生I&#x2F;O阻塞的时候，其他线程还可以interrupt该线程。这时，发生I&#x2F;O阻塞的线程会接收到ClosedByInterruptException异常。</p></blockquote><h3 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h3><p><strong>类图</strong></p><img src="/posts/4b405cfc/65.png" style="zoom: 50%;"><p><strong>时序图</strong></p><img src="/posts/4b405cfc/66.png" alt="image-20200705220252139" style="zoom: 50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountupThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * counter字段表示当前的计数器</span><br><span class="hljs-comment">     * shutdownRequested字段是表示是否已经发出终止请求的标志，该字段的值用于判断线程是否进入“终止处理中”状态</span><br><span class="hljs-comment">     * shutdownRequest方法是表示线程终止请求的方法，当要终止CountupThread的线程时，程序会调用该方法</span><br><span class="hljs-comment">     * 注意，shutdownRequest还调用了interrupt方法，这是为了确保程序在sleep和wait时也会被终止</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//计数值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">//发出终止请求后变为ture</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">shutdownRequested</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">//终止请求</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdownRequest</span><span class="hljs-params">()</span> &#123;<br>        shutdownRequested = <span class="hljs-literal">true</span>;<br>        interrupt();<br>    &#125;<br><br>    <span class="hljs-comment">//检查是否发出了终止请求</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShutdownRequested</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> shutdownRequested;<br>    &#125;<br><br>    <span class="hljs-comment">//线程体</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (!isShutdownRequested()) &#123;<br>                doWork();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            doShutdown();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//操作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        counter++;<br>        System.out.println(<span class="hljs-string">&quot;doWork: counter = &quot;</span> + counter);<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//终止处理</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doShutdown</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;doShutdown: counter = &quot;</span> + counter);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动CountupThread的线程，大约10s后终止该线程</span><br><span class="hljs-comment">     * Thread类的join方法是用户等待线程终止的方法，在指定的线程终止前，join方法不会返回。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main: Begin&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//启动线程</span><br>            <span class="hljs-type">CountupThread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountupThread</span>();<br>            t.start();<br><br>            <span class="hljs-comment">//稍微间隔一段时间</span><br>            Thread.sleep(<span class="hljs-number">10000</span>);<br><br>            <span class="hljs-comment">//线程的终止请求</span><br>            System.out.println(<span class="hljs-string">&quot;main: shutdownRequest&quot;</span>);<br>            t.shutdownRequest();<br><br>            System.out.println(<span class="hljs-string">&quot;main: join&quot;</span>);<br><br>            <span class="hljs-comment">//等待线程终止</span><br>            t.join();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;main: End&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>java.util.concurrent.ExecutorService接口与Two-phase Termination模式</strong></p><p>ExecutorService使用了Two-phase Termination模式</p><table><thead><tr><th></th><th>isShutdown方法</th><th>isTerminated方法</th></tr></thead><tbody><tr><td>【操作中】</td><td>false</td><td>false</td></tr><tr><td>【终止处理中】</td><td>true</td><td>false</td></tr><tr><td>【终止】</td><td>true</td><td>true</td></tr></tbody></table><h3 id="捕获程序整体的终止"><a href="#捕获程序整体的终止" class="headerlink" title="捕获程序整体的终止"></a>捕获程序整体的终止</h3><h4 id="退出钩子"><a href="#退出钩子" class="headerlink" title="退出钩子"></a>退出钩子</h4><p>退出钩子是指在Java虚拟机退出时启动的线程。”java虚拟机退出时“指的是System.exit()被调用或是全部非守护线程终止时。这时，我们可以使用退出钩子来编写程序完全终止时的终止处理。</p><p>示例程序执行了以下处理：</p><ul><li>设置未捕获的异常的处理器</li><li>设置退出钩子</li><li>大约3秒后启动执行”整数除零计算“的线程</li></ul><p>执行整数除零计算后，程序会抛出java.lang.ArithmeticException异常。由于在示例程序中我们并没有捕获ArithmeticExeception，所以程序会终止。在终止前，”为捕获的异常的处理器“和”退出钩子“会被依次调用。</p><h4 id="未捕获的异常的处理器"><a href="#未捕获的异常的处理器" class="headerlink" title="未捕获的异常的处理器"></a>未捕获的异常的处理器</h4><h4 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main:BEGIN&quot;</span>);<br><br>        <span class="hljs-comment">// 设置未捕获的异常的处理器</span><br>        Thread.setDefaultUncaughtExceptionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;\n***********&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;UncaughtExceptionHandler:BEGIN&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;currentThread = &quot;</span> + Thread.currentThread());<br>                System.out.println(<span class="hljs-string">&quot;thread = &quot;</span> + t);<br>                System.out.println(<span class="hljs-string">&quot;exception = &quot;</span> + e);<br>                System.out.println(<span class="hljs-string">&quot;UncaughtExceptionHandler:END&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 设置退出钩子</span><br>        Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><br>                System.out.println(<span class="hljs-string">&quot;\n*************&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;shutdown hook:BEGIN&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;currentThread = &quot;</span> + Thread.currentThread());<br>                System.out.println(<span class="hljs-string">&quot;shutdown hook:END&quot;</span>);<br>            &#125;<br>        &#125;));<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;MyThread:BEGIN&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;MyThread:SLEEP...&quot;</span>);<br><br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">3000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br><br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / <span class="hljs-number">0</span>;<br><br>            <span class="hljs-comment">//    不会来到这里</span><br>                System.out.println(<span class="hljs-string">&quot;MyThread:END&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;MyThread&quot;</span>).start();<br><br>        System.out.println(<span class="hljs-string">&quot;main:END&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li><p><strong>Multiphase Cancellation 模式</strong></p><p>使用Multiphase Cancellation模式停止线程时，如果在一定时间内线程没有停止，那么程序会逐渐发出更加强硬的终止请求。</p></li><li><p><strong>Multi-Phase StartUp 模式</strong></p><p>使用Two-Phase Termination模式时，在接收到终止请求后，程序并不立即终止线程，而是先进入”终止处理中“阶段，然后安全的终止线程。</p><p>而使用Multi-Phase StartUp模式时，如果存在多个子系统，则程序会经过多个阶段启动全部系统。在该模式下，系统会定义一个整数值的运行级锁，用来表示当前哪个运行级别正处于启动中状态。</p><p>Java的Applet也使用了该模式，不过它将Multi-Phase StartUp模式缩减至了三步（即创建实例 → 调用init方法 → 调用start方法）。</p></li></ul></blockquote><h3 id="java-util-concurrent-CountDownLatch类"><a href="#java-util-concurrent-CountDownLatch类" class="headerlink" title="java.util.concurrent.CountDownLatch类"></a>java.util.concurrent.CountDownLatch类</h3><p>当我们想让某个线程等待指定的线程终止时，可以使用java.lang.Thread类的join方法。但是，由于join方法可以等待的只是”线程终止“这个一次性的操作，所以我们无法使用它实现”等待指定次数的某种操作发生“。</p><p>使用java.util.concurrent.CountDownLatch类可以实现”等待指定次数的CountDown方法被调用“这一功能。</p><h4 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h4><ul><li>准备一个进行工作的ExecutorService对象（service）</li><li>创建一个CountDownLatch类的实例（doneLatch）。在创建时将初始值TASKS传入CountDownLatch类的构造函数</li><li>调用execute方法执行（在内部启动线程）TASKS 个 MyTask</li><li><strong>调用await方法</strong>等待doneLatch的计数值变为0</li><li><strong>调用shutdown方法终止service</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneLatch;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> context;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">321234</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(CountDownLatch doneLatch, <span class="hljs-type">int</span> context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.doneLatch = doneLatch;<br>        <span class="hljs-built_in">this</span>.context = context;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        doTask();<br>        doneLatch.countDown();<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doTask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        System.out.println(name + <span class="hljs-string">&quot;:MyTask:BEGIN:context = &quot;</span> + context);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(random.nextInt(<span class="hljs-number">3000</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(name + <span class="hljs-string">&quot;:MyTask:END:context = &quot;</span> + context);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TASKS</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 工作的个数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">doneLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(TASKS);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 开始工作</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; TASKS; i++) &#123;<br>                service.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(doneLatch, i));<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;AWAIT&quot;</span>);<br>            <span class="hljs-comment">// 等待工作结束</span><br>            doneLatch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            service.shutdown();<br>            System.out.println(<span class="hljs-string">&quot;END&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a><strong>时序图</strong></h4><img src="/posts/4b405cfc/68.png" style="zoom:50%;"><h3 id="java-util-concurrent-CyclicBarrier类"><a href="#java-util-concurrent-CyclicBarrier类" class="headerlink" title="java.util.concurrent.CyclicBarrier类"></a>java.util.concurrent.CyclicBarrier类</h3><p>CyclicBarrier可以周期性的创建出屏障。在屏障解除之前，碰到屏障的线程是无法继续前进的。屏障的解除条件是到达屏障处的线程个数达到了构造函数指定的个数。也就是说，当指定个数的线程到达屏障处后，屏障就会被解除，然后这些线程就会像听到了”预备，走“一样一起冲出去。</p><p><strong>在创建CyclicBarrier的实例时，可以指定Runnable对象。这个对象被称作”屏障操作“。每次屏障被解除后，该屏障操作都会被执行。</strong></p><h4 id="示例代码-8"><a href="#示例代码-8" class="headerlink" title="示例代码"></a>示例代码</h4><ul><li>调用doPhase(phase)方法进行第phase阶段的工作</li><li>调用await方法表示自己已经完成了第phase阶段的工作</li><li>当其他所有线程都完成了”第phase阶段的工作“后，run方法从await方法中返回并进入下个阶段的工作</li><li>当所有阶段的工作都完成后，使用doneLatch向主线程发送”工作结束“的消息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PHASE</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CyclicBarrier phaseBarrier;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CountDownLatch doneLatch;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> context;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>(<span class="hljs-number">32143</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(CyclicBarrier phaseBarrier, CountDownLatch doneLatch, <span class="hljs-type">int</span> context)</span> &#123;<br>        <span class="hljs-built_in">this</span>.phaseBarrier = phaseBarrier;<br>        <span class="hljs-built_in">this</span>.doneLatch = doneLatch;<br>        <span class="hljs-built_in">this</span>.context = context;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">phase</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; phase &lt; PHASE; phase++) &#123;<br>            doPhase(phase);<br>            <span class="hljs-keyword">try</span> &#123;<br>                phaseBarrier.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                doneLatch.countDown();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPhase</span><span class="hljs-params">(<span class="hljs-type">int</span> phase)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        System.out.println(name + <span class="hljs-string">&quot;:MyTask:BEGIN:context = &quot;</span> + context + <span class="hljs-string">&quot;, phase = &quot;</span> + phase);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(random.nextInt(<span class="hljs-number">3000</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(name + <span class="hljs-string">&quot;:MyTask:END:context = &quot;</span> + context + <span class="hljs-string">&quot;, phase = &quot;</span> + phase);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREADS</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; <span class="hljs-comment">// 线程的个数</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;BEGIN&quot;</span>);<br><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(THREADS);<br><br>        <span class="hljs-comment">// 屏障被解除时的操作</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">barrierAction</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Barrier Action!&quot;</span>);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// CyclicBarrier用于使线程步骤一致</span><br>        <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">phaseBarrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(THREADS, barrierAction);<br><br>        <span class="hljs-comment">// CountDownLatch用于确认工作是否结束</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">doneLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(THREADS);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; THREADS; i++) &#123;<br>                service.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(phaseBarrier, doneLatch, i));<br>            &#125;<br><br>            <span class="hljs-comment">// 等待工作结束</span><br>            System.out.println(<span class="hljs-string">&quot;AWAIT&quot;</span>);<br>            doneLatch.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            service.shutdown();<br>            System.out.println(<span class="hljs-string">&quot;END&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="时序图-1"><a href="#时序图-1" class="headerlink" title="时序图"></a>时序图</h4><img src="/posts/4b405cfc/69.png" alt="image-20200706000509173" style="zoom:50%;"><h2 id="Thread-Specific-Storage"><a href="#Thread-Specific-Storage" class="headerlink" title="Thread-Specific Storage"></a>Thread-Specific Storage</h2><h3 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h3><p>Thread-Specific Storage就是“线程独有的存储库”，该模式会对每个线程提供独有的内存空间。<br>java.lang.ThreadLocal类提供了该模式的实现，ThreadLocal的实例是一种集合（collection）架构，该实例管理了很多对象，可以想象成一个保管有大量保险箱的房间。</p><p>java.lang.ThreadLocal类的方法：</p><ul><li><p>public void set()<br>该方法会检查当前调用线程，默认以该线程的Thread.currentThread()值作为键，来保存指定的值。</p></li><li><p>public Object get()<br>该方法会检查当前调用线程，默认以该线程的Thread.currentThread()值作为键，获取保存指定的值。</p></li></ul><p>Thread-Specific Storage模式还有以下名称。</p><ul><li>Per-Thread Attribute（线程各自的属性）</li><li>Thread-Specific Data（线程特有的数据）</li><li>Thread-Specific Field（线程特有的字段）</li><li>Thread-Local Storage（线程中的局部存储空间）</li></ul><h3 id="模式详解-6"><a href="#模式详解-6" class="headerlink" title="模式详解"></a>模式详解</h3><p>java.lang.ThreadLocal是一个泛型类，可以通过参数的类型来指定要存储的对象的类型。ThreadLocal类的声明大致如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocal</span>&lt;T&gt; &#123;<br><span class="hljs-comment">// 存储</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(T value)</span> &#123;<br>...<br>&#125;<br><br><span class="hljs-comment">// 获取</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>...<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>名字</th><th>说明</th></tr></thead><tbody><tr><td>TSLog</td><td>创建日志的类（实例属于各个线程所有）</td></tr><tr><td>Log</td><td>创建日志的类（分配各个线程）</td></tr><tr><td>java.lang.ThreadLocal</td><td>分配线程持有的存储空间的类</td></tr><tr><td>ClientThread</td><td>表示调用Log的线程的类</td></tr><tr><td>Main</td><td>测试程序行为的类</td></tr></tbody></table><p><strong>角色</strong></p><ul><li><p>Client（委托者）</p><p>Client角色将处理委托给TSObjectProxy角色。一个TSObjectProxy角色会被多个Client角色使用。</p></li><li><p>TSObjectProxy（线程特有的对象的代理人）</p><p>TSObjectProxy角色使用TSObjectCollection角色获取与Client角色对应的TSObject角色。接着，它将处理委托给TSObject角色。</p></li><li><p>TSObjectCollection（线程持有的对象的集合）</p><p>TSObjectCollection角色有一张Client角色与TSObject角色之间的对应表。</p></li><li><p>TSObject（线程特有的对象）</p><p>TSObject角色中保存着线程特有的信息。</p><p>TSObject角色有TSObjectCollection角色管理。<strong>TSObject角色的方法只会被单线程调用</strong>。</p></li></ul><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><img src="/posts/4b405cfc/72.png" alt="image-20200706205505663" style="zoom:50%;"><h3 id="时序图-2"><a href="#时序图-2" class="headerlink" title="时序图"></a>时序图</h3><p><strong>新创建TSObject角色</strong></p><img src="/posts/4b405cfc/73.png" alt="image-20200706205538651" style="zoom:50%;"><p><strong>多个client角色访问各自的TSObject角色</strong></p><img src="/posts/4b405cfc/74.png" alt="image-20200706205843433" style="zoom:50%;"><p><strong>示例程序类图</strong></p><img src="/posts/4b405cfc/70.png" alt="image-20200706202151734" style="zoom: 67%;"><p><strong>示例程序TimeThreads图</strong></p><img src="/posts/4b405cfc/71.png" alt="image-20200706204459127" style="zoom:50%;"><h3 id="示例代码-9"><a href="#示例代码-9" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TSLog</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// 初始化writer字段</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TSLog</span><span class="hljs-params">(String filename)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            writer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filename));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 写日志</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(String s)</span> &#123;<br>        writer.println(s);<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭日志</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span> <span class="hljs-params">()</span> &#123;<br>        writer.println(<span class="hljs-string">&quot;=== Enf of log ===&quot;</span>);<br>        writer.close();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Log</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;TSLog&gt; tsLogCollection = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 写日志</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">println</span><span class="hljs-params">(String s)</span> &#123;<br>        getTsLog().println(s);<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭日志</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        getTsLog().close();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取线程持有的日志</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TSLog <span class="hljs-title function_">getTsLog</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">TSLog</span> <span class="hljs-variable">tsLog</span> <span class="hljs-operator">=</span> tsLogCollection.get();<br><br>        <span class="hljs-keyword">if</span> (tsLog == <span class="hljs-literal">null</span>) &#123;<br>            tsLog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TSLog</span>(Thread.currentThread().getName() + <span class="hljs-string">&quot;-log.txt&quot;</span>);<br>            tsLogCollection.set(tsLog);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> tsLog;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClientThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ClientThread</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(getName() + <span class="hljs-string">&quot; BEGIN&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Log.println(<span class="hljs-string">&quot;i= &quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            Log.close();<br>        &#125;<br>        System.out.println(getName() + <span class="hljs-string">&quot; END&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientThread</span>(<span class="hljs-string">&quot;Alice&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientThread</span>(<span class="hljs-string">&quot;Bobby&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientThread</span>(<span class="hljs-string">&quot;Chris&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>保存线程特有信息的位置</p><p>线程特有的信息”保存位置“有以下两种：</p><ul><li><p>线程外</p><p>类似于ThreadLocal这种将线程特有的信息保存在线程外部的方法称为”线程外“。</p></li><li><p>线程内</p><p>如果在线程中声明字段，该字段就是线程特有的信息。这就是在线程内保存线程特有的信息。</p></li></ul></blockquote><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>与强调吞吐量相比，Thread-Specific Storage模式更看重如下所示的可复用性。</p><ol><li>不改变结构即可实现程序</li><li>没有显式地执行互斥处理，所以编程时犯错的可能性较小</li></ol><blockquote><p><strong>Thread-Specific Storage与Worker Thread模式不能结合使用。</strong></p><p>如果不能确保所有的任务都由不同的线程执行，Thread-Specific Storage模式可能就无法正确工作。这是使用java.lang.ThreadLocal时的一个重要制约条件。</p></blockquote><blockquote><p>在设计多线程角色时，根据以 [ 主体 ] 为主还是以 [ 客体 ] 为主的不同产生了以下两种方式。</p><ul><li><p>基于角色：以主体为主</p><p>所谓基于角色，一言以蔽之即”线程最伟大“的方式。</p><p>基于角色的方式即在表示线程的实例中保存进行工作所必需的信息（上下文、状态）。这样可以减少和减轻线程之间的交互信息量。一个线程会使用从其他线程接收到的信息来执行处理，改变自己的内部状态。通常，我们称这样的线程为角色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Actor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>角色的内部状态<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>循环地从外部接收并执行任务，改变内部状态<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>基于任务：以客体为主</p><p>所谓基于任务，一言以蔽之即”任务最伟大“的方式。</p><p>基于任务的方式不在线程中保存信息（上下文、状态）。在这种方式下，这些信息不保存在线程中，而是保存在线程交互的实例中。而且，不仅是数据，连用于执行请求的方法都定义在其中。像这样在线程之交互的实例可以称为消息、请求或是命令。这里我们暂且称其为任务。由于任务中保存了足够的信息，所以任何线程执行该任务都没有问题。可以说，这是一种富任务往来于轻线程之间的方式。</p><p>使用该方式的一个典型的模式是Worker Thread模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>进行工作所必需的信息<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>工作的处理内容<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>基于任务的示例</p><p>java.util.TimerTask是一个基于任务的类。该类实现了java.lang.Runnable，它会被java.util.Timer类调用。如果要定义一项在一定时间后进行的工作或者定期进行的工作，可以使用java.util.TimerTask类。</p><p>java.util.concurrent.FutureTask类也是一个基于任务的类。该类是Future模式的组成部分，它也实现了java.lang.Runnable。</p></blockquote><h2 id="Active-Object模式"><a href="#Active-Object模式" class="headerlink" title="Active Object模式"></a>Active Object模式</h2><h3 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h3><p>Active是主动的意思，因此ActiveObject就是主动对象的意思。所谓主动一般指有自己特有的线程，举例来说，java.lang.Thread类的实例就是一种主动对象。</p><p>不过，在Active Object模式中出厂的主动对象可不仅仅有自己特有的线程，它同时还具备可以从外部接收和处理异步消息并根据需要返回处理结果的特征。Active Object模式中的主动对象会通过自己特有的线程在合适的时机处理从外部接收到的异步消息。</p><p>在Active Object中，组成主动对象与许多自然人组成法人类似，即使是java语言这样没有异步消息的编程语言，也可以使用Active Object模式组成实际上能够处理异步消息的主动对象。</p><blockquote><p>在Java中，有一种与Active Object模式相关的技术叫做Remote Method Invocation（远程方法调用，RMI）。RMI是一种可以在本地调用方法，然后网络远端的计算机上执行方法的技术。为了能够在网络间传输对象，RMI使用了Java的序列化（serialization）技术。</p></blockquote><h3 id="模式详解-7"><a href="#模式详解-7" class="headerlink" title="模式详解"></a>模式详解</h3><p><strong>成员一览（粗体字为activeObject包中的public的类和接口）</strong></p><table><thead><tr><th>包</th><th>名字</th><th>说明</th></tr></thead><tbody><tr><td>无名</td><td>Main</td><td>测试程序行为的类</td></tr><tr><td>无名</td><td>MakeClientThread</td><td>发出”生成字符串“请求的线程</td></tr><tr><td>无名</td><td>DisplayClientThread</td><td>发出”显示字符串“请求的线程</td></tr><tr><td>activeObject</td><td><strong>ActiveObject</strong></td><td>定义”主动对象“的接口（API）的接口</td></tr><tr><td>activeObject</td><td><strong>ActiveObjectFactory</strong></td><td>创建”主动对象“的类</td></tr><tr><td>activeObject</td><td>Proxy</td><td>将方法调用转换为MethodRequest对象的类（实现了ActiveObject）的接口</td></tr><tr><td>activeObject</td><td>SchedulerThread</td><td>调用execute方法处理MethodRequest对象的类</td></tr><tr><td>activeObject</td><td>ActivationQueue</td><td>按顺序保存MethodRequest对象的类</td></tr><tr><td>activeObject</td><td>MethodRequest</td><td>表示请求的抽象类</td></tr><tr><td>activeObject</td><td>MakeStringRequest</td><td>makeString方法（生成字符串）对应的类。MethodRequest类的子类</td></tr><tr><td>activeObject</td><td>DisplayStringRequest</td><td>displayString方法（显示字符串）对应的类。MethodRequest类的子类</td></tr><tr><td>activeObject</td><td>Result</td><td>表示执行结果的抽象类</td></tr><tr><td>activeObject</td><td>FutureResult</td><td>在Future模式中表示执行结果的类</td></tr><tr><td>activeObject</td><td>RealResult</td><td>表示实际的执行结果的类</td></tr><tr><td>activeObject</td><td>Servant</td><td>执行实际处理的类（实现了ActiveObject接口）</td></tr></tbody></table><h4 id="角色-1"><a href="#角色-1" class="headerlink" title="角色"></a><strong>角色</strong></h4><ul><li><p>Client（委托者）</p><p>Client角色调用ActiveObject角色的方法来委托处理，它能调用的只有ActiveObject角色提供的方法。调用这些方法后，（如果ActivationQueue角色没有满）程序控制权会立即返回。</p><p>虽然client只知道ActiveObject角色，但它实际上调用的是Proxy角色。</p><p>Client角色在获取处理结果时，会调用VirtualResult角色的getResultValue方法。这里使用了Future模式模式。</p><p>在示例程序1中，由MakerClientThread类和DisplayClientThread类扮演此角色。</p></li><li><p>ActiveObject角色</p><p>ActiveObject角色定义了主动对象向Client角色提供的接口。</p><p>在示例1程序中，由ActiveObject接口扮演此角色。</p></li><li><p>Proxy（代理人）</p><p>Proxy角色负责将方法调用转换为MethodRequest角色的对象。转换后的MethodRequest角色会被传递给Scheduler角色。</p><p>Proxy角色实现了ActiveObject角色提供的接口。</p><p>调用Proxy角色的方法的是Client角色。将方法调用转换为MethodRequest角色，并传递给Scheduler角色的操作都是使用Client角色的线程进行的。</p><p>在示例1程序中，由Proxy类扮演此角色。</p></li><li><p>Scheduler</p><p>Scheduler角色负责将Proxy角色传递过来的MethodRequest角色传递给ActivationQueue角色，以及从ActivationQueue角色去除并执行MethodRequest角色这两项工作。</p><p>Client角色负责将MethodRequest角色传递给ActivationQueue角色。</p><p>而从ActivationQueue角色中取出并执行MethodRequest角色这项工作则是使用Scheduler角色自己的线程进行的。在ActiveObject模式中，<strong>只有使用Client角色和Scheduler角色时才会启动新线程。</strong></p><p>Scheduler角色会把MethodRequest角色放入ActivationQueue角色或者从ActivationQueue角色取出MethodRequest角色。因此，Scheduler角色可以判断下次要执行哪个请求。<strong>如果想实现请求调度的判断逻辑，可以将它们实现在Scheduler角色中。</strong>也正是因为如此，我们才将其命名为Scheduler。</p><p>在示例程序1中，由SchedulerThread类扮演此角色。SchedulerThread并没有进行特殊的调度，而只是执行FIFO（First In First Out）处理。</p></li><li><p>MethodRequest</p><p>MethodRequest角色是来自Client角色的请求对应的角色。MethodRequest定义了负责执行处理的Servant角色，以及负责设置返回值的Future角色和负责执行请求的方法（execute）。</p><p>MethodRequest角色为主动对象的接口赋予了对象的表象形式。</p><p>在示例程序1中，由MethodRequest类扮演此角色。</p></li><li><p>ConcreteMethodRequest</p><p>ConcreteMethodRequest角色是使MethodRequest角色与具体的方法相对应的角色。对于ActiveObject角色中定义的每个方法，会有各个类与之对应。比如MethodAlphaRequest、MethodBetaRequest…。</p><p>在示例程序1中，由MakeStringRequest类和DisplayStringRequest类扮演此角色。其中，MakeStringRequest类对应makeString方法，DisplayStringRequest类对应displayString方法。</p></li><li><p>Servant（仆人）</p><p>Servant角色负责实际地处理请求。</p><p>调用Servant角色的是Scheduler角色的线程。Scheduler角色会从ActivationQueue角色取出一个MethodRequest角色（实际上是ConcreteMethodRequest角色）并执行它。此时，Scheduler角色调用的就是Servant角色的方法。</p><p>Servant角色实现了ActiveObject角色定义的接口。</p><p>Proxy角色会将请求转换为MethodRequest角色，而Servant角色则会实际地执行该请求。Scheduler角色介于Proxy角色和Servant角色之间，负责管理按照什么顺序执行请求。</p><p>在示例程序1中，由Servant类扮演此角色。</p></li><li><p>ActivationQueue（主动队列）</p><p>ActivationQueue角色是保存MethodRequest角色的类。</p><p>调用putRequest方法的是Client角色的线程，而调用takeRequest方法的是Scheduler角色的线程。这里使用了Producer-Consumer模式。</p></li><li><p>VirtualResult（虚拟结果）</p><p>VirtualResult角色与Future角色、RealResult角色共同构成了Future模式。</p><p>Client角色在获取处理结果时会调用VirtualResult角色（实际上是Future角色）的getResultValue方法。</p><p>在示例程序1中，由Result类扮演此角色。</p></li><li><p>Future（期货）</p><p>Future角色是Client角色在获取处理时实际调用的角色。当处理结果还没有出来的时候，它会使用Guarded Suspension模式让Client角色的线程等待结果出来。</p><p>在示例程序1中，由FutureResult类扮演此角色。</p></li><li><p>RealResult（真实结果）</p><p>RealResult角色是表示处理结果的角色。Servant角色会创建一个RealResult角色作为处理结果，然后调用Future角色的setRealResult方法将其设置到Future角色中。</p><p>在示例程序1中，由RealResult类扮演此角色</p></li></ul><h4 id="示例程序1类图"><a href="#示例程序1类图" class="headerlink" title="示例程序1类图"></a><strong>示例程序1类图</strong></h4><img src="/posts/4b405cfc/75.png" style="zoom:67%;"><h4 id="示例程序1时序图"><a href="#示例程序1时序图" class="headerlink" title="示例程序1时序图"></a><strong>示例程序1时序图</strong></h4><img src="/posts/4b405cfc/76.png" style="zoom:67%;"><h4 id="示例1代码"><a href="#示例1代码" class="headerlink" title="示例1代码"></a>示例1代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActivationQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_METHOD_REQUEST</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MethodRequest[] requestQueue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tail; <span class="hljs-comment">// 下次putRequest的位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> head; <span class="hljs-comment">// 下次taskRequest的位置</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count; <span class="hljs-comment">// MethodRequest的数量</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ActivationQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.requestQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodRequest</span>[MAX_METHOD_REQUEST];<br>        <span class="hljs-built_in">this</span>.tail = tail;<br>        <span class="hljs-built_in">this</span>.head = head;<br>        <span class="hljs-built_in">this</span>.count = count;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putRequest</span><span class="hljs-params">(MethodRequest request)</span> &#123;<br>        <span class="hljs-keyword">while</span> (count &gt;= requestQueue.length) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        requestQueue[tail] = request;<br>        tail = (tail + <span class="hljs-number">1</span>) % requestQueue.length;<br>        count++;<br>        notifyAll();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> MethodRequest <span class="hljs-title function_">takeRequest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (count &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">MethodRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> requestQueue[head];<br>        head = (head + <span class="hljs-number">1</span>) % requestQueue.length;<br>        count --;<br>        notifyAll();<br>        <span class="hljs-keyword">return</span> request;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ActiveObject</span> &#123;<br>    Result&lt;String&gt; <span class="hljs-title function_">makeString</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">char</span> fillchar)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayString</span><span class="hljs-params">(String string)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActiveObjectFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ActiveObject <span class="hljs-title function_">createActiveObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Servant</span> <span class="hljs-variable">servant</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Servant</span>();<br>        <span class="hljs-type">ActivationQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActivationQueue</span>();<br>        <span class="hljs-type">SchedulerThread</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SchedulerThread</span>(queue);<br>        <span class="hljs-type">Proxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(scheduler, servant);<br>        scheduler.start();<br>        <span class="hljs-keyword">return</span> proxy;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisplayClientThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActiveObject activeObject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DisplayClientThread</span><span class="hljs-params">(String name, ActiveObject activeObject)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.activeObject = activeObject;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-literal">true</span>; i++) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + i;<br>                activeObject.displayString(string);<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisplayStringRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodRequest</span>&lt;Object&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String string;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DisplayStringRequest</span><span class="hljs-params">(Servant servant, String string)</span> &#123;<br>        <span class="hljs-built_in">super</span>(servant, <span class="hljs-literal">null</span>);<br>        <span class="hljs-built_in">this</span>.string = string;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        servant.displayString(string);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureResult</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Result</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> Result&lt;T&gt; result;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">ready</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setResult</span><span class="hljs-params">(Result&lt;T&gt; result)</span> &#123;<br>        <span class="hljs-built_in">this</span>.result = result;<br>        <span class="hljs-built_in">this</span>.ready = <span class="hljs-literal">true</span>;<br>        notifyAll();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> T <span class="hljs-title function_">getResultValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!ready) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                wait();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result.getResultValue();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ActiveObject</span> <span class="hljs-variable">activeObject</span> <span class="hljs-operator">=</span> ActiveObjectFactory.createActiveObject();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MakeClientThread</span>(<span class="hljs-string">&quot;Alice&quot;</span>, activeObject).start();;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MakeClientThread</span>(<span class="hljs-string">&quot;Bobby&quot;</span>, activeObject).start();;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayClientThread</span>(<span class="hljs-string">&quot;Chris&quot;</span>, activeObject).start();;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MakeClientThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActiveObject activeObject;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> fillchar;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MakeClientThread</span><span class="hljs-params">(String name, ActiveObject activeObject)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.activeObject = activeObject;<br>        <span class="hljs-built_in">this</span>.fillchar = name.charAt(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-literal">true</span>; i++) &#123;<br>                Result&lt;String&gt; result = activeObject.makeString(i, fillchar);<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> result.getResultValue();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: value = &quot;</span> + value);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MakeStringRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MethodRequest</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> fillchar;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MakeStringRequest</span><span class="hljs-params">(Servant servant, FutureResult&lt;String&gt; future, <span class="hljs-type">int</span> count, <span class="hljs-type">char</span> fillchar)</span> &#123;<br>        <span class="hljs-built_in">super</span>(servant, future);<br>        <span class="hljs-built_in">this</span>.count = count;<br>        <span class="hljs-built_in">this</span>.fillchar = fillchar;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        Result&lt;String&gt; result = servant.makeString(count, fillchar);<br>        future.setResult(result);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodRequest</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Servant servant;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> FutureResult&lt;T&gt; future;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">MethodRequest</span><span class="hljs-params">(Servant servant, FutureResult&lt;T&gt; future)</span> &#123;<br>        <span class="hljs-built_in">this</span>.servant = servant;<br>        <span class="hljs-built_in">this</span>.future = future;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActiveObject</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SchedulerThread scheduler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Servant servant;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Proxy</span><span class="hljs-params">(SchedulerThread scheduler, Servant servant)</span> &#123;<br>        <span class="hljs-built_in">this</span>.scheduler = scheduler;<br>        <span class="hljs-built_in">this</span>.servant = servant;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">makeString</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">char</span> fillchar)</span> &#123;<br>        FutureResult&lt;String&gt; future = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureResult</span>&lt;&gt;();<br>        scheduler.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MakeStringRequest</span>(servant, future, count, fillchar));<br>        <span class="hljs-keyword">return</span> future;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayString</span><span class="hljs-params">(String string)</span> &#123;<br>        scheduler.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayStringRequest</span>(servant, string));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealResult</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Result</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T resultValue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RealResult</span><span class="hljs-params">(T result)</span> &#123;<br>        <span class="hljs-built_in">this</span>.resultValue = result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getResultValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> resultValue;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title function_">getResultValue</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchedulerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActivationQueue queue;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SchedulerThread</span><span class="hljs-params">(ActivationQueue queue)</span> &#123;<br>        <span class="hljs-built_in">this</span>.queue = queue;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodRequest request)</span> &#123;<br>        queue.putRequest(request);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-type">MethodRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> queue.takeRequest();<br>            request.execute();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Servant</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActiveObject</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result&lt;String&gt; <span class="hljs-title function_">makeString</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">char</span> fillchar)</span> &#123;<br>        <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[count];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>            buffer[i] = fillchar;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; make count = &quot;</span> + count + <span class="hljs-string">&quot;, fillchar = &quot;</span> + fillchar + <span class="hljs-string">&quot; complete&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealResult</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayString</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;displayString: &quot;</span> + string);<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类图-1"><a href="#类图-1" class="headerlink" title="类图"></a>类图</h3><img src="/posts/4b405cfc/77.png" alt="20200707213425" style="zoom: 67%;"><h3 id="时序图-3"><a href="#时序图-3" class="headerlink" title="时序图"></a>时序图</h3><img src="/posts/4b405cfc/78.png" alt="11111" style="zoom: 67%;"><h3 id="TimeThreads图"><a href="#TimeThreads图" class="headerlink" title="TimeThreads图"></a>TimeThreads图</h3><img src="/posts/4b405cfc/79.png" alt="2222" style="zoom: 67%;"><h3 id="java-uti-concurrent包于Active-Object模式"><a href="#java-uti-concurrent包于Active-Object模式" class="headerlink" title="java.uti.concurrent包于Active Object模式"></a>java.uti.concurrent包于Active Object模式</h3><p><strong>类和接口一览</strong></p><table><thead><tr><th>包</th><th>类和接口</th><th>内容</th></tr></thead><tbody><tr><td>无名</td><td>Main</td><td>测试程序行为的类</td></tr><tr><td>无名</td><td>MakerClientThread</td><td>委托ActiveObject来生成字符串的线程</td></tr><tr><td>无名</td><td>DisplayClientThread</td><td>委托ACtiveObject来显示字符串的线程</td></tr><tr><td>activeObject</td><td>ActiveObject</td><td>定义主动对象的接口的接口</td></tr><tr><td>activeObject</td><td>ActiveObjectFactory</td><td>创建主动对象的类</td></tr><tr><td>activeObject</td><td>ActiveObjectImpl</td><td>实现了ActiveObject接口的类</td></tr><tr><td>activeObject</td><td>MakeStringRequest</td><td>对应makeString方法（生成字符串）的类</td></tr><tr><td>activeObject</td><td>DisplayStringRequest</td><td>对应DisplayString方法（显示字符串）的类</td></tr></tbody></table><p><strong>使用到的标准类库</strong></p><table><thead><tr><th>类和接口</th><th>内容</th></tr></thead><tbody><tr><td>java.util.concurrent.Executors</td><td>用于获取ExecutorService的工具类</td></tr><tr><td>java.util.concurrent.ExecutorService</td><td>用于提交（submit）请求的接口（替换示例程序中1中的SchedulerThread、ActivationQueue）</td></tr><tr><td>java.util.concurrent.Callable</td><td>将获取返回值的调用（call）抽象化后的接口（替代示例程序1中的MethodRequest）</td></tr><tr><td>java.util.Runnable</td><td>将不获取返回值的调用（run）抽象化后的接口（替代示例程序1中的MethodRequest）</td></tr><tr><td>java.util.concurrent.Future</td><td>表示返回值的接口（替代示例程序1中的Result、FutureResult、RealResult）</td></tr></tbody></table><h4 id="示例程序2的类图"><a href="#示例程序2的类图" class="headerlink" title="示例程序2的类图"></a><strong>示例程序2的类图</strong></h4><img src="/posts/4b405cfc/80.png" alt="3333" style="zoom:67%;"><h4 id="角色-2"><a href="#角色-2" class="headerlink" title="角色"></a><strong>角色</strong></h4><ul><li><p>Main类</p><p>用于测试程序行为的类。与示例1不同的是可以通过shutdown方法终止。</p></li><li><p>MakerClientThread类<br>MakeClientThread类是调用ActiveObject对象的makeString方法（生成字符串）的线程。<br>于示例程序1不同时，makeString方法的返回值类型是Future&lt;String&gt;。</p></li><li><p>DisplayClientThread类<br>DisplayClientThread类与MakerClientThread类一样，也是表示调用ActiveObject对象的线程的类。</p></li><li><p>ActiveObject接口<br>ActiveObject接口定义了主动对象的接口。<br>与示例程序1不同的是，makeString的返回值类行为Future&lt;String&gt;，而且也增加了shutdown方法。</p></li><li><p>ActiveObjectFactory类<br>ActiveObjectFactory类是用于构成ACtiveObject对象的类。</p><p>于示例程序1不同的是，这里不会组建多个对象，而是仅仅返回ActiveObjectImpl类的实例。这是因为，使用java.util.concurrent包后，类的结构变简单了。</p></li><li><p>ActiveObjectImpl类</p><p>ActiveObjectImpl类是实现了ActiveObject接口的类，它可以进行很多工作。该类与示例程序1中的Proxy和Servant相对应。</p><p>servant字段中保存的是通过Executors.newSingleThreadExecutor方法获取的ExecutorService对象。这样可以确保在这个ExecutorService对象中的背后只有一个线程（通过newSingleThreadExecutor则个名字我们也可以看出来）。</p><p>ExecutorService对象相当于示例程序1中的SchedulerThread类的实例。另外，虽然从表面上看不出来，但是ExecutorService对象的内部保存着一个线程安全的队列，该队列相当于示例程序1中的ActivationQueue类的实例。</p><p>shutdown方法是用于关闭service字段中保存的ExecutorService对象的方法。这样一来，ExecutorService对象就不会再接受新的请求了。</p><p>makeString方法会创建MakeStringRequest类的实例，并submit给ExecutorService对象。</p><p>displayString方法会创建DisplayStringRequest类的实例，并在ExecutorService中execute。</p><p>可以submit和execute的是Callable对象和Runnable对象。MakeStringRequest类实现了Callable接口，而DisplayStringRequest类实现了Runnable接口。</p><h4 id="示例2代码"><a href="#示例2代码" class="headerlink" title="示例2代码"></a>示例2代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ActiveObject</span> &#123;<br>    Future&lt;String&gt; <span class="hljs-title function_">makeString</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">char</span> fillchar)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayString</span><span class="hljs-params">(String string)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActiveObjectFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ActiveObject <span class="hljs-title function_">createActiveObject</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ActiveObjectImpl</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ActiveObjectImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ActiveObject</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><br>    <span class="hljs-comment">// 有返回值的调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Future&lt;String&gt; <span class="hljs-title function_">makeString</span><span class="hljs-params">(<span class="hljs-type">int</span> count, <span class="hljs-type">char</span> fillchar)</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">MakeStringRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;String&gt; &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">char</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[count];<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                        buffer[i] = fillchar;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 发出请求</span><br>        <span class="hljs-keyword">return</span> service.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MakeStringRequest</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 没有返回值的调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayString</span><span class="hljs-params">(String string)</span> &#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisplayStringRequest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;displayString: &quot;</span> + string);<br>                    Thread.sleep(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 发出请求</span><br>        service.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayStringRequest</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 终止服务</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>        service.shutdown();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisplayClientThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActiveObject activeObject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DisplayClientThread</span><span class="hljs-params">(String name, ActiveObject activeObject)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.activeObject = activeObject;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-literal">true</span>; i++) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + i;<br>                activeObject.displayString(string);<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + e);<br>        &#125; <span class="hljs-keyword">catch</span> (CancellationException e) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MakerClientThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActiveObject activeObject;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> fillchar;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MakerClientThread</span><span class="hljs-params">(String name, ActiveObject activeObject)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>        <span class="hljs-built_in">this</span>.activeObject = activeObject;<br>        <span class="hljs-built_in">this</span>.fillchar = name.charAt(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-literal">true</span>; i++) &#123;<br>                Future&lt;String&gt; future = activeObject.makeString(i, fillchar);<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> future.get();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;: value = &quot;</span> + value);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + e);<br>        &#125; <span class="hljs-keyword">catch</span> (CancellationException e) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + e);<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;:&quot;</span> + e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ActiveObject</span> <span class="hljs-variable">activeObject</span> <span class="hljs-operator">=</span> ActiveObjectFactory.createActiveObject();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">MakerClientThread</span>(<span class="hljs-string">&quot;Alice&quot;</span>, activeObject).start();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">MakerClientThread</span>(<span class="hljs-string">&quot;Bobby&quot;</span>, activeObject).start();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisplayClientThread</span>(<span class="hljs-string">&quot;Chris&quot;</span>, activeObject).start();<br>            Thread.sleep(<span class="hljs-number">10000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;**** shutdown ****&quot;</span>);<br>            activeObject.shutdown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程设计模式&quot;&gt;&lt;a href=&quot;#多线程设计模式&quot; class=&quot;headerlink&quot; title=&quot;多线程设计模式&quot;&gt;&lt;/a&gt;多线程设计模式&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="设计" scheme="https://blog.yahyav2rayssr.top/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>AQS 原理</title>
    <link href="https://blog.yahyav2rayssr.top/posts/9784837e/"/>
    <id>https://blog.yahyav2rayssr.top/posts/9784837e/</id>
    <published>2023-04-16T15:53:54.708Z</published>
    <updated>2023-04-16T15:53:54.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AQS-原理"><a href="#AQS-原理" class="headerlink" title="AQS 原理"></a>AQS 原理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><img src="/posts/9784837e/20200910173801.png" alt="image-20200910173801408" style="zoom:33%;"><img src="/posts/9784837e/20200910181253.png" alt="image-20200910181253357" style="zoom:33%;"><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestAqs&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestAqs</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyLock</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br>                sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;locking...&quot;</span>);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;unlocking...&quot;</span>);<br>                lock.unlock();<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 自定义锁（不可重入锁）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-comment">// 独占锁  同步器类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MySync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-keyword">if</span>(compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                <span class="hljs-comment">// 加上了锁，并设置 owner 为当前线程</span><br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 是否持有独占锁</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">MySync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MySync</span>();<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 加锁（不成功会进入等待队列）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 加锁，可打断</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 尝试加锁（一次）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 尝试加锁，带超时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 解锁</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-comment">// 创建条件变量</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><img src="/posts/9784837e/20200910185100.png" alt="image-20200910185100196" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/9784837e/20200910185145.png" alt="image-20200910185145199" style="zoom:33%;"><img src="/posts/9784837e/20200910185338.png" alt="image-20200910185337965" style="zoom:33%;"><img src="/posts/9784837e/20200910185540.png" alt="image-20200910185540776" style="zoom:33%;"><p>-1 代表该节点有职责唤醒后继节点</p><img src="/posts/9784837e/20200910190051.png" alt="image-20200910190051286" style="zoom:33%;"><img src="/posts/9784837e/image-20200910190334697.png" alt="image-20200910190334697" style="zoom:33%;"><img src="/posts/9784837e/image-20200910190727603.png" alt="image-20200910190727603" style="zoom:33%;"><img src="/posts/9784837e/image-20200910191349362.png" alt="image-20200910191349362" style="zoom:33%;"><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><blockquote><p>通过内部的一个累加计数器实现锁重入，这也意味着只有计数器计数为0才算是真正意义上的释放锁。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Sync 继承过来的方法，方便阅读，放在此处。</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>          <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>          <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>          <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>              <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                  setExclusiveOwnerThread(current);<br>                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>              &#125;<br>          &#125;<br>          <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>              <span class="hljs-comment">// state++;</span><br>              <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>              <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>              setState(nextc);<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br><br><span class="hljs-comment">// Sync 继承过来的方法，方便阅读，放在此处。</span><br>      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>          <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>              <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>          <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>          <span class="hljs-comment">// 支持锁重入，只有state减为0，才释放成功</span><br>          <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>              free = <span class="hljs-literal">true</span>;<br>              setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>          &#125;<br>          setState(c);<br>          <span class="hljs-keyword">return</span> free;<br>      &#125;<br></code></pre></td></tr></table></figure><h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><h4 id="不可打断模式"><a href="#不可打断模式" class="headerlink" title="不可打断模式"></a>不可打断模式</h4><p>在此模式下，即使它被打断，任会驻留在AQS队列中，等获得锁后方能继续运行（是继续运行！只是打断标记被设置为true）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 如果打断标记是 true，则 park 会失效</span><br>       LockSupport.park(<span class="hljs-built_in">this</span>);<br>       <span class="hljs-comment">// interrupted 会清除打断标记</span><br>       <span class="hljs-keyword">return</span> Thread.interrupted();<br>   &#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>           <span class="hljs-keyword">for</span> (;;) &#123;<br>               <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>               <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                   setHead(node);<br>                   p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                   failed = <span class="hljs-literal">false</span>;<br>                   <span class="hljs-comment">// 还是需要获得锁后，才能返回打断标志</span><br>                   <span class="hljs-keyword">return</span> interrupted;<br>               &#125;<br>               <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                   parkAndCheckInterrupt())<br>                   <span class="hljs-comment">// 如果是因为 interrupt 被唤醒，返回打断状态为 true</span><br>                   interrupted = <span class="hljs-literal">true</span>;<br>           &#125;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-keyword">if</span> (failed)<br>               cancelAcquire(node);<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>       <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>           <span class="hljs-comment">// 如果打断状态为true</span><br>           selfInterrupt();<br>   &#125;<br><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">selfInterrupt</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 重新产生一次打断</span><br>       Thread.currentThread().interrupt();<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h4><blockquote><p>通过抛出异常的方式进行打断。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>           <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-keyword">if</span> (Thread.interrupted())<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>       <span class="hljs-comment">// 如果没有获得到锁，进入（一）</span><br>       <span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>           doAcquireInterruptibly(arg);<br>   &#125;<br><br><span class="hljs-comment">// （一）可打断的获取锁流程</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>       <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>       <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">for</span> (;;) &#123;<br>               <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>               <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                   setHead(node);<br>                   p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                   failed = <span class="hljs-literal">false</span>;<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<br>               <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                   parkAndCheckInterrupt())<br>                   <span class="hljs-comment">// 在 park 过程中如果被 interrupt 会进入此</span><br>                   <span class="hljs-comment">// 这时候抛出异常，而不会再次进入 for (;;)</span><br>                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>           &#125;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-keyword">if</span> (failed)<br>               cancelAcquire(node);<br>       &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h3><img src="/posts/9784837e/image-20200910231216160.png" alt="image-20200910231216160" style="zoom:33%;"><h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><img src="/posts/9784837e/image-20200910231351794.png" alt="image-20200910231351794" style="zoom: 50%;"><img src="/posts/9784837e/image-20200910231410324.png" alt="image-20200910231410324" style="zoom: 50%;"><img src="/posts/9784837e/image-20200910231522031.png" alt="image-20200910231522031" style="zoom: 50%;"><h3 id="条件变量实现原理"><a href="#条件变量实现原理" class="headerlink" title="条件变量实现原理"></a>条件变量实现原理</h3><h4 id="await流程"><a href="#await流程" class="headerlink" title="await流程"></a>await流程</h4><blockquote><p>相当于把当前线程放入到 ConditionObject 链表中，节点状态为-2，等待 signal 方法进行唤醒。</p></blockquote><img src="/posts/9784837e/image-20200910231802687.png" alt="image-20200910231802687" style="zoom:33%;"><img src="/posts/9784837e/image-20200910232557079.png" alt="image-20200910232557079" style="zoom:33%;"><img src="/posts/9784837e/image-20200910232459157.png" alt="image-20200910232459157" style="zoom:33%;"><img src="/posts/9784837e/image-20200910232513091.png" alt="image-20200910232513091" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>            interruptMode = REINTERRUPT;<br>        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>            unlinkCancelledWaiters();<br>        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>            reportInterruptAfterWait(interruptMode);<br>    &#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>            failed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> savedState;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    &#125;<br>&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Adds a new waiter to wait queue.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> its new wait node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>        <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>            unlinkCancelledWaiters();<br>            t = lastWaiter;<br>        &#125;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>            firstWaiter = node;<br>        <span class="hljs-keyword">else</span><br>            t.nextWaiter = node;<br>        lastWaiter = node;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br><br></code></pre></td></tr></table></figure><h4 id="signal-流程"><a href="#signal-流程" class="headerlink" title="signal 流程"></a>signal 流程</h4><blockquote><p>相当于从 ConditionObject 链表中获取到第一个节点，放到队列数组里面的最后一个节点，同时将前一个 Node 的标志位置为-1，使其具有换下一个节点的义务。</p></blockquote><img src="/posts/9784837e/image-20200910233133601.png" alt="image-20200910233133601" style="zoom:33%;"><img src="/posts/9784837e/image-20200910233503355.png" alt="image-20200910233503355" style="zoom:33%;"><img src="/posts/9784837e/image-20200910233728545.png" alt="image-20200910233728545" style="zoom:33%;"><img src="/posts/9784837e/image-20200910234451060.png" alt="image-20200910234451060" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Moves the longest-waiting thread, if one exists, from the</span><br><span class="hljs-comment">     * wait queue for this condition to the wait queue for the</span><br><span class="hljs-comment">     * owning lock.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="hljs-doctag">@link</span> #isHeldExclusively&#125;</span><br><span class="hljs-comment">     *         returns &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>            doSignal(first);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>                lastWaiter = <span class="hljs-literal">null</span>;<br>            first.nextWaiter = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>                 (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>    &#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If cannot change waitStatus, the node has been cancelled.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="hljs-comment">     * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="hljs-comment">     * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="hljs-comment">     * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>锁重入升级（不允许）：即持有读锁的情况下去获取写锁</p><img src="/posts/9784837e/image-20200911094432790.png" alt="image-20200911094432790" style="zoom:33%;"><p>重入时降级：即持有写锁的情况下去获取读锁</p><img src="/posts/9784837e/image-20200911094544537.png" alt="image-20200911094544537" style="zoom:33%;"><h3 id="应用之缓存"><a href="#应用之缓存" class="headerlink" title="应用之缓存"></a>应用之缓存</h3><h4 id="读多写少的场景"><a href="#读多写少的场景" class="headerlink" title="读多写少的场景"></a>读多写少的场景</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestGenericDao</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">GenericDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericDaoCached</span>();<br>        System.out.println(<span class="hljs-string">&quot;============&gt; 查询&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from emp where empno = ?&quot;</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">empno</span> <span class="hljs-operator">=</span> <span class="hljs-number">7369</span>;<br>        <span class="hljs-type">Emp</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> dao.queryOne(Emp.class, sql, empno);<br>        System.out.println(emp);<br>        emp = dao.queryOne(Emp.class, sql, empno);<br>        System.out.println(emp);<br>        emp = dao.queryOne(Emp.class, sql, empno);<br>        System.out.println(emp);<br><br>        System.out.println(<span class="hljs-string">&quot;============&gt; 更新&quot;</span>);<br>        dao.update(<span class="hljs-string">&quot;update emp set sal = ? where empno = ?&quot;</span>, <span class="hljs-number">800</span>, empno);<br>        emp = dao.queryOne(Emp.class, sql, empno);<br>        System.out.println(emp);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDaoCached</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GenericDao</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">GenericDao</span> <span class="hljs-variable">dao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericDao</span>();<br>    <span class="hljs-keyword">private</span> Map&lt;SqlPair, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">queryList</span><span class="hljs-params">(Class&lt;T&gt; beanClass, String sql, Object... args)</span> &#123;<br>        <span class="hljs-keyword">return</span> dao.queryList(beanClass, sql, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">queryOne</span><span class="hljs-params">(Class&lt;T&gt; beanClass, String sql, Object... args)</span> &#123;<br>        <span class="hljs-comment">// 先从缓存中找，找到直接返回</span><br>        <span class="hljs-type">SqlPair</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlPair</span>(sql, args);;<br>        rw.readLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (T) map.get(key);<br>            <span class="hljs-keyword">if</span>(value != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rw.readLock().unlock();<br>        &#125;<br>        rw.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 多个线程</span><br>            <span class="hljs-type">T</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> (T) map.get(key);<br>            <span class="hljs-keyword">if</span>(value == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 缓存中没有，查询数据库</span><br>                value = dao.queryOne(beanClass, sql, args);<br>                map.put(key, value);<br>            &#125;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rw.writeLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String sql, Object... args)</span> &#123;<br>        rw.writeLock().lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 先更新库</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> dao.update(sql, args);<br>            <span class="hljs-comment">// 清空缓存</span><br>            map.clear();<br>            <span class="hljs-keyword">return</span> update;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            rw.writeLock().unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlPair</span> &#123;<br>        <span class="hljs-keyword">private</span> String sql;<br>        <span class="hljs-keyword">private</span> Object[] args;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">SqlPair</span><span class="hljs-params">(String sql, Object[] args)</span> &#123;<br>            <span class="hljs-built_in">this</span>.sql = sql;<br>            <span class="hljs-built_in">this</span>.args = args;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-type">SqlPair</span> <span class="hljs-variable">sqlPair</span> <span class="hljs-operator">=</span> (SqlPair) o;<br>            <span class="hljs-keyword">return</span> Objects.equals(sql, sqlPair.sql) &amp;&amp;<br>                    Arrays.equals(args, sqlPair.args);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Objects.hash(sql);<br>            result = <span class="hljs-number">31</span> * result + Arrays.hashCode(args);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/9784837e/image-20200911102153358.png" alt="image-20200911102153358" style="zoom:33%;"><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><h3 id="加锁-lock"><a href="#加锁-lock" class="headerlink" title="加锁 lock"></a>加锁 lock</h3><img src="/posts/9784837e/image-20200911102411451.png" alt="image-20200911102411451" style="zoom:33%;"><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Walkthrough:</span><br><span class="hljs-comment">     * 1. If read count nonzero or write count nonzero</span><br><span class="hljs-comment">     *    and owner is a different thread, fail.</span><br><span class="hljs-comment">     * 2. If count would saturate, fail. (This can only</span><br><span class="hljs-comment">     *    happen if count is already nonzero.)</span><br><span class="hljs-comment">     * 3. Otherwise, this thread is eligible for lock if</span><br><span class="hljs-comment">     *    it is either a reentrant acquire or</span><br><span class="hljs-comment">     *    queue policy allows it. If so, update state</span><br><span class="hljs-comment">     *    and set owner.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> exclusiveCount(c);<br>    <span class="hljs-keyword">if</span> (c != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span><br>        <span class="hljs-keyword">if</span> (w == <span class="hljs-number">0</span> || current != getExclusiveOwnerThread())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        <span class="hljs-comment">// Reentrant acquire</span><br>        setState(c + acquires);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (writerShouldBlock() ||<br>        !compareAndSetState(c, c + acquires))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    setExclusiveOwnerThread(current);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><img src="/posts/9784837e/image-20200911103656909.png" alt="image-20200911103656909" style="zoom:33%;"><img src="/posts/9784837e/image-20200911104153690.png" alt="image-20200911104153690" style="zoom:33%;"><img src="/posts/9784837e/image-20200911104522233.png" alt="image-20200911104522233" style="zoom:33%;"><img src="/posts/9784837e/image-20200911104613373.png" alt="image-20200911104613373" style="zoom:33%;"><img src="/posts/9784837e/image-20200911111138715.png" alt="image-20200911111138715" style="zoom:33%;"><p>图2</p><img src="/posts/9784837e/image-20200911111411201.png" alt="image-20200911111411201" style="zoom:33%;"><p>图3</p><img src="/posts/9784837e/image-20200911173229306.png" alt="image-20200911173229306" style="zoom:33%;"><p>图4</p><img src="/posts/9784837e/image-20200911173458330.png" alt="image-20200911173458330" style="zoom:33%;"><img src="/posts/9784837e/image-20200911180657807.png" alt="image-20200911180657807" style="zoom:33%;"><img src="/posts/9784837e/image-20200911180839851.png" alt="image-20200911180839851" style="zoom:33%;"><img src="/posts/9784837e/image-20200911181121407.png" alt="image-20200911181121407" style="zoom:33%;"><img src="/posts/9784837e/image-20200911182004345.png" alt="image-20200911182004345" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 返回值 -1 代表竞争失败， 1 代表加锁成功了</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-comment">// 返回值 -1 代表竞争失败， 1 代表加锁成功了</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 这里说明加锁成功了，剃掉头结点</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Walkthrough:</span><br><span class="hljs-comment">     * 1. If write lock held by another thread, fail.</span><br><span class="hljs-comment">     * 2. Otherwise, this thread is eligible for</span><br><span class="hljs-comment">     *    lock wrt state, so ask if it should block</span><br><span class="hljs-comment">     *    because of queue policy. If not, try</span><br><span class="hljs-comment">     *    to grant by CASing state and updating count.</span><br><span class="hljs-comment">     *    Note that step does not check for reentrant</span><br><span class="hljs-comment">     *    acquires, which is postponed to full version</span><br><span class="hljs-comment">     *    to avoid having to check hold count in</span><br><span class="hljs-comment">     *    the more typical non-reentrant case.</span><br><span class="hljs-comment">     * 3. If step 2 fails either because thread</span><br><span class="hljs-comment">     *    apparently not eligible or CAS fails or count</span><br><span class="hljs-comment">     *    saturated, chain to version with full retry loop.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (exclusiveCount(c) != <span class="hljs-number">0</span> &amp;&amp;<br>        getExclusiveOwnerThread() != current)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> sharedCount(c);<br>    <span class="hljs-keyword">if</span> (!readerShouldBlock() &amp;&amp;<br>        r &lt; MAX_COUNT &amp;&amp;<br>        compareAndSetState(c, c + SHARED_UNIT)) &#123;<br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>) &#123;<br>            firstReader = current;<br>            firstReaderHoldCount = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstReader == current) &#123;<br>            firstReaderHoldCount++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">HoldCounter</span> <span class="hljs-variable">rh</span> <span class="hljs-operator">=</span> cachedHoldCounter;<br>            <span class="hljs-keyword">if</span> (rh == <span class="hljs-literal">null</span> || rh.tid != getThreadId(current))<br>                cachedHoldCounter = rh = readHolds.get();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rh.count == <span class="hljs-number">0</span>)<br>                readHolds.set(rh);<br>            rh.count++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fullTryAcquireShared(current);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="解锁-unlock"><a href="#解锁-unlock" class="headerlink" title="解锁 unlock"></a>解锁 unlock</h3><img src="/posts/9784837e/image-20200911182745934.png" alt="image-20200911182745934" style="zoom: 50%;"><img src="/posts/9784837e/image-20200911182916809.png" alt="image-20200911182916809" style="zoom: 50%;"><img src="/posts/9784837e/image-20200911183246321.png" alt="image-20200911183246321" style="zoom: 50%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AQS-原理&quot;&gt;&lt;a href=&quot;#AQS-原理&quot; class=&quot;headerlink&quot; title=&quot;AQS 原理&quot;&gt;&lt;/a&gt;AQS 原理&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="AQS" scheme="https://blog.yahyav2rayssr.top/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>StampedLock 应用</title>
    <link href="https://blog.yahyav2rayssr.top/posts/61ccd33e/"/>
    <id>https://blog.yahyav2rayssr.top/posts/61ccd33e/</id>
    <published>2023-04-16T15:49:37.103Z</published>
    <updated>2023-04-16T15:49:37.103Z</updated>
    
    <content type="html"><![CDATA[<h1 id="StampedLock-应用"><a href="#StampedLock-应用" class="headerlink" title="StampedLock 应用"></a>StampedLock 应用</h1><img src="/posts/61ccd33e/image-20200911183739206.png" alt="image-20200911183739206" style="zoom:33%;"><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestStampedLock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestStampedLock</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">DataContainerStamped</span> <span class="hljs-variable">dataContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataContainerStamped</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            dataContainer.read(<span class="hljs-number">1</span>);<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>        sleep(<span class="hljs-number">0.5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            dataContainer.read(<span class="hljs-number">0</span>);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.DataContainerStamped&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DataContainerStamped</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">StampedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DataContainerStamped</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span> &#123;<br>        <span class="hljs-built_in">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> readTime)</span> &#123;<br>        <span class="hljs-comment">// 先乐观读，如果数据被写锁更改的话再执行锁升级</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br>        log.debug(<span class="hljs-string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);<br>        sleep(readTime);<br>        <span class="hljs-keyword">if</span> (lock.validate(stamp)) &#123;<br>            log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br>        <span class="hljs-comment">// 锁升级 - 读锁</span><br>        log.debug(<span class="hljs-string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            stamp = lock.readLock();<br>            log.debug(<span class="hljs-string">&quot;read lock &#123;&#125;&quot;</span>, stamp);<br>            sleep(readTime);<br>            log.debug(<span class="hljs-string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);<br>            <span class="hljs-keyword">return</span> data;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);<br>            lock.unlockRead(stamp);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-type">int</span> newData)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>        log.debug(<span class="hljs-string">&quot;write lock &#123;&#125;&quot;</span>, stamp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            sleep(<span class="hljs-number">2</span>);<br>            <span class="hljs-built_in">this</span>.data = newData;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            log.debug(<span class="hljs-string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);<br>            lock.unlockWrite(stamp);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/61ccd33e/image-20200911185759596.png" alt="image-20200911185759596" style="zoom: 33%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;StampedLock-应用&quot;&gt;&lt;a href=&quot;#StampedLock-应用&quot; class=&quot;headerlink&quot; title=&quot;StampedLock 应用&quot;&gt;&lt;/a&gt;StampedLock 应用&lt;/h1&gt;&lt;img src=&quot;/posts/61ccd33e</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Semaphore 应用</title>
    <link href="https://blog.yahyav2rayssr.top/posts/bcd2abf0/"/>
    <id>https://blog.yahyav2rayssr.top/posts/bcd2abf0/</id>
    <published>2023-04-16T15:49:19.536Z</published>
    <updated>2023-04-16T15:49:19.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Semaphore-应用"><a href="#Semaphore-应用" class="headerlink" title="Semaphore 应用"></a>Semaphore 应用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSemaphore</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 1. 创建 semaphore 对象</span><br>        <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><br>        <span class="hljs-comment">// 2. 10个线程同时运行</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    semaphore.acquire();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;running...&quot;</span>);<br>                    sleep(<span class="hljs-number">1</span>);<br>                    log.debug(<span class="hljs-string">&quot;end...&quot;</span>);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    semaphore.release();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><img src="/posts/bcd2abf0/image-20200911191554624.png" alt="image-20200911191554624" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestPoolSemaphore</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Pool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> pool.borrow();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                pool.free(conn);<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j(topic = &quot;c.Pool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>    <span class="hljs-comment">// 1. 连接池大小</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br><br>    <span class="hljs-comment">// 2. 连接对象数组</span><br>    <span class="hljs-keyword">private</span> Connection[] connections;<br><br>    <span class="hljs-comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span><br>    <span class="hljs-keyword">private</span> AtomicIntegerArray states;<br><br>    <span class="hljs-keyword">private</span> Semaphore semaphore;<br><br>    <span class="hljs-comment">// 4. 构造方法初始化</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pool</span><span class="hljs-params">(<span class="hljs-type">int</span> poolSize)</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>        <span class="hljs-comment">// 让许可数与资源数一致</span><br>        <span class="hljs-built_in">this</span>.semaphore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(poolSize);<br>        <span class="hljs-built_in">this</span>.connections = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Connection</span>[poolSize];<br>        <span class="hljs-built_in">this</span>.states = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[poolSize]);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            connections[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockConnection</span>(<span class="hljs-string">&quot;连接&quot;</span> + (i+<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 5. 借连接</span><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">borrow</span><span class="hljs-params">()</span> &#123;<span class="hljs-comment">// t1, t2, t3</span><br>        <span class="hljs-comment">// 获取许可</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            semaphore.acquire(); <span class="hljs-comment">// 没有许可的线程，在此等待</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-comment">// 获取空闲连接</span><br>            <span class="hljs-keyword">if</span>(states.get(i) == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (states.compareAndSet(i, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                    log.debug(<span class="hljs-string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);<br>                    <span class="hljs-keyword">return</span> connections[i];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 不会执行到这里</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 6. 归还连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(Connection conn)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; poolSize; i++) &#123;<br>            <span class="hljs-keyword">if</span> (connections[i] == conn) &#123;<br>                states.set(i, <span class="hljs-number">0</span>);<br>                log.debug(<span class="hljs-string">&quot;free &#123;&#125;&quot;</span>, conn);<br>                semaphore.release();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">45.197</span> c<span class="hljs-selector-class">.Pool</span> <span class="hljs-selector-attr">[Thread-1]</span> - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">45.197</span> c<span class="hljs-selector-class">.Pool</span> <span class="hljs-selector-attr">[Thread-0]</span> - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">46.200</span> c<span class="hljs-selector-class">.Pool</span> <span class="hljs-selector-attr">[Thread-0]</span> - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">46.200</span> c<span class="hljs-selector-class">.Pool</span> <span class="hljs-selector-attr">[Thread-1]</span> - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">46.200</span> c<span class="hljs-selector-class">.Pool</span> <span class="hljs-selector-attr">[Thread-2]</span> - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">46.200</span> c<span class="hljs-selector-class">.Pool</span> <span class="hljs-selector-attr">[Thread-3]</span> - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">47.201</span> c<span class="hljs-selector-class">.Pool</span> <span class="hljs-selector-attr">[Thread-3]</span> - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接2&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">47.201</span> c<span class="hljs-selector-class">.Pool</span> <span class="hljs-selector-attr">[Thread-2]</span> - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">47.201</span> c<span class="hljs-selector-class">.Pool</span> <span class="hljs-selector-attr">[Thread-4]</span> - borrow MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><span class="hljs-number">22</span>:<span class="hljs-number">32</span>:<span class="hljs-number">48.202</span> c<span class="hljs-selector-class">.Pool</span> <span class="hljs-selector-attr">[Thread-4]</span> - free MockConnection&#123;name=<span class="hljs-string">&#x27;连接1&#x27;</span>&#125;<br><br>Process finished with exit <span class="hljs-selector-tag">code</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><img src="/posts/bcd2abf0/image-20200911213945484.png" alt="image-20200911213945484" style="zoom:33%;"><img src="/posts/bcd2abf0/image-20200911214550865.png" alt="image-20200911214550865" style="zoom:33%;"><h3 id="release"><a href="#release" class="headerlink" title="release"></a>release</h3><img src="/posts/bcd2abf0/image-20200911220629619.png" alt="image-20200911220629619" style="zoom:33%;"><img src="/posts/bcd2abf0/image-20200911222216954.png" alt="image-20200911222216954" style="zoom:33%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Semaphore-应用&quot;&gt;&lt;a href=&quot;#Semaphore-应用&quot; class=&quot;headerlink&quot; title=&quot;Semaphore 应用&quot;&gt;&lt;/a&gt;Semaphore 应用&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CyclicBarrier 应用</title>
    <link href="https://blog.yahyav2rayssr.top/posts/27d2027c/"/>
    <id>https://blog.yahyav2rayssr.top/posts/27d2027c/</id>
    <published>2023-04-16T15:49:08.426Z</published>
    <updated>2023-04-16T15:49:08.426Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CyclicBarrier-应用"><a href="#CyclicBarrier-应用" class="headerlink" title="CyclicBarrier 应用"></a>CyclicBarrier 应用</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>和CountDownLatch不同，CyclicBarrier的数值可以被重复使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">3</span>);<br><span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>, ()-&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;task1, task2 finish...&quot;</span>);<br>&#125;);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123; <span class="hljs-comment">// task1  task2  task1</span><br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;task1 begin...&quot;</span>);<br>        sleep(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            barrier.await(); <span class="hljs-comment">// 2-1=1</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>    service.submit(() -&gt; &#123;<br>        log.debug(<span class="hljs-string">&quot;task2 begin...&quot;</span>);<br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            barrier.await(); <span class="hljs-comment">// 1-1=0</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;);<br>&#125;<br>service.shutdown();<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CyclicBarrier-应用&quot;&gt;&lt;a href=&quot;#CyclicBarrier-应用&quot; class=&quot;headerlink&quot; title=&quot;CyclicBarrier 应用&quot;&gt;&lt;/a&gt;CyclicBarrier 应用&lt;/h1&gt;&lt;h2 id=&quot;应用&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch 应用</title>
    <link href="https://blog.yahyav2rayssr.top/posts/18ad812a/"/>
    <id>https://blog.yahyav2rayssr.top/posts/18ad812a/</id>
    <published>2023-04-16T15:48:57.296Z</published>
    <updated>2023-04-16T15:48:57.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CountDownLatch-应用"><a href="#CountDownLatch-应用" class="headerlink" title="CountDownLatch 应用"></a>CountDownLatch 应用</h1><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>service.submit(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>    sleep(<span class="hljs-number">1</span>);<br>    latch.countDown();<br>    log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>&#125;);<br>service.submit(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>    sleep(<span class="hljs-number">1.5</span>);<br>    latch.countDown();<br>    log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>&#125;);<br>service.submit(() -&gt; &#123;<br>    log.debug(<span class="hljs-string">&quot;begin...&quot;</span>);<br>    sleep(<span class="hljs-number">2</span>);<br>    latch.countDown();<br>    log.debug(<span class="hljs-string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());<br>&#125;);<br>service.submit(()-&gt;&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        log.debug(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>        latch.await();<br>        log.debug(<span class="hljs-string">&quot;wait end...&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">22</span>:<span class="hljs-number">50</span>:<span class="hljs-number">55.958</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [main] - waiting...<br><span class="hljs-number">22</span>:<span class="hljs-number">50</span>:<span class="hljs-number">55.958</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-0</span>] - <span class="hljs-keyword">begin</span>...<br><span class="hljs-number">22</span>:<span class="hljs-number">50</span>:<span class="hljs-number">55.958</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-1</span>] - <span class="hljs-keyword">begin</span>...<br><span class="hljs-number">22</span>:<span class="hljs-number">50</span>:<span class="hljs-number">55.958</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-2</span>] - <span class="hljs-keyword">begin</span>...<br><span class="hljs-number">22</span>:<span class="hljs-number">50</span>:<span class="hljs-number">56.963</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-0</span>] - <span class="hljs-keyword">end</span>...<span class="hljs-number">2</span><br><span class="hljs-number">22</span>:<span class="hljs-number">50</span>:<span class="hljs-number">57.463</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-2</span>] - <span class="hljs-keyword">end</span>...<span class="hljs-number">1</span><br><span class="hljs-number">22</span>:<span class="hljs-number">50</span>:<span class="hljs-number">57.964</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [Thread<span class="hljs-number">-1</span>] - <span class="hljs-keyword">end</span>...<span class="hljs-number">0</span><br><span class="hljs-number">22</span>:<span class="hljs-number">50</span>:<span class="hljs-number">57.964</span> <span class="hljs-keyword">c</span>.TestCountDownLatch [main] - wait <span class="hljs-keyword">end</span>...<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h3><p>模拟王者农药多人游戏加载进度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>, (r) -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;t&quot;</span> + num.getAndIncrement());<br>&#125;);<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">10</span>);<br>String[] all = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">Random</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> j;<br>    service.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(r.nextInt(<span class="hljs-number">100</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            &#125;<br>            all[x] = Thread.currentThread().getName() + <span class="hljs-string">&quot;(&quot;</span> + (i + <span class="hljs-string">&quot;%&quot;</span>) + <span class="hljs-string">&quot;)&quot;</span>;<br>            System.out.print(<span class="hljs-string">&quot;\r&quot;</span> + Arrays.toString(all));<br>        &#125;<br>        latch.countDown();<br>    &#125;);<br>&#125;<br>latch.await();<br>System.out.println(<span class="hljs-string">&quot;\n游戏开始...&quot;</span>);<br>service.shutdown();<br></code></pre></td></tr></table></figure><p>结果</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">[t0(<span class="hljs-number">100</span>%), t1(<span class="hljs-number">100</span>%), t2(<span class="hljs-number">100</span>%), t3(<span class="hljs-number">100</span>%), t4(<span class="hljs-number">100</span>%), t5(<span class="hljs-number">100</span>%), t6(<span class="hljs-number">100</span>%), t7(<span class="hljs-number">100</span>%), t8(<span class="hljs-number">100</span>%), t9(<span class="hljs-number">100</span>%)]<br>游戏开始...<br><br>Process finished with <span class="hljs-keyword">exit</span> code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h3><p>多个远程接口调用</p><img src="/posts/18ad812a/image-20200911225323980.png" alt="image-20200911225323980" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RestTemplate</span> <span class="hljs-variable">restTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RestTemplate</span>();<br>log.debug(<span class="hljs-string">&quot;begin&quot;</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">4</span>);<br>Future&lt;Map&lt;String,Object&gt;&gt; f1 = service.submit(() -&gt; &#123;<br>    Map&lt;String, Object&gt; response = restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/order/&#123;1&#125;&quot;</span>, Map.class, <span class="hljs-number">1</span>);<br>    latch.countDown();<br>    <span class="hljs-keyword">return</span> response;<br>&#125;);<br>Future&lt;Map&lt;String, Object&gt;&gt; f2 = service.submit(() -&gt; &#123;<br>    Map&lt;String, Object&gt; response = restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="hljs-number">1</span>);<br>    latch.countDown();<br>    <span class="hljs-keyword">return</span> response;<br>&#125;);<br>Future&lt;Map&lt;String, Object&gt;&gt; f3 = service.submit(() -&gt; &#123;<br>    Map&lt;String, Object&gt; response = restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/product/&#123;1&#125;&quot;</span>, Map.class, <span class="hljs-number">2</span>);<br>    latch.countDown();<br>    <span class="hljs-keyword">return</span> response;<br>&#125;);<br>Future&lt;Map&lt;String, Object&gt;&gt; f4 = service.submit(() -&gt; &#123;<br>    Map&lt;String, Object&gt; response = restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/logistics/&#123;1&#125;&quot;</span>, Map.class, <span class="hljs-number">1</span>);<br>    latch.countDown();<br>    <span class="hljs-keyword">return</span> response;<br>&#125;);<br><br>latch.await();<br>log.debug(<span class="hljs-string">&quot;执行完毕&quot;</span>);<br>service.shutdown();<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CountDownLatch-应用&quot;&gt;&lt;a href=&quot;#CountDownLatch-应用&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch 应用&quot;&gt;&lt;/a&gt;CountDownLatch 应用&lt;/h1&gt;&lt;h2 id=&quot;应用&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程基础集合体系概述</title>
    <link href="https://blog.yahyav2rayssr.top/posts/ff94c717/"/>
    <id>https://blog.yahyav2rayssr.top/posts/ff94c717/</id>
    <published>2023-04-16T15:47:56.056Z</published>
    <updated>2023-04-16T15:47:56.056Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程集合体系概述"><a href="#线程集合体系概述" class="headerlink" title="线程集合体系概述"></a>线程集合体系概述</h2><img src="/posts/ff94c717/image-20200911233458814.png" alt="image-20200911233458814" style="zoom:33%;"><img src="/posts/ff94c717/image-20200911234147713.png" alt="image-20200911234147713" style="zoom:33%;"><p>List 集合</p><ul><li>CopyOnWriteArrayList</li></ul><p>Set 集合</p><ul><li>CopyOnWriteArraySet</li><li>ConcurrentSkipListSet</li></ul><p>Map 集合</p><ul><li>ConcurrentMap</li><li>ConcurrentHashMap</li><li>ConcurrentSkipListMap</li><li>ConcurrentNavigableMap</li></ul><p>Queue 队列</p><ul><li>queue<ul><li>ConcurrentLinkedQueue</li><li>ArrayBlockingQueue</li><li>PriorityBlockingQueue</li><li>LinkedBlockingQueue</li></ul></li><li>deque<ul><li>ConcurrentLinkedDeque</li><li>ForwardingBlockingDeque</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;线程集合体系概述&quot;&gt;&lt;a href=&quot;#线程集合体系概述&quot; class=&quot;headerlink&quot; title=&quot;线程集合体系概述&quot;&gt;&lt;/a&gt;线程集合体系概述&lt;/h2&gt;&lt;img src=&quot;/posts/ff94c717/image-20200911233458814</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程池详解</title>
    <link href="https://blog.yahyav2rayssr.top/posts/cf2a801/"/>
    <id>https://blog.yahyav2rayssr.top/posts/cf2a801/</id>
    <published>2023-04-16T15:47:41.225Z</published>
    <updated>2023-04-16T15:47:41.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程池详解"><a href="#线程池详解" class="headerlink" title="线程池详解"></a>线程池详解</h1><h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>步骤：</p><ol><li><p>线程池本身就是一个生产者、消费者的模型</p></li><li><p>定义一个双向队列</p></li><li><p>使用ReetrantLock一把锁对队列中的进行存取操作</p></li><li><p>同时定义一个Set存储线程集合，消费请求过来的任务，处理不过来的任务就放在双向队列里面</p></li><li><p>线程池可以设置成如下策略</p><ol><li>死等</li><li>带超时等待</li><li>让调用者放弃任务执行</li><li>让调用者抛出异常</li><li>让调用者自己执行任务</li></ol></li></ol><p>take put<br>poll offer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">RejectPolicy</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">reject</span><span class="hljs-params">(BlockingQueue&lt;T&gt; queue, T task)</span>;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.ThreadPool&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPool</span> &#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">// 线程集合</span><br>    <span class="hljs-keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> coreSize;<br><br>    <span class="hljs-comment">// 获取任务时的超时时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> timeout;<br><br>    <span class="hljs-keyword">private</span> TimeUnit timeUnit;<br><br>    <span class="hljs-keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;<br><br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span><br>        <span class="hljs-comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span><br>        <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>            <span class="hljs-keyword">if</span>(workers.size() &lt; coreSize) &#123;<br>                <span class="hljs-type">Worker</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(task);<br>                log.debug(<span class="hljs-string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);<br>                workers.add(worker);<br>                worker.start();<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                taskQueue.tryPut(task, rejectPolicy);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> coreSize, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit, <span class="hljs-type">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;<br>        <span class="hljs-built_in">this</span>.coreSize = coreSize;<br>        <span class="hljs-built_in">this</span>.timeout = timeout;<br>        <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>        <span class="hljs-built_in">this</span>.taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingQueue</span>&lt;&gt;(queueCapcity);<br>        <span class="hljs-built_in">this</span>.rejectPolicy = rejectPolicy;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>        <span class="hljs-keyword">private</span> Runnable task;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span><span class="hljs-params">(Runnable task)</span> &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 执行任务</span><br>            <span class="hljs-comment">// 1) 当 task 不为空，执行任务</span><br>            <span class="hljs-comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span><br><span class="hljs-comment">//            while(task != null || (task = taskQueue.take()) != null) &#123;</span><br>            <span class="hljs-keyword">while</span>(task != <span class="hljs-literal">null</span> || (task = taskQueue.poll(timeout, timeUnit)) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;正在执行...&#123;&#125;&quot;</span>, task);<br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">synchronized</span> (workers) &#123;<br>                log.debug(<span class="hljs-string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="hljs-built_in">this</span>);<br>                workers.remove(<span class="hljs-built_in">this</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Slf4j(topic = &quot;c.BlockingQueue&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-comment">// 1. 任务队列</span><br>    <span class="hljs-keyword">private</span> Deque&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 2. 锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-comment">// 3. 生产者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">fullWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">// 4. 消费者条件变量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">emptyWaitSet</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-comment">// 5. 容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capcity;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capcity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capcity = capcity;<br>    &#125;<br><br>    <span class="hljs-comment">// 带超时阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将 timeout 统一转换为 纳秒</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 返回值是剩余时间</span><br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                    nanos = emptyWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 阻塞获取</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    emptyWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> queue.removeFirst();<br>            fullWaitSet.signal();<br>            <span class="hljs-keyword">return</span> t;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T task)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);<br>                    fullWaitSet.await();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 带超时时间阻塞添加</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(T task, <span class="hljs-type">long</span> timeout, TimeUnit timeUnit)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> timeUnit.toNanos(timeout);<br>            <span class="hljs-keyword">while</span> (queue.size() == capcity) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span>(nanos &lt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                    &#125;<br>                    log.debug(<span class="hljs-string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);<br>                    nanos = fullWaitSet.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>            queue.addLast(task);<br>            emptyWaitSet.signal();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> queue.size();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryPut</span><span class="hljs-params">(T task, RejectPolicy rejectPolicy)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span>(queue.size() == capcity) &#123;<br>                rejectPolicy.reject(<span class="hljs-built_in">this</span>, task);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                log.debug(<span class="hljs-string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);<br>                queue.addLast(task);<br>                emptyWaitSet.signal();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><img src="/posts/cf2a801/20200910173142.png" alt="image-20200910173142580" style="zoom:50%;"><img src="/posts/cf2a801/20200910173221.png" alt="image-20200910173221052" style="zoom: 33%;"><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><img src="/posts/cf2a801/20200910162453.png" alt="image-20200909233843627" style="zoom:33%;"><h2 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h2><img src="/posts/cf2a801/20200910162454.png" alt="image-20200909234657936" style="zoom:33%;"><img src="/posts/cf2a801/20200910162455.png" alt="image-20200910000418212" style="zoom:33%;"><img src="/posts/cf2a801/20200910162456.png" alt="image-20200909235941989" style="zoom:33%;"><h3 id="自定义线程池名称"><a href="#自定义线程池名称" class="headerlink" title="自定义线程池名称"></a>自定义线程池名称</h3><img src="/posts/cf2a801/20200910162457.png" alt="image-20200910000605879" style="zoom:33%;"><h2 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h2><img src="/posts/cf2a801/20200910162458.png" alt="image-20200910001431998" style="zoom:33%;"><img src="/posts/cf2a801/20200910162459.png" alt="image-20200910001641578" style="zoom:33%;"><h2 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h2><img src="/posts/cf2a801/20200910162502.png" alt="image-20200910003436272" style="zoom:33%;"><h2 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<br>                                   <span class="hljs-type">long</span> delay, TimeUnit unit);<br><br><br><span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable,</span><br><span class="hljs-params">                                       <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br><br><br><span class="hljs-comment">// 延迟一定时间固定周期执行，周期以【任务本身的耗时时间】为准</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<br>                                              <span class="hljs-type">long</span> initialDelay,<br>                                              <span class="hljs-type">long</span> period,<br>                                              TimeUnit unit);<br><br><br><span class="hljs-comment">// 延迟一定时间固定周期执行，周期以【任务本身的耗时时间 + dealy时间】为准</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<br>                                                 <span class="hljs-type">long</span> initialDelay,<br>                                                 <span class="hljs-type">long</span> delay,<br>                                                 TimeUnit unit);<br></code></pre></td></tr></table></figure><h2 id="异常处理方式"><a href="#异常处理方式" class="headerlink" title="异常处理方式"></a>异常处理方式</h2><p>要么在线程池处理逻辑里面使用 try catch 代码块主动捕捉进行</p><p>要么使用有返回值的 Callable 接口而不是使用 Runnable 接口</p><h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><img src="/posts/cf2a801/20200910162501.png" alt="image-20200910002651350" style="zoom:33%;"><p>shutdownNow() 的话会返回没有执行完的任务</p><img src="/posts/cf2a801/20200910162503.png" alt="image-20200910005735728" style="zoom:33%;"><h2 id="工作线程模式"><a href="#工作线程模式" class="headerlink" title="工作线程模式"></a>工作线程模式</h2><img src="/posts/cf2a801/20200910162504.png" alt="image-20200910010101886" style="zoom:33%;"><img src="/posts/cf2a801/20200910162505.png" alt="image-20200910010309884" style="zoom:33%;"><h2 id="异步模式之工作线程"><a href="#异步模式之工作线程" class="headerlink" title="异步模式之工作线程"></a>异步模式之工作线程</h2><img src="/posts/cf2a801/20200910162506.png" alt="image-20200910105349061" style="zoom:33%;"><img src="/posts/cf2a801/20200910162435.png" alt="image-20200910105431240" style="zoom:33%;"><img src="/posts/cf2a801/20200910162507.png" alt="image-20200910110157389" style="zoom:33%;"><h2 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h2><img src="/posts/cf2a801/20200910162508.png" alt="image-20200910111838872" style="zoom:33%;"><h3 id="Tomcat线程池"><a href="#Tomcat线程池" class="headerlink" title="Tomcat线程池"></a>Tomcat线程池</h3><img src="/posts/cf2a801/image-20200910161030785.png" alt="image-20200910161030785" style="zoom:33%;"><img src="/posts/cf2a801/image-20200910161729614.png" alt="image-20200910161729614" style="zoom:33%;"><img src="/posts/cf2a801/20200910162851.png" alt="image-20200910162851024" style="zoom:33%;"><img src="/posts/cf2a801/20200910162904.png" alt="image-20200910162904265" style="zoom:33%;"><img src="/posts/cf2a801/20200910163220.png" alt="image-20200910163206545" style="zoom:33%;"><img src="/posts/cf2a801/20200910163809.png" alt="image-20200910163809505" style="zoom:33%;"><h3 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><img src="/posts/cf2a801/20200910164236.png" alt="image-20200910164235894" style="zoom:33%;"><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><img src="/posts/cf2a801/20200910170741.png" alt="image-20200910170741244" style="zoom:33%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.TestForkJoin2&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestForkJoin2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br>        System.out.println(pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTask</span>(<span class="hljs-number">5</span>)));<br><br>        <span class="hljs-comment">// new MyTask(5)  5+ new MyTask(4)  4 + new MyTask(3)  3 + new MyTask(2)  2 + new MyTask(1)</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 1~n 之间整数的和</span><br><span class="hljs-meta">@Slf4j(topic = &quot;c.MyTask&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTask</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + n + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 如果 n 已经为 1，可以求得结果了</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, n);<br>            <span class="hljs-keyword">return</span> n;<br>        &#125;<br><br>        <span class="hljs-comment">// 将任务进行拆分(fork)</span><br>        <span class="hljs-type">AddTask1</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask1</span>(n - <span class="hljs-number">1</span>);<br>        t1.fork();<br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);<br><br>        <span class="hljs-comment">// 合并(join)结果</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> n + t1.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">17</span>:<span class="hljs-number">16</span>:<span class="hljs-number">11.291</span> c<span class="hljs-selector-class">.MyTask</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-1]</span> - <span class="hljs-built_in">fork</span>() <span class="hljs-number">5</span> + &#123;<span class="hljs-number">4</span>&#125;<br><span class="hljs-number">17</span>:<span class="hljs-number">16</span>:<span class="hljs-number">11.291</span> c<span class="hljs-selector-class">.AddTask</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-0]</span> - <span class="hljs-built_in">fork</span>() <span class="hljs-number">2</span> + &#123;<span class="hljs-number">1</span>&#125;<br><span class="hljs-number">17</span>:<span class="hljs-number">16</span>:<span class="hljs-number">11.291</span> c<span class="hljs-selector-class">.AddTask</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-2]</span> - <span class="hljs-built_in">fork</span>() <span class="hljs-number">4</span> + &#123;<span class="hljs-number">3</span>&#125;<br><span class="hljs-number">17</span>:<span class="hljs-number">16</span>:<span class="hljs-number">11.294</span> c<span class="hljs-selector-class">.AddTask</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-0]</span> - <span class="hljs-built_in">join</span>() <span class="hljs-number">1</span><br><span class="hljs-number">17</span>:<span class="hljs-number">16</span>:<span class="hljs-number">11.291</span> c<span class="hljs-selector-class">.AddTask</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-3]</span> - <span class="hljs-built_in">fork</span>() <span class="hljs-number">3</span> + &#123;<span class="hljs-number">2</span>&#125;<br><span class="hljs-number">17</span>:<span class="hljs-number">16</span>:<span class="hljs-number">11.294</span> c<span class="hljs-selector-class">.AddTask</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-0]</span> - <span class="hljs-built_in">join</span>() <span class="hljs-number">2</span> + &#123;<span class="hljs-number">1</span>&#125; = <span class="hljs-number">3</span><br><span class="hljs-number">17</span>:<span class="hljs-number">16</span>:<span class="hljs-number">11.294</span> c<span class="hljs-selector-class">.AddTask</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-3]</span> - <span class="hljs-built_in">join</span>() <span class="hljs-number">3</span> + &#123;<span class="hljs-number">2</span>&#125; = <span class="hljs-number">6</span><br><span class="hljs-number">17</span>:<span class="hljs-number">16</span>:<span class="hljs-number">11.295</span> c<span class="hljs-selector-class">.AddTask</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-2]</span> - <span class="hljs-built_in">join</span>() <span class="hljs-number">4</span> + &#123;<span class="hljs-number">3</span>&#125; = <span class="hljs-number">10</span><br><span class="hljs-number">17</span>:<span class="hljs-number">16</span>:<span class="hljs-number">11.295</span> c<span class="hljs-selector-class">.MyTask</span> <span class="hljs-selector-attr">[ForkJoinPool-1-worker-1]</span> - <span class="hljs-built_in">join</span>() <span class="hljs-number">5</span> + &#123;<span class="hljs-number">4</span>&#125; = <span class="hljs-number">15</span><br><span class="hljs-number">15</span><br></code></pre></td></tr></table></figure><img src="/posts/cf2a801/20200910172750.png" alt="image-20200910171741525" style="zoom:33%;"><p>改进</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddTask3</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br><br>    <span class="hljs-type">int</span> begin;<br>    <span class="hljs-type">int</span> end;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AddTask3</span><span class="hljs-params">(<span class="hljs-type">int</span> begin, <span class="hljs-type">int</span> end)</span> &#123;<br>        <span class="hljs-built_in">this</span>.begin = begin;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&quot;</span> + begin + <span class="hljs-string">&quot;,&quot;</span> + end + <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (begin == end) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125;&quot;</span>, begin);<br>            <span class="hljs-keyword">return</span> begin;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (end - begin == <span class="hljs-number">1</span>) &#123;<br>            log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);<br>            <span class="hljs-keyword">return</span> end + begin;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (end + begin) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-type">AddTask3</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask3</span>(begin, mid);<br>        t1.fork();<br>        <span class="hljs-type">AddTask3</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddTask3</span>(mid + <span class="hljs-number">1</span>, end);<br>        t2.fork();<br>        log.debug(<span class="hljs-string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> t1.join() + t2.join();<br>        log.debug(<span class="hljs-string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">17:26:23.768 c.AddTask [ForkJoinPool<span class="hljs-string">-1</span>-worker<span class="hljs-string">-3</span>] - join() 4 + 5 = 9<br>17:26:23.768 c.AddTask [ForkJoinPool<span class="hljs-string">-1</span>-worker<span class="hljs-string">-1</span>] - fork() &#123;1,3&#125; + &#123;4,5&#125; = ?<br>17:26:23.772 c.AddTask [ForkJoinPool<span class="hljs-string">-1</span>-worker<span class="hljs-string">-3</span>] - join() 3<br>17:26:23.768 c.AddTask [ForkJoinPool<span class="hljs-string">-1</span>-worker<span class="hljs-string">-0</span>] - join() 1 + 2 = 3<br>17:26:23.768 c.AddTask [ForkJoinPool<span class="hljs-string">-1</span>-worker<span class="hljs-string">-2</span>] - fork() &#123;1,2&#125; + &#123;3,3&#125; = ?<br>17:26:23.772 c.AddTask [ForkJoinPool<span class="hljs-string">-1</span>-worker<span class="hljs-string">-2</span>] - join() &#123;1,2&#125; + &#123;3,3&#125; = 6<br>17:26:23.772 c.AddTask [ForkJoinPool<span class="hljs-string">-1</span>-worker<span class="hljs-string">-1</span>] - join() &#123;1,3&#125; + &#123;4,5&#125; = 15<br>15<br></code></pre></td></tr></table></figure><img src="/posts/cf2a801/20200910172751.png" alt="image-20200910172527081" style="zoom:33%;">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;线程池详解&quot;&gt;&lt;a href=&quot;#线程池详解&quot; class=&quot;headerlink&quot; title=&quot;线程池详解&quot;&gt;&lt;/a&gt;线程池详解&lt;/h1&gt;&lt;h2 id=&quot;自定义线程池&quot;&gt;&lt;a href=&quot;#自定义线程池&quot; class=&quot;headerlink&quot; title=&quot;自</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="线程池" scheme="https://blog.yahyav2rayssr.top/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程基础</title>
    <link href="https://blog.yahyav2rayssr.top/posts/71aa5641/"/>
    <id>https://blog.yahyav2rayssr.top/posts/71aa5641/</id>
    <published>2023-04-16T15:46:53.358Z</published>
    <updated>2023-04-16T15:46:53.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="类与对象的区别"><a href="#类与对象的区别" class="headerlink" title="类与对象的区别"></a>类与对象的区别</h2><p>类是对某一类事物的描述，是抽象的，而对象是一个实实在在的个体，是类的一个实例。</p><h2 id="本线程与当前线程"><a href="#本线程与当前线程" class="headerlink" title="本线程与当前线程"></a>本线程与当前线程</h2><p>“本线程”表示this（以及this对应的线程的意思）。</p><p>“当前线程”则是指调用对象方法的线程。</p><p>举个例子：</p><p><code>public final void join() throws InterruptedException</code></p><p>让当前线程（调用join方法的线程）等待本线程（this）终止。</p><h2 id="start和run的区别"><a href="#start和run的区别" class="headerlink" title="start和run的区别"></a>start和run的区别</h2><h3 id="start"><a href="#start" class="headerlink" title="start() :"></a>start() :</h3><p>它的作用是启动一个新线程。<br> 通过start()方法来启动的新线程，处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行相应线程的run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。start()不能被重复调用。用start方法来启动线程，真正实现了多线程运行，即无需等待某个线程的run方法体代码执行完毕就直接继续执行下面的代码。这里无需等待run方法执行完毕，即可继续执行下面的代码，即进行了线程切换。</p><h3 id="run"><a href="#run" class="headerlink" title="run()   :"></a>run()   :</h3><p>run()就和普通的成员方法一样，可以被重复调用。<br> 如果直接调用run方法，并不会启动新线程！程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。<br> 总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</p><p>总结一下：</p><ol><li>start() 可以启动一个新线程，run()不能</li><li>start()不能被重复调用，run()可以</li><li>start()中的run代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用run方法必须等待其代码全部执行完才能继续执行下面的代码。</li><li>start() 实现了多线程，run()没有实现多线程。</li></ol><h2 id="Thread-currentThread-与this的区别"><a href="#Thread-currentThread-与this的区别" class="headerlink" title="Thread.currentThread()与this的区别"></a>Thread.currentThread()与this的区别</h2><p>Thread.currentThread()可以获取当前线程的引用，一般都是在没有线程对象又需要获得线程信息时通过Thread.currentThread()获取当前代码段所在线程的引用</p><p>this.XXX()调用的是当前对象的方法</p><h2 id="interrupt、interrupted-、isInterrupted-区别"><a href="#interrupt、interrupted-、isInterrupted-区别" class="headerlink" title="interrupt、interrupted 、isInterrupted 区别"></a>interrupt、interrupted 、isInterrupted 区别</h2><p>interrupt()：将调用该方法的对象所表示的线程标记一个停止标记，并不是真的停止该线程。 </p><p>interrupted()：获取当前线程的中断状态，并且会清除线程的状态标记。 是一个是静态方法。 </p><p>isInterrupted()：获取调用该方法的对象所表示的线程，不会清除线程的状态标记。</p><table><thead><tr><th>方法名</th><th>静态</th></tr></thead><tbody><tr><td>interrupted</td><td>√</td></tr><tr><td>isInterrupted</td><td>×</td></tr></tbody></table><h2 id="停止线程的方式"><a href="#停止线程的方式" class="headerlink" title="停止线程的方式"></a>停止线程的方式</h2><blockquote><p>前提都是要调用判断中断状态的interrupted()或者isInterrupted()方法</p></blockquote><ol><li>阻塞状态（sleep,wait等）</li><li>interrupt() + return</li><li>抛异常法</li></ol><h2 id="suspend-、resume"><a href="#suspend-、resume" class="headerlink" title="suspend()、resume()"></a>suspend()、resume()</h2><blockquote><p>暂停&#x2F;恢复线程</p></blockquote><h2 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a>isAlive()</h2><blockquote><p>判断线程是否在运行</p></blockquote><h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><blockquote><p>放弃当前的CPU资源</p></blockquote><h2 id="优先级（priority）"><a href="#优先级（priority）" class="headerlink" title="优先级（priority）"></a>优先级（priority）</h2><ul><li>继承性（可继承main或者父级的优先级）</li><li>规则性（优先级高执行的机会多）</li><li>随机性（优先级高不一定先执行）</li></ul><p><strong>表示优先级的静态字段</strong></p><ul><li>Thread.MIN_PRIORITY：表示最低优先级的值</li><li>Thread.NORM_PRIORITY：表示默认优先级的值</li><li>Thread.MAX_PRIORITY：表示最高优先级的值</li></ul><h2 id="Daemon守护进程"><a href="#Daemon守护进程" class="headerlink" title="Daemon守护进程"></a>Daemon守护进程</h2><p><code>public final void setDaemon(boolean on)</code></p><p>当on为true时，本线程（this）会变成守护进程。</p><p>如果本线程已经启动了，异常java.lang.IllegalThreadStateException会被抛出。</p><p>如果当前线程无法改变本线程（this），异常java.lang.SecurityException会被抛出。</p><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><blockquote><p>发生脏读的情况是在读取实例变量时，此值已经被其他线程更改过了。</p></blockquote><h2 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h2><blockquote><p>关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁是可以再次得到对象的锁的。这也证明在一个synchronized方法&#x2F;块的内部调用本类的其他synchronized方法&#x2F;块时，是永远可以得到锁的。</p></blockquote><ul><li>出现异常，锁自动释放</li><li>同步锁不能被子类继承</li></ul><h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><p>Semaphore、CountDownLatch、CyclicBarrier、Exchanger&lt;V&gt;都是用于线程同步的类。</p><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>Semaphore</td><td>计数信号量</td></tr><tr><td>CountDownLatch</td><td>让线程等待某个操作执行完指定次数的同步机制</td></tr><tr><td>CyclicBarrier</td><td>让多个线程在特定位置（屏障）等待的同步机制</td></tr><tr><td>Exchanger&lt;V&gt;</td><td>让两个线程交换对象的同步机制</td></tr></tbody></table><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>synchronized方法和synchronized(this)等效，都是对当前对象进行加锁；而synchronized(非this对象X)则是对某个对象进行加锁，即<strong>对象监视器锁</strong>。</p><p>synchronized可以使多个线程访问同一个资源具有同步性，而且它还具有将线程工作内存中的私有变量与公共内存中的变量同步的功能，即<strong>具有volatile同步的功能</strong>。</p><p>synchronized包含两大特性：</p><ul><li>互斥性</li><li>可见性</li></ul><p>synchronized(非this对象X)格式的写法是将X对象本身作为<strong>对象监视器</strong>，这样就可以得出以下三个结论：</p><ol><li>当多个线程同时执行synchronized(X){} 同步代码块呈同步效果。</li><li>当其他线程执行X对象中synchronized同步方法时呈同步效果。</li><li>当其他线程执行X对象方法里面的synchronized(this)代码块时也呈现同步效果。</li></ol><blockquote><p>synchronized关键字加到static静态方法上是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁。</p><p>Class锁可以对类的所有对象实例起作用，即锁定所有对象锁。</p><p>同步synchronized(XX.class)代码块的作用和synchronized static方法的作用一样。</p></blockquote><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote><p>volatile关键字的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。</p></blockquote><p>synchronized和volatile区别：</p><ol><li>关键字volatile是线程同步的轻量级实现，所以volatile<strong>性能</strong>肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized关键字的比率还是比较大的。</li><li>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。</li><li><strong>volatile可以保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，即保证多个线程之间访问资源的同步性</strong>，因为它会将私有内存和公共内存中的数据做同步。</li></ol><h2 id="等待-x2F-通知机制"><a href="#等待-x2F-通知机制" class="headerlink" title="等待&#x2F;通知机制"></a>等待&#x2F;通知机制</h2><ul><li>wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到被再次唤醒。</li><li>notify()方法可以随机唤醒等待队列中等待同一共享资源的一个线程，并使该线程退出等待队列，进入可运行状态，也就是notify()方法仅通知一个线程。</li><li>notifyAll()方法可以使所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这要取决于JVM虚拟机的实现。</li></ul><p>用一句话来总结一下wait和notify：wait使线程停止运行，而notify使停止的线程继续运行，notify()方法执行后并不立即释放锁，而是等同步代码块&#x2F;同步方法中的逻辑执行完才释放。</p><blockquote><p>如果调用wait()没有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕捉异常。</p></blockquote><blockquote><p>当interrupt方法遇到wait方法后会抛出异常，锁也会释放，即在执行同步代码块的过程中，<strong>遇到异常而导致线程终止，锁也会被释放</strong>。</p></blockquote><p><strong>每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列</strong>。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。</p><h2 id="线程的6种状态及切换"><a href="#线程的6种状态及切换" class="headerlink" title="线程的6种状态及切换"></a>线程的6种状态及切换</h2><img src="/posts/71aa5641/9.jpg" class><h3 id="初始状态NEW"><a href="#初始状态NEW" class="headerlink" title="初始状态NEW"></a>初始状态<code>NEW</code></h3><p>  实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p><h3 id="就绪状态RUNNABLE"><a href="#就绪状态RUNNABLE" class="headerlink" title="就绪状态RUNNABLE"></a>就绪状态<code>RUNNABLE</code></h3><img src="/posts/71aa5641/image-20200912223705497.png" alt="image-20200912223705497" style="zoom:33%;"><p>就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。</p><p>调用线程的start()方法，此线程进入就绪状态。</p><p>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</p><p>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。</p><p>锁池里的线程拿到对象锁后，进入就绪状态。</p><p>线程进入Runnable状态大体分为如下5种情况：</p><ul><li><p>调用sleep()方法后经过的时间超过了指定的休眠时间。</p></li><li><p>线程调用的阻塞IO已经返回，阻塞方法执行完毕。</p></li><li><p>线程成功地获得了试图同步的监视器。</p></li><li><p>线程正在等待某个通知，其他线程发出了通知。</p></li><li><p>处于挂起状态的线程调用resume恢复方法。</p></li></ul><h3 id="运行中状态RUNNING"><a href="#运行中状态RUNNING" class="headerlink" title="运行中状态RUNNING"></a>运行中状态<code>RUNNING</code></h3><blockquote><p><code>getState()</code>并没有<code>RUNNING</code>状态，<code>RUNNING</code>和<code>RUNNABLE</code>是合并在一块的。</p></blockquote><p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</p><h3 id="阻塞状态BLOCKED"><a href="#阻塞状态BLOCKED" class="headerlink" title="阻塞状态BLOCKED"></a>阻塞状态<code>BLOCKED</code></h3><p>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态，Blocked状态结束后，进入Runnable状态，等待系统重新分配资源。</p><p>出现阻塞的情况大致分为如下5种：</p><ul><li><p>线程调用sleep方法，主动放弃占用的处理器资源。</p></li><li><p>线程调用了阻塞式IO方法，在该方法返回前，该线程被阻塞。</p></li><li><p>线程识图获得一个同步监视器，但该同步监视器正被其他线程所持有。</p></li><li><p>线程等待某个通知。</p></li><li><p>程序调用了suspend方法将该线程挂起。此方法容易导致死活，尽量避免使用该方法。</p></li></ul><h3 id="等待WAITING"><a href="#等待WAITING" class="headerlink" title="等待WAITING"></a>等待<code>WAITING</code></h3><blockquote><p>有可能被这些方法调用</p><ul><li><strong>Object.wait</strong></li><li>Thread.join</li><li>LockSupport.park</li></ul></blockquote><p>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p><h3 id="超时等待TIMED-WAITING"><a href="#超时等待TIMED-WAITING" class="headerlink" title="超时等待TIMED_WAITING"></a>超时等待<code>TIMED_WAITING</code></h3><blockquote><p>有可能被这些方法调用</p><ul><li>Object.wait</li><li>Thread.join</li><li><strong>Thread.sleep</strong></li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul></blockquote><p>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p><h3 id="终止状态TERMINATED"><a href="#终止状态TERMINATED" class="headerlink" title="终止状态TERMINATED"></a>终止状态<code>TERMINATED</code></h3><p>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。<br>在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>join的作用是使所属的线程对象X正常执行run()方法中的任务，而使当前线程Z进行无限制的阻塞，等待线程X销毁后再继续执行线程Z后面的代码。</p><h2 id="join和synchronized的区别"><a href="#join和synchronized的区别" class="headerlink" title="join和synchronized的区别"></a>join和synchronized的区别</h2><p>join具有使线程排队运行的作用，有些类似同步的运行效果。join于synchronized的区别是：join在内部使用wait()方法进行等待，而synchronized关键字使用的是“对象监视器”原理作为同步。</p><h2 id="join-long-与sleep-long-的区别"><a href="#join-long-与sleep-long-的区别" class="headerlink" title="join(long)与sleep(long)的区别"></a>join(long)与sleep(long)的区别</h2><p>join(long)的功能在内部是使用wait(long)方法来实现的，所以join(long)方法具有释放锁的特点，而Thread.sleep(long)方法却不释放锁。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p>ThreadLocal设置初始化值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalExt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;设置初始化值&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>InheritableThreadLocal类可以让子线程从父线程中取得值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalExt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InheritableThreadLocal</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;设置初始化值&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">childValue</span><span class="hljs-params">(Object parentValue)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;子类值&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock功能上比synchronized关键字更加的强大，比如具有<strong>嗅探锁定、多路分支通知</strong>等功能，而且在使用上也比synchronized更加的灵活。</p><p>关键字synchronized于wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知模式，类ReentrantLock也可以实现同样的功能，但需要借助于Condition对象，从而实现有选择性的线程通知。</p><p><strong>Condition等待&#x2F;通知方法和synchronized等待&#x2F;通知方法的区别</strong>：</p><ul><li>Object类中的wait()方法相当于Condition类中的await()方法。</li><li>Object类中的wait(long timeout)方法相当于Condition类中的await(long time, TimeUnit unit)方法。</li><li>Object类中的notify()方法相当于Condition类中的signal()方法。</li><li>Object类中的notifyAll()方法相当于Condition类中的signalAll()方法。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">conditionA</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">conditionB</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            conditionA.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll_A</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            conditionA.signalAll();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="公平锁于非公平锁"><a href="#公平锁于非公平锁" class="headerlink" title="公平锁于非公平锁"></a>公平锁于非公平锁</h3><p>公平与非公平锁：锁Lock分为“公平锁”和“非公平锁”，<strong>公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的</strong>，即先来先得的FIFO先进先出顺序。而<strong>非公平锁就是一种获取锁的抢占机制，是随机获得锁的</strong>，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果也就是不公平的了。</p><p><strong>在默认的情况下，ReentrantLock类使用的是非公平锁。</strong></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">private</span> ReentrantLock lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Service</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isFair)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(isFair);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReentrantLock对象方法"><a href="#ReentrantLock对象方法" class="headerlink" title="ReentrantLock对象方法"></a>ReentrantLock对象方法</h3><h4 id="getHoldCount"><a href="#getHoldCount" class="headerlink" title="getHoldCount"></a>getHoldCount</h4><blockquote><p><strong>int getHoldCount()的作用是查询当前线程保持此锁定的个数</strong>，也就是调用lock()方法的次数。</p></blockquote><h4 id="getQueueLength"><a href="#getQueueLength" class="headerlink" title="getQueueLength"></a>getQueueLength</h4><blockquote><p><strong>int getQueueLength()的作用是返回正等待获取此锁定的线程估计数</strong>，比如有5个线程，1个线程首先执行await()方法，那么在调用getQueue()方法后返回值是4，说明有4个线程同时在等待lock的释放。</p></blockquote><h4 id="getWaitQueueLength"><a href="#getWaitQueueLength" class="headerlink" title="getWaitQueueLength"></a>getWaitQueueLength</h4><blockquote><p><strong>int getWaitQueueLength(Condition condition)的作用是返回等待与此锁定相关的给定条件Conditin的线程估计数</strong>，比如有5个线程，每个线程都执行了同一个condition的await方法，则调用getWaitQueueLength(Condition condition)方法时返回的int值是5。</p></blockquote><h4 id="hasQueuedThread"><a href="#hasQueuedThread" class="headerlink" title="hasQueuedThread"></a>hasQueuedThread</h4><blockquote><p>boolean hasQueueThread(Thread thread)的作用是查询指定的线程是否正在等待获取此锁定。</p></blockquote><h4 id="hasQueuedThreads"><a href="#hasQueuedThreads" class="headerlink" title="hasQueuedThreads"></a>hasQueuedThreads</h4><blockquote><p>boolean hasQueueThreads()的作用是获取指定的锁是否有线程正在等待调用。</p></blockquote><h4 id="hasWaiters"><a href="#hasWaiters" class="headerlink" title="hasWaiters"></a>hasWaiters</h4><blockquote><p>boolean hasWaiters(Condition condition)的作用是查询是否有线程正在等待与此锁定有关的condition条件；getWaitQueueLength(Condition condition)可以获取到等待的线程的数量。</p></blockquote><h4 id="isFair"><a href="#isFair" class="headerlink" title="isFair"></a>isFair</h4><blockquote><p>boolean isFair()的作用是判断是不是公平锁。</p></blockquote><h4 id="isHeldByCurrentThread"><a href="#isHeldByCurrentThread" class="headerlink" title="isHeldByCurrentThread"></a>isHeldByCurrentThread</h4><blockquote><p>boolean isHeldByCurrentThread()的作用是查询当前线程是否保持此锁定。</p></blockquote><h4 id="isLocked"><a href="#isLocked" class="headerlink" title="isLocked"></a>isLocked</h4><blockquote><p>boolean isLocked()的作用是查询此锁定是否由任意线程保持。</p></blockquote><h4 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h4><blockquote><p>void lockInterruptibly()的作用是：如果当前线程未被中断，则获取锁定，如果已经被中断<strong>interrupt</strong>则出现异常。(对比lock()方法)</p></blockquote><h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h4><blockquote><p>boolean tryLock()的作用是，仅在调用时锁定未被另一个线程保持的情况下，才获取改锁定。</p><p>boolean tryLock(long timeout, TimeUnit unit)的作用是，如果锁定在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定。</p></blockquote><h3 id="Condition对象方法"><a href="#Condition对象方法" class="headerlink" title="Condition对象方法"></a>Condition对象方法</h3><blockquote><p>使用好Condition对象可以对线程执行的业务进行排序规划（<strong>即利用主内存唯一变量做判断控制，如果不满足条件当当前线程停留在await状态</strong>）。</p></blockquote><h4 id="awaitUninterruptibly"><a href="#awaitUninterruptibly" class="headerlink" title="awaitUninterruptibly"></a>awaitUninterruptibly</h4><blockquote><p>void awaitUninterruptibly()的作用是等待时忽略中断，不至于类似于await()那样被中断后会抛出异常。</p></blockquote><h4 id="awaitUntil"><a href="#awaitUntil" class="headerlink" title="awaitUntil"></a>awaitUntil</h4><blockquote><p>boolean awaitUntil(Date deadline)的作用是：等待到特定日期，而且<strong>线程在等待时间到达之前，可以被其他线程唤醒</strong>。</p></blockquote><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>类ReentrantLock具有完全互斥排他的效果，即同一时间只有一个线程在执行ReentrantLock()方法后面的任务。这样做虽然保证了实例变量的线程安全性，但效率是非常低下的。所以在JDK中提供了一种读写锁ReentrantReadWriteLock类，使用他可以加快运行效率，在某些不需要操作实例的变量中，完全可以使用读写锁ReentrantReadWriteLock来提升该方法的代码运行速度。</p><p>读写锁表示也有两个锁，一个是读操作相关的锁，也成为共享锁；另一个是写操作相关的锁，也叫排它锁。也就是多个读锁之间不互斥，读锁和写锁互斥、写锁和写锁互斥。在没有线程Thread进行写入操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的Thread只有在获取写锁之后才能进行写入操作。<strong>即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作</strong>；体现在读读共享，写写互斥，读写互斥，写读互斥。</p><h2 id="定时器Timer"><a href="#定时器Timer" class="headerlink" title="定时器Timer"></a>定时器Timer</h2><p>在JDK库中，Timer类主要负责计划任务的功能，也就是在指定的时间开始执行某一个任务；抽象类为TimerTask。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Timer</span> <span class="hljs-variable">timer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(); <span class="hljs-comment">//非守护线程</span><br><span class="hljs-type">Timer</span> <span class="hljs-variable">timer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 守护线程</span><br></code></pre></td></tr></table></figure><p>Timmer执行定时任务如果计划时间早于当前时间，则会提前执行task任务。</p><blockquote><p>TimmerTask是以队列的方式一个一个被顺序的执行，所以执行的时间有可能和预期的时间不一致，因为前面的任务有可能消耗的时间较长，则后面的任务运行的时间也被延后。</p></blockquote><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><blockquote><p>Timer类的<strong>cancel()方法有时不一定会停止计划任务，而是正常执行</strong>，原因是Timer类中的cancel()方法有时并没有争抢到queue锁，而让TimerTask类中的任务正常执行。</p></blockquote><ul><li><p><strong>TimerTask类的cancel()方法</strong></p><p>TimerTask类的cancel()方法的作用是讲自身从任务队列中进行清除。</p></li><li><p><strong>Timer类的cancel()方法</strong></p><p>和TimerTask类中的cancel方法()清除自身不同，Timer类中的cancel()方法是将自身队列中全部的任务进行清空。</p></li></ul><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><ul><li><p><strong>schedule(TimerTask task, Date firstTime, long period)</strong></p><p>该方法的作用是在指定的日期之后按指定的间隔周期，无限循环地执行某一任务。</p></li><li><p><strong>schedule(TimerTask task, long delay, long period)</strong></p><p>该方法的作用是以执行schedule(TimerTask task, long delay, long period)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数，再以某一间隔时间无限次数地执行某一任务。</p></li></ul><h3 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h3><ul><li><p><strong>scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</strong></p><p>该方法的作用是在指定的日期之后按指定的间隔周期，无限循环地执行某一任务，同schedule的区别在于有没有<strong>追赶性</strong>。</p></li><li><p><strong>scheduleAtFixedRate(TimerTask task, long delay, long period)</strong></p><p>该方法的作用是以执行scheduleAtFixedRate(TimerTask task, long delay, long period)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数，再以某一间隔时间无限次数地执行某一任务。</p></li></ul><h3 id="追赶性"><a href="#追赶性" class="headerlink" title="追赶性"></a>追赶性</h3><p>如果定时任务计划的时间早于当前时间，schedule方法在提前时间段区间之间的所对应的Task任务就被取消掉，不被执行了，这就是Task任务不追赶；而scheduleAtFixedRate方法在提前时间段区间之间的所对应的Task任务就被“补充性”地执行，直到提前时间区间段的时间区间补充执行完毕，这就是Task任务追赶特性。</p><h2 id="单例模式与多线程"><a href="#单例模式与多线程" class="headerlink" title="单例模式与多线程"></a>单例模式与多线程</h2><h3 id="俄汉模式、懒汉模式"><a href="#俄汉模式、懒汉模式" class="headerlink" title="俄汉模式、懒汉模式"></a>俄汉模式、懒汉模式</h3><h4 id="立即加载-x2F-饿汉模式"><a href="#立即加载-x2F-饿汉模式" class="headerlink" title="立即加载&#x2F;饿汉模式"></a>立即加载&#x2F;饿汉模式</h4><p>什么是立即加载？立即加载就是使用类的时候已经将对象创建完毕，常见的实现方法就是直接new实例化。而立即加载从中文的语境来看，有“着急”、“急迫”的含义，所以也称为“饿汉模式”。</p><h4 id="延迟加载-x2F-懒汉模式"><a href="#延迟加载-x2F-懒汉模式" class="headerlink" title="延迟加载&#x2F;懒汉模式"></a>延迟加载&#x2F;懒汉模式</h4><p>什么是延迟加载？延迟加载就是在调用get()方法时实例才被创建，常见的实现办法就是在get()方法中进行实例化。而延迟加载从中文的语境来看，是“缓慢”、“不急迫”的含义，所以也称为“懒汉模式”。</p><p>饿汉模式应用于多线程会产生很大的性能问题，推荐多线程一般都用的懒汉模式，大概分为以下几种：</p><h3 id="DCL双检查-机制"><a href="#DCL双检查-机制" class="headerlink" title="DCL双检查 机制"></a>DCL双检查 机制</h3><p>DCL双检查机制就是在同步代码块调用之前检查一遍，再在同步代码块内部再检查一遍，即使用volatile保证主内存变量一致，同时对逻辑代码块进行加锁，作为一种双重保险的保障。</p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> MyObject myObject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObject</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 使用双检查机制来解决问题，既保证了不需要同步代码的异步执行型</span><br>    <span class="hljs-comment">// 又保证了单例的效果</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyObject <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (myObject != <span class="hljs-literal">null</span>) &#123;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 模拟在创建对象之前做一些准备性的工作</span><br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>                <span class="hljs-keyword">synchronized</span> (MyObject.class) &#123;<br>                    <span class="hljs-keyword">if</span> (myObject == <span class="hljs-literal">null</span>) &#123;<br>                        myObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> myObject;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用静态内置类"><a href="#使用静态内置类" class="headerlink" title="使用静态内置类"></a>使用静态内置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;<br>    <span class="hljs-comment">// 内部类方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObjectHandler</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MyObject</span> <span class="hljs-variable">myOjbect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObject</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyObject <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MyObjectHandler.myOjbect;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="序列化与反序列化的单例模式"><a href="#序列化与反序列化的单例模式" class="headerlink" title="序列化与反序列化的单例模式"></a>序列化与反序列化的单例模式</h3><blockquote><p>readResolve()的实现是关键所在，可以从ObjectInputStream中的readObject进行延伸，代码如下所示：</p></blockquote><img src="/posts/71aa5641/10.png" alt="image-20200624193252720" style="zoom:50%;"><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">4037244617173811007L</span>;<br><br>    <span class="hljs-comment">// 内部类方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObjectHandler</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MyObject</span> <span class="hljs-variable">myOjbect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObject</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyObject <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MyObjectHandler.myOjbect;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了readResolve方法！ &quot;</span>);<br>        <span class="hljs-keyword">return</span> MyObjectHandler.myOjbect;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveAndRead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> MyObject.getInstance();<br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fosRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;myObjectFile.txt&quot;</span>));<br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oosRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fosRef);<br>            oosRef.writeObject(myObject);<br>            oosRef.close();<br>            fosRef.close();<br>            System.out.println(myObject.hashCode());<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fisRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;myObjectFile.txt&quot;</span>));<br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">iosRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fisRef);<br>            <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> (MyObject)iosRef.readObject();<br>            iosRef.close();<br>            fisRef.close();<br>            System.out.println(myObject.hashCode());<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用static代码块实现单例模式"><a href="#使用static代码块实现单例模式" class="headerlink" title="使用static代码块实现单例模式"></a>使用static代码块实现单例模式</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MyObject instance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObject</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyObject <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用enum枚举数据类型实现单例模式"><a href="#使用enum枚举数据类型实现单例模式" class="headerlink" title="使用enum枚举数据类型实现单例模式"></a>使用enum枚举数据类型实现单例模式</h3><p>枚举enum和静态代码块的特性相似，在使用枚举类时，构造方法会被自动调用。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyObject</span> &#123;<br>    connectionFactory;<br>    <span class="hljs-keyword">private</span> Connection connection;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyEnumSingleTon</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;调用了MyObject的构造 &quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:sqlserver://localhost:1079;databaseName=ghydb&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sa&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">driverName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>;<br>            Class.forName(driverName);<br>            connection = DriverManager.getConnection(url, username, password);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MyEnumSingleTon.connectionFactory.getConnection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程。</p><p>线程组的作用是：可以批量的管理线程或线程组对象，有效地对线程或线程组对象进行组织。</p><blockquote><p><strong>线程组拥有自动归属特性，即自动归到当前线程组中。</strong></p><p>优先：通过将线程归属到线程组中，当调用线程组<code>ThreadGroup的interrupt()</code>方法时，可以将该组中的所有正在运行的线程批量停止。</p></blockquote><h3 id="一级关联"><a href="#一级关联" class="headerlink" title="一级关联"></a>一级关联</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;姚煜明的线程组&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="多级关联"><a href="#多级关联" class="headerlink" title="多级关联"></a>多级关联</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">mainGroup</span> <span class="hljs-operator">=</span> Thread.currentThread().getThreadGroup();<br><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(mainGroup, <span class="hljs-string">&quot;A&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="递归与非递归取得组内对象"><a href="#递归与非递归取得组内对象" class="headerlink" title="递归与非递归取得组内对象"></a>递归与非递归取得组内对象</h3><blockquote><p>默认是递归获取。</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadGroup[] listGroup1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>[Thread.currentThread().activeCount()];<br>Thread.currentThread().getThreadGroup().enumerate(listGroup1, <span class="hljs-literal">true</span>);<br><br>ThreadGroup[] listGroup2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>[Thread.currentThread().activeCount()];<br>Thread.currentThread().getThreadGroup().enumerate(listGroup2, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h2 id="线程出现异常的处理"><a href="#线程出现异常的处理" class="headerlink" title="线程出现异常的处理"></a>线程出现异常的处理</h2><h3 id="setUncaughtExceptionHandler方法"><a href="#setUncaughtExceptionHandler方法" class="headerlink" title="setUncaughtExceptionHandler方法"></a>setUncaughtExceptionHandler方法</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadA</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>();<br>t1.setName(<span class="hljs-string">&quot;线程T1&quot;</span>);<br>t1.setUncaughtExceptionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程：&quot;</span> + t.getName() + <span class="hljs-string">&quot; 出现了异常： &quot;</span>);<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br>t1.start();<br></code></pre></td></tr></table></figure><blockquote><p>在默认的情况下，线程组的一个线程出现异常不会影响其他线程的运行。</p><p>如果想出现异常停止所有的线程，<strong>前提必须调用父类的<code>uncaughtException(t, e)</code>方法，</strong>可以如下操作：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadGroup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadGroup</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThreadGroup</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>        <span class="hljs-built_in">super</span>.uncaughtException(t, e);<br>        <span class="hljs-built_in">this</span>.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Executor和ExexcutorService"><a href="#Executor和ExexcutorService" class="headerlink" title="Executor和ExexcutorService"></a>Executor和ExexcutorService</h2><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>Executor</td><td>提供了用于执行Runnable对象的execute方法的接口</td></tr><tr><td>ExecutorService</td><td>提供了用于关闭自己的shutdown方法的Executor接口</td></tr><tr><td>ScheduledExecutorService</td><td>在一定时间后或周期性地执行提交上来的命令的ExecutorService的接口</td></tr><tr><td>AbstractExecutorService</td><td>ExecutorService的默认实现类</td></tr><tr><td>ThreadPoolExecutor</td><td>使用了线程池的ExecutorService的实现类</td></tr><tr><td>ScheduledThreadPoolExecutor</td><td>ScheduledExecutorService的典型的实现类</td></tr></tbody></table><h2 id="Future和FutureTask"><a href="#Future和FutureTask" class="headerlink" title="Future和FutureTask"></a>Future和FutureTask</h2><p><code>java.util.concurrent.Future</code>是表示异步处理的执行结果的接口。该接口的主要实现是FutureTask类。</p><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>Future&lt;V&gt;</td><td>表示异步处理的结果的接口，该接口是ExecutorService的返回值</td></tr><tr><td>ScheduledFuture</td><td>ScheduledExecutorService的处理结果</td></tr><tr><td>FutureTask&lt;V&gt;</td><td>可以调用Runnable对象的run方法或是Callable对象的call方法的任务。该类是Future接口的典型的实现类</td></tr><tr><td>CompletionService&lt;V&gt;</td><td>将异步任务的创建与使用任务处理结果分离的任务</td></tr><tr><td>ExecutorCompletionService&lt;V&gt;</td><td>面向Executor的CompletionService</td></tr></tbody></table><img src="/posts/71aa5641/84.png" alt="111111" style="zoom: 67%;"><h2 id="java-util-concurrent-locks包"><a href="#java-util-concurrent-locks包" class="headerlink" title="java.util.concurrent.locks包"></a>java.util.concurrent.locks包</h2><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>Lock</td><td>可以创建出与synchronized的锁具有不同结构的锁的接口</td></tr><tr><td>ReadWriteLock</td><td>用于创建Read-Write Lock的接口</td></tr><tr><td>ReentrantLock</td><td>可以被多次获取的互斥锁</td></tr><tr><td>ReentrantReadWriteLock</td><td>具有与ReentrantLock类似功能的ReadWriteLock的实现类</td></tr><tr><td>ReentrantReadWriteLock.ReadLock</td><td>通过ReentrantReadWriteLock.readLock方法获取的Lock对象</td></tr><tr><td>ReentrantReadWriteLock</td><td>通过ReentrantReadWriteLock.writeLock方法获取的Lock对象</td></tr><tr><td>Condition</td><td>用于与Lock组合使用，创建线程的等待队列的接口</td></tr><tr><td>AbstractQueueSynchronizer</td><td>用于创建一个以FIFO方式让线程等待的队列的框架</td></tr><tr><td>LockSupport</td><td>制作锁和同步机制的基本原语</td></tr></tbody></table><h2 id="java-util-concurrent-atomic包"><a href="#java-util-concurrent-atomic包" class="headerlink" title="java.util.concurrent.atomic包"></a>java.util.concurrent.atomic包</h2><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>AtomicBoolean</td><td>以原子方式操作的boolean类型的变量</td></tr><tr><td>AtomicInteger</td><td>以原子方式操作的int类型的变量</td></tr><tr><td>AtomicLong</td><td>以原子方式操作的long类型的变量</td></tr><tr><td>AtomicReference&lt;V&gt;</td><td>以原子方式操作的对象引用类型的变量</td></tr><tr><td>AtomicIntegerFieldUpdater&lt;T&gt;</td><td>以原子方式操作的int类型的字段</td></tr><tr><td>AtomicLongFieldUpdater&lt;T&gt;</td><td>以原子方式操作的long类型的字段</td></tr><tr><td>AtomicReferenceFieldUpdater&lt;T&gt;</td><td>以原子方式操作的引用类型的字段</td></tr><tr><td>AtomicIntegerArray</td><td>以原子方式操作的int类型的数组</td></tr><tr><td>AtomicLongArray</td><td>以原子方式操作的long类型的数组</td></tr><tr><td>AtomicReferenceArray&lt;E&gt;</td><td>以原子方式操作的对象引用类型的数组</td></tr><tr><td>AtomicMarkableReference&lt;E&gt;</td><td>以原子方式操作的带有标记的对象引用</td></tr><tr><td>AtomicStampedReference&lt;V&gt;</td><td>以原子方式操作的带有时间戳的对象引用</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程基础&quot;&gt;&lt;a href=&quot;#多线程基础&quot; class=&quot;headerlink&quot; title=&quot;多线程基础&quot;&gt;&lt;/a&gt;多线程基础&lt;/h1&gt;&lt;h2 id=&quot;类与对象的区别&quot;&gt;&lt;a href=&quot;#类与对象的区别&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="多线程" scheme="https://blog.yahyav2rayssr.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 基础</title>
    <link href="https://blog.yahyav2rayssr.top/posts/a019e08c/"/>
    <id>https://blog.yahyav2rayssr.top/posts/a019e08c/</id>
    <published>2023-04-16T14:13:45.201Z</published>
    <updated>2023-04-16T14:13:45.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote><p>注：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的</p></blockquote><p>如果在静态方法的声明中加上final，则表示该方法不会被子类的方法隐藏。</p><p>final参数不可以赋值，因为在调用方法时，已经对其赋值了。</p><p><strong>用final修饰的字符串就是在编译期可知的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lan&quot;</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;tao&quot;</span>;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b + <span class="hljs-string">&quot;2019&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面即使是引用拼接，由于编译期可知，执行效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lantao2019&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static方法：</p><ol><li>不可被子类重写（如果子类含有相同静态方法则与父类的静态方法无关）；</li><li>直接以类名调用，也可以使用实例调用(避免)；</li><li>没有this，因为不依赖于任何实例对象；</li><li>不能访问非静态成员变量与非静态成员方法；</li><li>static方法必须实现，也就是说他不能是抽象方法abstract；</li></ol><blockquote><p>使用情景：方法不需要访问对象状态，其所需参数均显示参数提供；只需要访问静态域；</p></blockquote><h2 id="List线程安全化"><a href="#List线程安全化" class="headerlink" title="List线程安全化"></a>List线程安全化</h2><h3 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList"></a>Collections.synchronizedList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>      ...<br>  <span class="hljs-keyword">synchronized</span> (list) &#123;<br>      <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.iterator(); <span class="hljs-comment">// Must be in synchronized block</span><br>      <span class="hljs-keyword">while</span> (i.hasNext())<br>          foo(i.next());<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>既然封装类内部已经加了对象锁，为什么外部还要加一层对象锁？</strong></p><p>看源码可知，Collections.synchronizedList中很多方法，比如equals,hasCode,get,set,add,remove,indexOf,lastIndexOf……</p><p>都添加了锁，但是List中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CopyIterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>这个方法没有加锁，不是线程安全的，所以如果要遍历，还是必须要在外面加一层锁。</p><p><strong>SynchronizedList和Vector最主要的区别</strong></p><ol><li>Vector扩容为原来的2倍长度，ArrayList扩容为原来1.5倍</li><li>SynchronizedList有很好的扩展和兼容功能。他可以将所有的List的子类转成线程安全的类。</li><li><strong>使用SynchronizedList的时候，进行遍历时要手动进行同步处理 。</strong></li><li>SynchronizedList可以指定锁定的对象。</li></ol><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList是ArrayList的线程安全版本，从他的名字可以推测，CopyOnWriteArrayList是在有写操作的时候会copy一份数据，然后写完再设置成新的数据。CopyOnWriteArrayList适用于读多写少的并发场景。</p><blockquote><h5 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h5><p>所谓写时复制（copy-on-write），是在对集合进行“写”操作时，在内部将数据结构全部复制一份的机制。使用这种机制后，即使在多个线程发生读写冲突时ConcurrentModificationException异常也不会被抛出。</p></blockquote><h2 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列与栈是相对的一种数据结构。只允许在一端进行插入操作，而在另一端进行删除操作的线性表。栈的特点是后进先出，而队列的特点是先进先出。队列的用处很大，但大多都是在其他的数据结构中，比如，树的按层遍历，图的广度优先搜索等都需要使用队列做为辅助数据结构。</p><h4 id="单向队列"><a href="#单向队列" class="headerlink" title="单向队列"></a>单向队列</h4><p>  单向队列比较简单，只能向队尾添加元素，从队头删除元素。</p><h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><p>  如果一个队列的头和尾都支持元素入队，出队，那么这种队列就称为双向队列，英文是Deque。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//插入（抛出异常）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-comment">//插入（返回特殊值）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-comment">//移除（抛出异常）</span><br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//移除（返回特殊值）</span><br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//检查（抛出异常）</span><br>    E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//检查（返回特殊值）</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue又叫做优先级队列，保存队列元素的顺序不是按照及加入队列的顺序，而是按照队列元素的大小进行重新排序。一句话概括，PriorityQueue使用了一个高效的数据结构：堆。底层是使用数组保存数据。还会进行排序，优先将元素的最小值存到队头。</p><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p>Deque接口是Queue接口子接口。它代表一个双端队列。</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>ArrayDeque使用数组实现的Deque;底层是数组，也是可以指定它的capacity,当然也可以不指定，默认长度是16，根据添加的元素个数，动态扩容。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是一种队列，一种可以在多线程环境下使用，并且支持阻塞等待的队列。也就是说，阻塞队列和一般的队列的区别就在于：</p><ol><li>多线程环境支持，多个线程可以安全的访问队列</li><li>支持生产和消费等待，多个线程之间互相配合，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线程就会阻塞直到队列不满。</li></ol><p>根据插入和取出两种类型的操作，具体分为下面一些类型：</p><table><thead><tr><th>操作类型</th><th>Throws Exception</th><th>Special Value</th><th>Timed out</th><th>Blocked</th></tr></thead><tbody><tr><td>插入</td><td>add(o)</td><td>offer(o)</td><td>offer(o, timeout, unit)</td><td>put(o)</td></tr><tr><td>取出(删除)</td><td>remove(o)</td><td>poll()</td><td>poll(timeout, unit)</td><td>take()</td></tr></tbody></table><ul><li>Throws Exception 类型的插入和取出在不能立即被执行的时候就会抛出异常。</li><li>Special Value 类型的插入和取出在不能被立即执行的情况下会返回一个特殊的值（true 或者 false）。</li><li>Blocked 类型的插入和取出操作在不能被立即执行的时候会阻塞线程直到可以操作的时候会被其他线程唤醒。</li><li>Timed out 类型的插入和取出操作在不能立即执行的时候会被阻塞一定的时候，如果在指定的时间内没有被执行，那么会返回一个特殊值。</li></ul><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><img src="/posts/a019e08c/51.jpg" class><p>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p><p><strong>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行</strong>，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。</p><p><strong>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例</strong>，<strong>而后者则会生成一个额外的Node对象</strong>。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其 <strong>对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能</strong>。 作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue是一个优先阻塞队列。所谓优先队列，就是每次从队队列里面获取到的都是队列中优先级最高的，对于优先级，PriorityBlockingQueue需要你为插入其中的元素类型提供一个Comparator，PriorityBlockingQueue使用这个Comparator来确定元素之间的优先级关系。</p><p>但需要注意的是<strong>PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong>。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>SynchronousQueue和前面分析的阻塞队列都不同，因为SynchronousQueue不存在容量的说法，任何插入操作都需要等待其他线程来消费，否则就会阻塞等待，也就是说，生产线程生产出一条数据之后就要等待消费者线程来将其消费掉，才能继续生产数据，否则就会阻塞等待消费。</p><h5 id="TransferQueue（公平模式）"><a href="#TransferQueue（公平模式）" class="headerlink" title="TransferQueue（公平模式）"></a>TransferQueue（公平模式）</h5><p>该队列可以创建生产者和消费者程序并协调消息从生产者传输到消费者。</p><p>该实现类似于<a href="https://blog.csdn.net/neweastsun/article/details/87907890">BlockingQueue</a>类，但其可以实现反压形式传输，即当生产者利用transfer()方法发送消息给消费者时，生产者将一直被阻塞，直到消息被使用为止。</p><h5 id="TransferStack（非公平模式）"><a href="#TransferStack（非公平模式）" class="headerlink" title="TransferStack（非公平模式）"></a>TransferStack（非公平模式）</h5><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>并编程中，一般需要用到安全的队列，如果要自己实现安全队列，可以使用2种方式：</p><ul><li>加锁，这种实现方式就是我们常说的阻塞队列。</li><li>使用循环CAS算法实现，这种方式实现队列称之为非阻塞队列。</li></ul><p>ConcurrentLinkedQueue 是一个基于链接节点的<strong>无界线</strong>程安全的队列，按照先进先出原则对元素进行排序。新元素从队列尾部插入，而获取队列元素，则需要从队列头部获取；内部的数据结构是分开的，线程之间互不影响，所以也就无需执行互斥处理。</p><h5 id="ConcurrentLinkedQueue使用约定："><a href="#ConcurrentLinkedQueue使用约定：" class="headerlink" title="ConcurrentLinkedQueue使用约定："></a>ConcurrentLinkedQueue使用约定：</h5><ul><li>不允许null入列</li><li>在入队的最后一个元素的next为null</li><li>队列中所有未删除的节点的item都不能为null且都能从head节点遍历到</li><li>删除节点是将item设置为null, 队列迭代时跳过item为null节点</li><li>head节点跟tail不一定指向头节点或尾节点，可能存在滞后性</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>入列出列线程安全，遍历不安全</li><li>不允许添加null元素</li><li>底层使用列表与CAS算法保证入列出列安全</li></ol><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>java.util.concurrent.Exchanger 类用于让两个线程安全的交换对象。</p><h2 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h2><h3 id="Executors-newFixedThreadPool方法"><a href="#Executors-newFixedThreadPool方法" class="headerlink" title="Executors.newFixedThreadPool方法"></a>Executors.newFixedThreadPool方法</h3><p>Executors.newFixedThreadPool方法会创建一个线程池，该线程池会创建个数由参数指定的工人线程，而且创建出的线程会被重复利用。如果在这个方法的参数中加上ThreadFactory对象，则线程池会使用该ThreadFactory来创建新的工人线程。</p><h3 id="Executors-newCachedThreadPool方法"><a href="#Executors-newCachedThreadPool方法" class="headerlink" title="Executors.newCachedThreadPool方法"></a>Executors.newCachedThreadPool方法</h3><p>Executors.newCachedThreadPool方法会创建一个线城市，该线程池可以根据需要自动创建工人线程，而且创建的工人线程会被重复利用。没有工作的工人线程会在缓存约60秒后自动终止。如果像这个方法的参数中传入ThreadFactory对象，则线程池会使用这个ThreadFactory来创建新的工人线程。</p><h3 id="Executors-newScheduledThreadPool方法"><a href="#Executors-newScheduledThreadPool方法" class="headerlink" title="Executors.newScheduledThreadPool方法"></a>Executors.newScheduledThreadPool方法</h3><blockquote><p>推荐使用<code>newScheduledThreadPool</code>代替 <code>Timer</code>对象</p><p>因为不会收到异常中断的影响</p></blockquote><p>Executors.newScheduledThreadPool方法会创建一个线程池，该线程池可以在一定时间后执行请求或是反复执行请求。即使在没有请求时也需要保存的线程数量可以通过参数指定。此外，如果在这个方法的参数中加上ThreadFactory对象，则线程池会使用这个ThreadFactory来创建新的工人线程。</p><h2 id="5种创建对象的方法："><a href="#5种创建对象的方法：" class="headerlink" title="5种创建对象的方法："></a>5种创建对象的方法：</h2><ol><li>使用new关键字</li><li>Class对象的newInstance()方法</li><li>构造函数对象的newInstance()方法</li><li>对象反序列化</li><li>Object对象的clone()方法</li></ol><h3 id="1-使用new关键字"><a href="#1-使用new关键字" class="headerlink" title="1. 使用new关键字"></a><strong>1. 使用new关键字</strong></h3><p>这是最常用也最简单的方式，看看下面这个例子就知道了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_ invoke__">Test</span>() &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_ invoke__">Test</span>(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_ invoke__">getName</span>() &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">setName</span>(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">main</span>(String[] args) &#123;<br>        Test t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        Test t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Class对象的newInstance-方法"><a href="#2-Class对象的newInstance-方法" class="headerlink" title="2. Class对象的newInstance()方法"></a><strong>2. Class对象的newInstance()方法</strong></h3><p>还是上面的Test对象，首先我们通过Class.forName()动态的加载类的Class对象，然后通过newInstance()方法获得Test类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;org.b3log.solo.util.Test&quot;</span>;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">clasz</span> <span class="hljs-operator">=</span> Class.forName(className);<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (Test) clasz.newInstance();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-构造函数对象的newInstance-方法"><a href="#3-构造函数对象的newInstance-方法" class="headerlink" title="3. 构造函数对象的newInstance()方法"></a><strong>3. 构造函数对象的newInstance()方法</strong></h3><p>类Constructor也有newInstance方法，这一点和Class有点像。从它的名字可以看出它与Class的不同，Class是通过类来创建对象，而Constructor则是通过构造器。我们依然使用第一个例子中的Test类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Constructor&lt;Test&gt; constructor;<br>   <span class="hljs-keyword">try</span> &#123;<br>        constructor = Test.class.getConstructor();<br>       <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> constructor.newInstance();<br>   &#125; <span class="hljs-keyword">catch</span> (InstantiationException |<br>        IllegalAccessException |<br>        IllegalArgumentException |<br>        InvocationTargetException |<br>        NoSuchMethodException |<br>        SecurityException e) &#123;<br>        e.printStackTrace();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-对象反序列化"><a href="#4-对象反序列化" class="headerlink" title="4. 对象反序列化"></a><strong>4. 对象反序列化</strong></h3><p>使用反序列化来获得类的对象，那么这里必然要用到序列化Serializable接口，所以这里我们将第一个例子中的Test作出一点改变，那就是实现序列化接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sample.txt&quot;</span>;<br>     <span class="hljs-type">Test</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>     <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath);<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fileOutputStream);<br>        outputStream.writeObject(t1);<br>        outputStream.flush();<br>        outputStream.close();<br><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fileInputStream);<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> (Test) inputStream.readObject();<br>        inputStream.close();<br>        System.out.println(t2.getName());<br>     &#125; <span class="hljs-keyword">catch</span> (Exception ee) &#123;<br>           ee.printStackTrace();<br>     &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-Object对象的clone-方法"><a href="#5-Object对象的clone-方法" class="headerlink" title="5. Object对象的clone()方法"></a><strong>5. Object对象的clone()方法</strong></h3><p>Object对象中存在clone方法，它的作用是创建一个对象的副本。看下面的例子，这里我们依然使用第一个例子的Test类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> (Test) t1.clone();<br>    System.out.println(t2.getName());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a><strong>happens-before原则</strong></h2><p>　　Java内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>　　下面是Java内存模型下一些”天然的“happens-before关系，这些happens-before关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。</p><p>　　a. 程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。</p><p>　　b. 管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。</p><p>　　c. volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。</p><p>　　d. 线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。</p><p>　　e. 线程终止规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。</p><p>　　f. 线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。</p><p>　　g. 对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。</p><p>　　h. 传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>CAS，是 compare and swap 的缩写，即比较并交换。它是一种基于乐观锁的操作。它有三个操作数，内存值V，预期值A，更新值B。当且仅当A和V相同时，才会把V修改成B，否则什么都不做。之前说到AtomicInteger用到了CAS，那么先从这个类说起。看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">5</span>);<br>        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>,<span class="hljs-number">50</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>AtomicInteger有一个compareAndSet方法，有两个操作数，第一个是期望值，第二个是希望修改成的值。首先初始值是5，第一次调用compareAndSet方法的时候，将5拷贝回自己的工作空间，然后改成50，写回到主内存中的时候，它期望主内存中的值是5，而这时确实也是5，所以可以修改成功，主内存中的值也变成了50，输出true。第二次调用compareAndSet的时候，在自己的工作内存将值修改成100，写回去的时候，希望主内存中的值是5，但是此时是50，所以set失败，输出false。这就是比较并交换，也即CAS。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>简而言之，CAS工作原理就是<strong>UnSafe类</strong>和<strong>自旋锁</strong>。</p><p><strong>1、UnSafe类：</strong><br> UnSafe类在jdk的rt.jar下面的一个类，全包名是sun.misc.UnSafe。这个类大多数方法都是native方法。由于Java不能操作计算机系统，所以设计之初就留了一个UnSafe类。通过UnSafe类，Java就可以操作指定内存地址的数据。调用UnSafe类的CAS，JVM会帮我们实现出汇编指令，从而实现原子操作。现在就来分析一下AtomicInteger的getAndIncrement方法是怎么工作的。看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> U.getAndAddInt(<span class="hljs-built_in">this</span>, VALUE, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@HotSpotIntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(o, offset);<br>    &#125; <span class="hljs-keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的o就是当前对象，offset是内存地址，delta是1，也就是自增步伐。首先把当前对象主内存中的值赋给v，然后进入while循环。判断当前对象此刻主内存中的值是否等于v，如果是，就自增，否则继续循环，重新获取v的值。这里的compareAndSwapInt方法就是一个native方法，这个方法汇编之后是CPU原语指令，原语指令是连续执行不会被打断的，所以可以保证原子性。</p><p><strong>2、自旋锁：</strong><br>所谓的自旋，其实就是上面getAndAddInt方法中的do while循环操作。当预期值和主内存中的值不等时，就重新获取主内存中的值，这就是自旋。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>1、循环时间长，开销大。</strong><br> synchronized是加锁，同一时间只能一个线程访问，并发性不好。而CAS并发性提高了，但是由于CAS存在自旋操作，即do while循环，如果CAS失败，会一直进行尝试。如果CAS长时间不成功，会给CPU带来很大的开销。</p><p><strong>2、只能保证一个共享变量的原子性。</strong><br> 上面也看到了，getAndAddInt方法的o是代表当前对象，所以它也就是能保证这一个共享变量的原子性。如果要保证多个，那只能加锁了。</p><p><strong>3、引来的ABA问题。</strong></p><ul><li><strong>什么是ABA问题？</strong></li></ul><p>假设现在主内存中的值是A，现有t1和t2两个线程去对其进行操作。t1和t2先将A拷贝回自己的工作内存。这个时候t2线程将A改成B，刷回到主内存。此刻主内存和t2的工作内存中的值都是B。接下来还是t2线程抢到执行权，t2又把B改回A，并刷回到主内存。这时t1终于抢到执行权了，自己工作内存中的值的A，主内存也是A，因此它认为没人修改过，就在工作内存中把A改成了X，然后刷回主内存。也就是说，在t1线程执行前，t2将主内存中的值由A改成B再改回A。这便是ABA问题。看下面的代码演示(代码涉及到原子引用，请参考下面的原子引用的介绍)：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">ABADemo</span> &#123;<br>   <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>&#123;<br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>              atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>);<br>              atomicReference.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>);<br>              &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123; <br>                   TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace(); <br>              &#125;<br>              System.<span class="hljs-keyword">out</span>.println(atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>) <br>                                           + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.<span class="hljs-keyword">get</span>());<br>              &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码执行结果是”true C”，这就证明了ABA问题的存在。如果一个业务只管开头和结果，不管这个A中间是否变过，那么出现了ABA问题也没事。如果需要A还是最开始的那个A，中间不许别人动手脚，那么就要规避ABA问题。要解决ABA问题，先看下面的原子引用的介绍。</p><ul><li><strong>原子引用：</strong></li></ul><p>JUC包下给我们提供了原子包装类，像AtomicInteger。如果我不仅仅想要原子包装类，我自己定义的User类也想具有原子操作，怎么办呢？JUC为我们提供了AtomicReference<V>，即原子引用。看下面的代码：</V></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-built_in">int</span> age;<br>    <span class="hljs-built_in">String</span> name;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args)&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();<br>        atomicReference.<span class="hljs-keyword">set</span>(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像这样，就把User类变成了原子User类了。</p><ul><li><strong>解决ABA问题思路：</strong></li></ul><p>我们可以这个共享变量带上一个版本号。比如现在主内存中的是A，版本号是1，然后t1和t2线程拷贝一份到自己工作内存。t2将A改为B，刷回主内存。此时主内存中的是B，版本号为2。然后再t2再改回A，此时主内存中的是A，版本号为3。这个时候t1线程终于来了，自己工作内存是A，版本号是1，主内存中是A，但是版本号为3，它就知道已经有人动过手脚了。那么这个版本号从何而来，这就要说说AtomicStampedReference这个类了。</p><ul><li><strong>带时间戳的原子引用(AtomicStampedReference)：</strong><br>这个时间戳就理解为版本号就行了。看如下代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ABADemo</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// 睡一秒，让t1线程拿到最初的版本号</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, atomicReference.getStamp(), atomicReference.getStamp() + <span class="hljs-number">1</span>);<br>            atomicReference.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, atomicReference.getStamp(), atomicReference.getStamp() + <span class="hljs-number">1</span>);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicReference.getStamp(); <span class="hljs-comment">// 拿到最开始的版本号</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); <span class="hljs-comment">// 睡3秒，让t2线程的ABA操作执行完</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始版本号为1，t2线程每执行一次版本号加。等t1线程执行的时候，发现当前版本号不是自己一开始拿到的1了，所以set失败，输出false。这就解决了ABA问题。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>什么是CAS?  —— 比较并交换，主内存值和工作内存值相同，就set为更新值。</li><li>CAS原理是什么？ —— UnSafe类和自旋锁。理解那个do while循环。</li><li>CAS缺点是什么？ —— 循环时间长会消耗大量CPU资源；只能保证一个共享变量的原子性操作；造成ABA问题。</li><li>什么是ABA问题？ —— t2线程先将A改成B，再改回A，此时t1线程以为没人修改过。</li><li>如何解决ABA问题？—— 使用带时间戳的原子引用。</li></ol><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>所谓的重排序，英文记作Reorder，是指编译器和Java虚拟机通过改变程序的处理顺序来优化程序。虽然重排序被广泛用于提高性能，不过开发人员几乎不会意识到这一点。实际上，在运行单线程程序时我们无法判断是否进行了重排序。这是因为，虽然处理顺序改变了，但是规范上有很多限制可以避免程序出现运行错误。</p><blockquote><p>没有同步的状态为“存在数据竞争”。</p></blockquote><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><img src="/posts/a019e08c/81.png" alt="image-20200709205146965" style="zoom:50%;"><p>重排序可能导致x&lt;y</p><img src="/posts/a019e08c/82.png" alt="image-20200709205234341" style="zoom:50%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Something</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        x = <span class="hljs-number">100</span>;<br>        y = <span class="hljs-number">50</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; y) &#123;<br>            System.out.println(<span class="hljs-string">&quot;x &lt; y&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;x &gt; y&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Something</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Something</span>();<br><br>        <span class="hljs-comment">// 写数据的线程A</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                obj.write();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 读数据的线程B</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                obj.read();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>假设线程A将某个值写入了字段X中，而线程B读取到了该值。我们称其为“线程A向X的写值对线程B是可见的（visible）”。“是否是可见的”这个性质就成为可见性，英文记作visibility。</p><h2 id="共享内存（堆）"><a href="#共享内存（堆）" class="headerlink" title="共享内存（堆）"></a>共享内存（堆）</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>共享内存是所有线程共享的存储空间，也被称为堆内存（heap memory）。因为实例会被全部保存在共享内存中，所以实例中的字段也存在于共享内存中。此外，<strong>数据的元素</strong>也被保存在共享内存中。也就是说，可以使用new在共享内存中分配存储空间。</p><p>局部变量不会被保存在共享内存中。通常，除局部变量外，方法的形参，catch语句块中编写的异常处理器的参数等也不会被保存在共享内存中，而是被保存在各个线程特有的栈中。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized（lock&#x2F;unlock操作）并不仅仅进行线程的互斥处理。<strong>Java内存模型确保了某个线程在进行unlockM操作前进行的所有写入操作对进行lockM操作的线程都是可见的。</strong></p><img src="/posts/a019e08c/83.png" alt="image-20200709213538876" style="zoom:50%;"><ul><li>进行unlock操作后，写入缓存中的内容会被强制地写入共享内存中</li><li>进行lock操作后，缓存中的内容会先失效，然后共享内存中的最新内存会被强制重新读取到缓存中</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile write操作时是一种release，而volatile read操作是一种acquire。</p><table><thead><tr><th>release</th><th>acquire</th></tr></thead><tbody><tr><td>volatile write</td><td>volatile read</td></tr><tr><td>unlock</td><td>lock</td></tr><tr><td>线程的启动（start）</td><td>线程启动后的第一个操作</td></tr><tr><td>线程终止前的最后一个操作</td><td>检测线程的终止（join、isAlive）</td></tr><tr><td>中断（interrupt）</td><td>检测中断（isInterrupted、Thread.interrupted、InterruptException）</td></tr><tr><td>向字段写入默认值</td><td>线程的第一个操作</td></tr></tbody></table><ul><li><p>volatile字段的赋值语句的位置很重要</p><p>volatile字段放在最后才可以保证上面声明的变量的值能够被写入主内存。</p></li><li><p>volatile不会进行线程的互斥处理</p><p>访问volatile字段的线程不会进入等待队列。</p></li><li><p>访问volatile字段会产生性能开销</p><p>访问volatile字段与synchronized的处理耗费的时间几乎相同。</p></li></ul><blockquote><p>对long和double的原子操作</p><p>Java规范无法确保对long和double的赋值操作的原子性。但是，即使是long和double的字段，只要它是volatile字段，就可以确保赋值操作的原子性。</p></blockquote><h2 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h2><p>使用final关键字声明的字段（final字段）只能被初始化一次。</p><p>final字段的初始化只能在“字段声明时”或是“构造函数中”进行。那么，当final字段的初始化结束后，无论在任何时候，它的值对其他线程都是可见的（变成visible）。Java内存模型可以确保被初始化后的final字段在构造函数的处理结束后是可见的。</p><p>Java内存模型可以确保final字段在构造函数执行结束后可以正确的被看到。这样就不再需要通过synchronized和volatile进行同步了。</p><h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><table><thead><tr><th align="left">操作符</th><th align="left">补齐方式</th><th align="left">结果符号</th></tr></thead><tbody><tr><td align="left">&lt;&lt;</td><td align="left">右边用 0 补齐</td><td align="left">和原操作数没有绝对关系，取决于左移后符号位。</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">左边有原符号位补齐</td><td align="left">和原操作数有相同符号。</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">左边用 0 补齐</td><td align="left">和原操作数无关，一直为正数。</td></tr></tbody></table><h2 id="Java-常见的七大设计原则"><a href="#Java-常见的七大设计原则" class="headerlink" title="Java 常见的七大设计原则"></a>Java 常见的七大设计原则</h2><p>Java常见的设计开发原则，能够帮助我们更好的理解软件设计的方式方法，更方便进行代码的维护以及写出高质量的代码。</p><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1. 开闭原则"></a>1. 开闭原则</h3><p>对扩展开放，对修改关闭。尽量不要修改已有的能够稳定运行的代码，在原有的基础上进行拓展，增加新的功能，避免影响原有功能。</p><h3 id="2-单一职责原则"><a href="#2-单一职责原则" class="headerlink" title="2. 单一职责原则"></a>2. 单一职责原则</h3><p>一个类尽量实现一种功能或者提供一种服务。如果类里包含的功能特别多，在后面需要扩展或者修改的时候就要重新修改该类，容易影响代码的稳定性，维护起来也不方便。</p><h3 id="3-迪米特原则"><a href="#3-迪米特原则" class="headerlink" title="3. 迪米特原则"></a>3. 迪米特原则</h3><p>也叫最小知道原则，即如果某类A与类B可以没有直接的联系，尽量不要在A中出现B类。这样能够减少代码的耦合度，提高代码的健壮性。</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><p>客户端尽量不要依赖它不需要的接口，在设计接口的时候尽量方法少一些，不要建立非常臃肿的接口。接口功能越细化，系统的灵活性就越高，但是也不能越少越好，尽量细化接口及其方法即可。</p><h3 id="5-里氏替换原则"><a href="#5-里氏替换原则" class="headerlink" title="5. 里氏替换原则"></a>5. 里氏替换原则</h3><p>即在任何出现父类的地方，都可以用自子类替代。只有这样，基类才能够被复用，这也是开闭原则的补充。子类可以在父类的基础上扩展新的功能。反过来，在使用子类的地方不能使用父类，因为父类不一定具有子类的新功能。</p><h3 id="6-依赖倒置原则"><a href="#6-依赖倒置原则" class="headerlink" title="6. 依赖倒置原则"></a>6. 依赖倒置原则</h3><p>即程序要依赖抽象，而不是依赖实现。<br>这要去我们的在代码方法的参数或者对象关联时，尽量用高层次的抽象类，而不是具体的实现类。其本质就是面向接口编程。</p><h3 id="7-聚合-x2F-组合复用原则"><a href="#7-聚合-x2F-组合复用原则" class="headerlink" title="7. 聚合&#x2F;组合复用原则"></a>7. 聚合&#x2F;组合复用原则</h3><p>即尽量用聚合&#x2F;组合的方式去复用功能，尽量不要通过继承来达到复用的功能。因为继承关系中，如果基类的功能需要修改，那么子类的功能也可能受到影响。如果使用聚合&#x2F;组合的关系，类的关系不像继承那样耦合度那么高，而且聚合&#x2F;组合可以在运行时动态的进行，新对象可以动态的引用与原有类同样功能的其他对象。</p><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>对于一个类而言，按照如下顺序执行：</p><ol><li>执行静态代码块</li><li>执行构造代码块</li><li>执行构造函数</li></ol><p>对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt; 构造器</p><p>当涉及到继承时，按照如下顺序执行：</p><ol><li>执行父类的静态代码块，并初始化父类静态成员变量</li><li>执行子类的静态代码块，并初始化子类静态成员变量</li><li>执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量</li><li>执行子类的构造代码块， 执行子类的构造函数，并初始化子类普通成员变量</li></ol><img src="/posts/a019e08c/120.png" class><h2 id="生成实例的方法"><a href="#生成实例的方法" class="headerlink" title="生成实例的方法"></a>生成实例的方法</h2><ul><li>new</li><li>clone</li><li>newInstance</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&amp;（按位与）</td><td>1&amp;1&#x3D;1 , 1&amp;0&#x3D;0 , 0&amp;1&#x3D;0 , 0&amp;0&#x3D;0</td></tr><tr><td>|（按位或）</td><td>1|1&#x3D;1 , 1|0&#x3D;1 , 0|1&#x3D;1 , 0|0&#x3D;0</td></tr><tr><td>^（异或运算符）</td><td>1^0 &#x3D; 1 , 1^1 &#x3D; 0 , 0^1 &#x3D; 1 , 0^0 &#x3D; 0</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-基础&quot;&gt;&lt;a href=&quot;#Java-基础&quot; class=&quot;headerlink&quot; title=&quot;Java 基础&quot;&gt;&lt;/a&gt;Java 基础&lt;/h1&gt;&lt;h2 id=&quot;final&quot;&gt;&lt;a href=&quot;#final&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="Java 基础" scheme="https://blog.yahyav2rayssr.top/categories/Java/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://blog.yahyav2rayssr.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 状态码</title>
    <link href="https://blog.yahyav2rayssr.top/posts/e1434ae1/"/>
    <id>https://blog.yahyav2rayssr.top/posts/e1434ae1/</id>
    <published>2023-04-16T13:55:32.743Z</published>
    <updated>2023-04-16T13:55:32.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-状态码一览"><a href="#HTTP-状态码一览" class="headerlink" title="HTTP 状态码一览"></a>HTTP 状态码一览</h1><h2 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h2><h3 id="信息：1xx"><a href="#信息：1xx" class="headerlink" title="信息：1xx"></a>信息：1xx</h3><p>代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。</p><table><thead><tr><th>消息：</th><th align="center">描述：</th></tr></thead><tbody><tr><td>100 Continue</td><td align="center">服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求</td></tr><tr><td>101 Switching Protocols</td><td align="center">服务器转换协议，服务器将遵从客户的请求转换到另外一种协议</td></tr><tr><td>102 Processing</td><td align="center">代表处理将被继续执行</td></tr></tbody></table><h3 id="成功：2xx"><a href="#成功：2xx" class="headerlink" title="成功：2xx"></a>成功：2xx</h3><p>代表请求已成功被服务器接收、理解、并接受。</p><table><thead><tr><th>消息：</th><th align="center">描述：</th></tr></thead><tbody><tr><td>200 OK</td><td align="center">请求成功，表示正常状态</td></tr><tr><td>201 Created</td><td align="center">请求被创建完成，同时新的资源被创建立</td></tr><tr><td>202 Accepted</td><td align="center">处理的请求已被接受，但处理未完成</td></tr><tr><td>203 Non-authoritative Information</td><td align="center">服务器已成功处理了请求，但一些应答头可能不正确，因为使用的是文档的拷贝</td></tr><tr><td>204 No Content</td><td align="center">服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息</td></tr><tr><td>205 Reset Content</td><td align="center">服务器成功处理了请求，且没有返回任何内容，返回此状态码的响应要求请求者重置文档视图</td></tr><tr><td>206 Partial Content</td><td align="center">服务器已经成功处理了部分 GET 请求</td></tr><tr><td>207 Multi-Status</td><td align="center">代表之后的消息体将是一个XML消息</td></tr></tbody></table><h3 id="重定向：3xx"><a href="#重定向：3xx" class="headerlink" title="重定向：3xx"></a>重定向：3xx</h3><p>代表需要客户端采取进一步的操作才能完成请求。</p><table><thead><tr><th>消息：</th><th align="center">描述：</th></tr></thead><tbody><tr><td>300 Multiple Choices</td><td align="center">被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向</td></tr><tr><td>301 Moved Permanently</td><td align="center">所请求的资源已经转移至新的url</td></tr><tr><td>302 Move temporarily</td><td align="center">请求的资源临时从不同的 URI响应请求</td></tr><tr><td>303 See Other</td><td align="center">所请求的页面可在别的url下被找到，客户端应当采用 GET 的方式访问那个资源</td></tr><tr><td>304 Not Modified</td><td align="center">服务器告诉客户，原来缓冲的文档还可以继续使用</td></tr><tr><td>305 Use Proxy</td><td align="center">被请求的资源必须通过指定的代理才能被访问</td></tr><tr><td>306 Switch Proxy</td><td align="center">目前已不再使用，但是代码依然被保留</td></tr><tr><td>307 Temporary Redirect</td><td align="center">请求的资源临时从不同的URI 响应请求</td></tr></tbody></table><h3 id="客户端错误：4xx"><a href="#客户端错误：4xx" class="headerlink" title="客户端错误：4xx"></a>客户端错误：4xx</h3><p>代表了客户端看起来可能发生了错误，妨碍了服务器的处理。</p><table><thead><tr><th>消息:</th><th align="center">描述:</th></tr></thead><tbody><tr><td>400 Bad Request</td><td align="center">语义有误，服务器未能理解请求。或请求参数有误</td></tr><tr><td>401 Unauthorized</td><td align="center">被请求的页面需要用户名和密码</td></tr><tr><td>402 Payment Required</td><td align="center">为了将来可能的需求而预留的</td></tr><tr><td>403 Forbidden</td><td align="center">对被请求资源的访问被禁止</td></tr><tr><td>404 Not Found</td><td align="center">服务器无法找到被请求的资源</td></tr><tr><td>405 Method Not Allowed</td><td align="center">请求中指定的方法不被允许</td></tr><tr><td>406 Not Acceptable</td><td align="center">服务器生成的响应无法被客户端所接受</td></tr><tr><td>407 Proxy Authentication Required</td><td align="center">用户必须首先使用代理服务器进行验证，这样请求才会被处理</td></tr><tr><td>408 Request Timeout</td><td align="center">请求超出了服务器的等待时间</td></tr><tr><td>409 Conflict</td><td align="center">和被请求的资源的当前状态之间存在冲突，请求无法完成</td></tr><tr><td>410 Gone</td><td align="center">被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址</td></tr><tr><td>411 Length Required</td><td align="center">“Content-Length” 未被定义。如果无此内容，服务器不会接受请求</td></tr><tr><td>412 Precondition Failed</td><td align="center">请求中的前提条件被服务器评估为失败</td></tr><tr><td>413 Request Entity Too Large</td><td align="center">由于所请求的实体数据太大，服务器不会接受请求</td></tr><tr><td>414 Request-url Too Long</td><td align="center">由于url太长，服务器不会接受请求。当post请求被转换为带有很长的查询信息的get请求时，就会发生这种情况</td></tr><tr><td>415 Unsupported Media Type</td><td align="center">由于请求中格式类型不被支持，服务器不会接受请求</td></tr><tr><td>416 Requested Range Not Satisfiable</td><td align="center">客户在请求中指定的Range头与当前资源的可用范围不重合</td></tr><tr><td>417 Expectation Failed</td><td align="center">在请求头 Expect 中指定的预期内容无法被服务器满足</td></tr><tr><td>421 too many connections</td><td align="center">当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围</td></tr><tr><td>422 Unprocessable Entity</td><td align="center">请求格式正确，但是由于含有语义错误，无法响应</td></tr><tr><td>423 Locked</td><td align="center">当前资源被锁定</td></tr><tr><td>424 Failed Dependency</td><td align="center">之前的某个请求发生的错误，导致当前请求失败</td></tr><tr><td>425 Unordered Collectiond</td><td align="center"></td></tr><tr><td>449 Retry With</td><td align="center">客户端应当切换到TLS&#x2F;1.0</td></tr><tr><td>425 Unordered Collectiond</td><td align="center">由微软扩展，代表请求应当在执行完适当的操作后进行重试</td></tr><tr><td>451 Unavailable For Legal Reasons</td><td align="center">该请求因法律原因不可用</td></tr></tbody></table><h3 id="服务器错误：5xx，-6xx"><a href="#服务器错误：5xx，-6xx" class="headerlink" title="服务器错误：5xx， 6xx"></a>服务器错误：5xx， 6xx</h3><p>代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理</p><table><thead><tr><th>消息:</th><th align="center">描述:</th></tr></thead><tbody><tr><td>500 Internal Server Error</td><td align="center">请求未完成，服务器遇到不可预知的情况。一般为服务器源码出现问题</td></tr><tr><td>501 Not Implemented</td><td align="center">请求未完成，服务器不支持所请求的功能</td></tr><tr><td>502 Bad Gateway</td><td align="center">请求未完成，网关或者代理工作的服务器尝试执行请求，从上游服务器收到一个无效的响应</td></tr><tr><td>503 Service Unavailable</td><td align="center">请求未完成，服务器临时过载或维护</td></tr><tr><td>504 Gateway Timeout</td><td align="center">网关或者代理工作的服务器尝试执行请求超时</td></tr><tr><td>505 HTTP Version Not Supported</td><td align="center">服务器不支持或拒绝请求中指明的HTTP协议版本</td></tr><tr><td>506 Variant Also Negotiates</td><td align="center">服务器存在内部配置错误</td></tr><tr><td>507 Insufficient Storage</td><td align="center">服务器无法存储完成请求所必须的内容</td></tr><tr><td>509 Bandwidth Limit Exceeded</td><td align="center">服务器达到带宽限制</td></tr><tr><td>510 Not Extended</td><td align="center">获取资源所需要的策略并没有被满足</td></tr><tr><td>600 Unparseable Response Headers</td><td align="center">没有返回响应头部，只返回实体内容</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-状态码一览&quot;&gt;&lt;a href=&quot;#HTTP-状态码一览&quot; class=&quot;headerlink&quot; title=&quot;HTTP 状态码一览&quot;&gt;&lt;/a&gt;HTTP 状态码一览&lt;/h1&gt;&lt;h2 id=&quot;状态&quot;&gt;&lt;a href=&quot;#状态&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="网络" scheme="https://blog.yahyav2rayssr.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="http" scheme="https://blog.yahyav2rayssr.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HTTP 基础知识</title>
    <link href="https://blog.yahyav2rayssr.top/posts/e5fda0b2/"/>
    <id>https://blog.yahyav2rayssr.top/posts/e5fda0b2/</id>
    <published>2023-04-16T13:55:16.952Z</published>
    <updated>2023-04-16T13:55:16.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-基础知识"><a href="#HTTP-基础知识" class="headerlink" title="HTTP 基础知识"></a>HTTP 基础知识</h1><h2 id="三次握手，四次挥手"><a href="#三次握手，四次挥手" class="headerlink" title="三次握手，四次挥手"></a>三次握手，四次挥手</h2><p><strong>TCP三次握手过程</strong></p><ol><li>主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B ,向主机B 请求建立连接,通过这个数据段,</li></ol><p>主机A告诉主机B两件事:我想要和你通信;你可以用哪个序列号作为起始数据段来回应我.</p><ol start="2"><li>主机B收到主机A的请求后,用一个带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应主机A,也告诉主机A两件事:</li></ol><p>我已经收到你的请求了,你可以传输数据了;你要用哪佧序列号作为起始数据段来回应我</p><ol start="3"><li>主机A收到这个数据段后,再发送一个确认应答,确认已收到主机B的数据段:”我已收到回复,我现在要开始传输实际数据了</li></ol><p>这样3次握手就完成了,主机A和主机B就可以传输数据了.</p><p><strong>3次握手的特点</strong></p><ul><li>没有应用层的数据</li><li>SYN这个标志位只有在TCP建立连接时才会被置1</li><li>握手完成后SYN标志位被置0</li></ul><img src="http 基础/201.png" style="zoom:80%;"><p><strong>TCP建立连接要进行3次握手,而断开连接要进行4次</strong></p><ol><li><p>当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求</p></li><li><p>主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1</p></li><li><p>由B端再提出反方向的关闭请求,将FIN置1</p></li><li><p>主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.</p></li></ol><p>由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础。</p><img src="http 基础/202.png" style="zoom:80%;"><p><strong>名词解释</strong></p><p>ACK：TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段</p><p>都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK&#x3D;1时,确认号才有效,当ACK&#x3D;0时,确认号无效,这时会要求重传数据,保证数据的完整性.</p><p>SYN：同步序列号,TCP建立连接时将这个位置1</p><p>FIN：发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1</p><h2 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h2><ul><li><p><strong>TCP（Transmission Control Protocol，传输控制协议）</strong>是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，只简单的描述下这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。</p></li><li><p><strong>UDP（User Data Protocol，用户数据报协议）</strong></p></li></ul><ol><li><p>UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</p></li><li><p>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。</p></li><li><p>UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。</p></li><li><p>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。</p></li><li><p>UDP使用<strong>尽最大努力交付，</strong>即不保证可靠交付，因此主机不需要维持复杂的链接状态表（这里面有许多参数）。</p></li><li><p>UDP是<strong>面向报文</strong>的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</p></li></ol><p>我们经常使用“ping”命令来测试两台主机之间TCP&#x2F;IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</p><p><strong>UDP的包头结构：</strong></p><p>源端口 16位</p><p>目的端口 16位</p><p>长度 16位</p><p>校验和 16位</p><p><strong>小结TCP与UDP的区别：</strong></p><p>1.基于连接与无连接；</p><p>2.对系统资源的要求（TCP较多，UDP少）；</p><p>3.UDP程序结构较简单；</p><p>4.流模式与数据报模式 ；</p><p>5.TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-基础知识&quot;&gt;&lt;a href=&quot;#HTTP-基础知识&quot; class=&quot;headerlink&quot; title=&quot;HTTP 基础知识&quot;&gt;&lt;/a&gt;HTTP 基础知识&lt;/h1&gt;&lt;h2 id=&quot;三次握手，四次挥手&quot;&gt;&lt;a href=&quot;#三次握手，四次挥手&quot; class</summary>
      
    
    
    
    <category term="网络" scheme="https://blog.yahyav2rayssr.top/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="http" scheme="https://blog.yahyav2rayssr.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>HashMap 详解</title>
    <link href="https://blog.yahyav2rayssr.top/posts/e344884c/"/>
    <id>https://blog.yahyav2rayssr.top/posts/e344884c/</id>
    <published>2023-04-16T13:43:28.189Z</published>
    <updated>2023-04-16T13:43:28.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="HahsMap存值过程"><a href="#HahsMap存值过程" class="headerlink" title="HahsMap存值过程"></a>HahsMap存值过程</h2><ul><li>根据key计算一个hash值</li><li>在put的时候计算数组是否存在 如果不存在调用resize方法创建默认容量为16的数组</li><li>确定node在数组中的位置 根据hash值与数组最大索引值进行与运算得到索引位置</li><li>获取该位置是否有元素 如果没有元素 直接新建一个Node放在该位置</li><li>如果有元素 判断key是否完全相同 如果相同把原来的node赋值给一个变量</li><li>此时再去判断 该位置是红黑树还是链表</li><li>如果是红黑树 以红黑树的方式将node放在红黑树上</li><li>如果是链表 此时遍历链表 然后将node放在最后一位<br>放完以后需要去判断链表的长度 是否超过8 如果超过需要判断是否将链表转换为红黑树（当数组容量小于64的时候 只会进行数组的扩容 如果大于64才会进行链表转换红黑树）</li><li>返回被覆盖的值</li><li>判断整个数组是否需要扩容</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h2 id=&quot;HahsMap存值过程&quot;&gt;&lt;a href=&quot;#HahsMap存值过程&quot; class=&quot;headerlink&quot; title=&quot;Hah</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap 详解</title>
    <link href="https://blog.yahyav2rayssr.top/posts/39a12d12/"/>
    <id>https://blog.yahyav2rayssr.top/posts/39a12d12/</id>
    <published>2023-04-16T13:43:17.896Z</published>
    <updated>2023-04-16T13:43:17.896Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrentHashMap-详解"><a href="#concurrentHashMap-详解" class="headerlink" title="concurrentHashMap 详解"></a>concurrentHashMap 详解</h1><h2 id="初始化数组"><a href="#初始化数组" class="headerlink" title="初始化数组"></a>初始化数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;<br>    Node&lt;K,V&gt;[] tab; <span class="hljs-type">int</span> sc;<br>    <span class="hljs-keyword">while</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> ((sc = sizeCtl) &lt; <span class="hljs-number">0</span>)<br>            Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// lost initialization race; just spin</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSetInt(<span class="hljs-built_in">this</span>, SIZECTL, sc, -<span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || tab.length == <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> (sc &gt; <span class="hljs-number">0</span>) ? sc : DEFAULT_CAPACITY;<br>                    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?,?&gt;[n];<br>                    table = tab = nt;<br>                    sc = n - (n &gt;&gt;&gt; <span class="hljs-number">2</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                sizeCtl = sc;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> tab;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="分片统计总和"><a href="#分片统计总和" class="headerlink" title="分片统计总和"></a>分片统计总和</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">sumCount</span><span class="hljs-params">()</span> &#123;<br>    CounterCell[] cs = counterCells;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> baseCount;<br>    <span class="hljs-keyword">if</span> (cs != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (CounterCell c : cs)<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>)<br>                sum += c.value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程抢占CounterCell"><a href="#线程抢占CounterCell" class="headerlink" title="线程抢占CounterCell"></a>线程抢占CounterCell</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// cellsBusy == 1 代表有其他线程正在扩容 </span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; counterCells == cs &amp;&amp;<br>         U.compareAndSetInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>        <span class="hljs-keyword">if</span> (counterCells == cs) &#123;<br>            CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[<span class="hljs-number">2</span>];<br>            rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x);<br>            counterCells = rs;<br>            init = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        cellsBusy = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (init)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="初始化tab"><a href="#初始化tab" class="headerlink" title="初始化tab"></a>初始化tab</h2><blockquote><p>tab 代指 Node&lt;K,V&gt;[] 数组</p></blockquote><h2 id="sizeCtl"><a href="#sizeCtl" class="headerlink" title="sizeCtl"></a>sizeCtl</h2><ol><li>-1 表示一个占位符，如果sizeCtl &#x3D; -1，表示当前已经有线程抢到了初始化的权限</li><li>&gt; 0的数字 sizeCtl &#x3D; sc &#x3D; n*0.75 &#x3D; 12 表示下一次扩容的大小</li><li>负数（非 -1）代表有几个线程正在扩容 （-2）有一个线程正在扩容</li></ol><h2 id="binCount"><a href="#binCount" class="headerlink" title="binCount"></a>binCount</h2><blockquote><p>链表长度</p></blockquote><h2 id="CounterCell"><a href="#CounterCell" class="headerlink" title="CounterCell"></a>CounterCell</h2><blockquote><p>分片计数器数组</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cellsBusy == <span class="hljs-number">0</span> &amp;&amp; counterCells == cs &amp;&amp;<br>         U.compareAndSetInt(<span class="hljs-built_in">this</span>, CELLSBUSY, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">init</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;                           <span class="hljs-comment">// Initialize table</span><br>        <span class="hljs-keyword">if</span> (counterCells == cs) &#123;<br>            CounterCell[] rs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>[<span class="hljs-number">2</span>];<br>            rs[h &amp; <span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CounterCell</span>(x);<br>            counterCells = rs;<br>            init = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        cellsBusy = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (init)<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>CHM的扩容，是可以多个线程并行扩容的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">resizeStamp</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="hljs-number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>resizeStamp(16) &#x3D; 32795</p><p>0000 0000 0000 0000 1000 0000 0001 1011 左移16位</p><p>1000 0000 0001 1011 0000 0000 0000 0000 + 2</p><p>1000 0000 0001 1011 0000 0000 0000 0010 -&gt; 表示当前有一个线程在扩容</p><p>扩容的戳</p><p>高16位代表扩容的标记</p><p>低16位代表扩容的线程数 -&gt; 有一个线程参与扩容了</p><ol><li>需要保证每次扩容的扩容戳都是唯一的</li><li>可以支持并发扩容</li></ol><h2 id="占位节点"><a href="#占位节点" class="headerlink" title="占位节点"></a>占位节点</h2><blockquote><p>MOVED状态，即为 -1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ForwardingNode&lt;K,V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);<br></code></pre></td></tr></table></figure><h2 id="transfer"><a href="#transfer" class="headerlink" title="transfer"></a>transfer</h2><blockquote><p>数组扩容</p></blockquote><img src="/posts/39a12d12/206.png" class alt="image-20200821213045324"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSetInt<br>         (<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>          nextBound = (nextIndex &gt; stride ?<br>                       nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>    bound = nextBound;<br>    i = nextIndex - <span class="hljs-number">1</span>;<br>    advance = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="链路拆分"><a href="#链路拆分" class="headerlink" title="链路拆分"></a>链路拆分</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;<br>    Node&lt;K,V&gt; lastRun = f;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.hash &amp; n;<br>        <span class="hljs-keyword">if</span> (b != runBit) &#123;<br>            runBit = b;<br>            lastRun = p;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 低位链</span><br>    <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;<br>        ln = lastRun;<br>        hn = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 高位链</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        hn = lastRun;<br>        ln = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ph</span> <span class="hljs-operator">=</span> p.hash; <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key; <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> p.val;<br>        <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>)<br>            ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);<br>        <span class="hljs-keyword">else</span><br>            hn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);<br>    &#125;<br>    setTabAt(nextTab, i, ln); <span class="hljs-comment">// 低位链路，位置保持不动</span><br>    setTabAt(nextTab, i + n, hn); <span class="hljs-comment">// 高位链，需要增加n长度位置 14+16=30</span><br>    setTabAt(tab, i, fwd)<br>    advance = <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><img src="/posts/39a12d12/image-20200821220504563.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">(f = tabAt(tab, i = (n - <span class="hljs-number">1</span>) &amp; hash)) == <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>通过数组的方式来实现并发增加元素的个数</li><li>并发扩容，可以通过多个线程来并行实现数据的迁移</li><li>采用高低链的方式来解决多次hash计算的问题，提升了效率</li><li>sizeCtl的设计，三种表示状态</li><li>resizeStamp的设计，高低位的设计来实现唯一性以及多个线程的协助扩容记录</li></ol><blockquote><p>如果连链表的长度大于8，并且node数组的长度 &gt; 64 的时候，如果再添加数据到当前链表中，会把当前链表转换为红黑树。</p><p>当出现扩容的时候，如果链表的长度小于8，把红黑树转换为链表</p></blockquote><blockquote><p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。</p><p>1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</p><p>2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。</p><p>3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</p><p>4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。</p><p>5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concurrentHashMap-详解&quot;&gt;&lt;a href=&quot;#concurrentHashMap-详解&quot; class=&quot;headerlink&quot; title=&quot;concurrentHashMap 详解&quot;&gt;&lt;/a&gt;concurrentHashMap 详解&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 数据结构基础</title>
    <link href="https://blog.yahyav2rayssr.top/posts/c9844e82/"/>
    <id>https://blog.yahyav2rayssr.top/posts/c9844e82/</id>
    <published>2023-04-16T13:42:55.909Z</published>
    <updated>2023-04-16T13:42:55.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="1、什么是链表？"><a href="#1、什么是链表？" class="headerlink" title="1、什么是链表？"></a>1、什么是链表？</h2><p>链表 [Linked List]：链表是由一组不必相连【不必相连：可以连续也可以不连续】的内存结构 【节点】，按特定的顺序链接在一起的抽象数据类型。</p><blockquote><p>补充：<br>抽象数据类型（Abstract Data Type [ADT]）：表示数学中抽象出来的一些操作的集合。<br>内存结构：内存中的结构，如：struct、特殊内存块…等等之类；</p></blockquote><h2 id="2、链表共分几类？"><a href="#2、链表共分几类？" class="headerlink" title="2、链表共分几类？"></a>2、链表共分几类？</h2><p>链表常用的有 3 类： 单链表、双向链表、循环链表。</p><p>链表的核心操作集有 3 种：插入、删除、查找【遍历】</p><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>单链表  [Linked List]：由各个内存结构通过一个 <code>Next</code> 指针链接在一起组成，每一个内存结构都存在后继内存结构【链尾除外】，内存结构由数据域和 Next 指针域组成。</p><p>单链表实现图示：</p><img src="/posts/c9844e82/98.jpg" class><p>文字解析：</p><ul><li>Data 数据 + Next 指针，组成一个单链表的内存结构 ；</li><li>第一个内存结构称为 链头，最后一个内存结构称为 链尾；</li><li>链尾的 Next 指针设置为 NULL [指向空]；</li><li>单链表的遍历方向单一【只能从链头一直遍历到链尾】</li></ul><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>双向链表 [Double Linked List]：由各个内存结构通过指针 <code>Next</code> 和指针 <code>Prev</code> 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构【链头没有前驱，链尾没有后继】，内存结构由数据域、Prev 指针域和 Next 指针域组成。</p><p>双向链表实现图示：</p><img src="/posts/c9844e82/99.jpg" class><p>文字解析：</p><ul><li>Data 数据 + Next 指针 + Prev 指针，组成一个双向链表的内存结构；</li><li>第一个内存结构称为 链头，最后一个内存结构称为 链尾；</li><li>链头的 Prev 指针设置为 NULL， 链尾的 Next 指针设置为 NULL；</li><li>Prev 指向的内存结构称为 前驱， Next 指向的内存结构称为 后继；</li><li>双向链表的遍历是双向的，即如果把从链头的 Next 一直到链尾的[NULL] 遍历方向定义为正向，那么从链尾的 Prev 一直到链头 [NULL ]遍历方向就是反向；</li></ul><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>单向循环链表 [Circular Linked List] : 由各个内存结构通过一个指针 <code>Next</code> 链接在一起组成，每一个内存结构都存在后继内存结构，内存结构由数据域和 Next 指针域组成。</p><p>双向循环链表 [Double Circular Linked List] : 由各个内存结构通过指针 <code>Next</code> 和指针 <code>Prev</code> 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构，内存结构由数据域、Prev 指针域和 Next 指针域组成。</p><p>循环链表的单向与双向实现图示：</p><img src="/posts/c9844e82/100.jpg" class><p>文字解析：</p><ul><li>循环链表分为单向、双向两种；</li><li>单向的实现就是在单链表的基础上，把链尾的 Next 指针直接指向链头，形成一个闭环；</li><li>双向的实现就是在双向链表的基础上，把链尾的 Next 指针指向链头，再把链头的 Prev 指针指向链尾，形成一个闭环；</li><li>循环链表没有链头和链尾的说法，因为是闭环的，所以每一个内存结构都可以充当链头和链尾；</li></ul><h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="ArrayList实现原理"><a href="#ArrayList实现原理" class="headerlink" title="ArrayList实现原理"></a>ArrayList实现原理</h2><p>默认初始容量为10<br>数组数据和容量统计是分开的<br>是通过下标访问数组的<br>如果添加元素的时候超过数组本身的容量，则扩展为原来的1.5倍数<br>加减元素挪动原有数据通过<code>System.arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>来操作实现</p><h2 id="LinkedList实现原理"><a href="#LinkedList实现原理" class="headerlink" title="LinkedList实现原理"></a>LinkedList实现原理</h2><p>链表的数据不一定是连续存储的<br>LinkedList<br>通过分半的方式查找的<br>默认是添加到链表尾部</p><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><img src="/posts/c9844e82/image-20200908191149997.png" alt="image-20200908191149997" style="zoom:33%;"><h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><blockquote><p>put  take 阻塞<br>add remove 异常<br>offer poll true&#x2F;false</p></blockquote><h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><img src="/posts/c9844e82/image-20200908174640627.png" alt="image-20200908174640627" style="zoom:33%;"><h3 id="出队操作"><a href="#出队操作" class="headerlink" title="出队操作"></a>出队操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> E <span class="hljs-title function_">dequeue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// assert takeLock.isHeldByCurrentThread();</span><br>    <span class="hljs-comment">// assert head.item == null;</span><br>    Node&lt;E&gt; h = head;<br>    Node&lt;E&gt; first = h.next;<br>    h.next = h; <span class="hljs-comment">// help GC</span><br>    head = first;<br>    <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;<br>    first.item = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><p>解析：</p><p><code>h = head</code></p><p><code>first = h.next</code></p><p><code>h.next = h (help gc)</code></p><p><code>head = first</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> first.item;<br>first.item = <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span> x;<br></code></pre></td></tr></table></figure><h2 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h2><h2 id="ConcurrentLinkedQueue-1"><a href="#ConcurrentLinkedQueue-1" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><img src="/posts/c9844e82/image-20200908172446586.png" alt="image-20200908172446586" style="zoom:33%;"><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><blockquote><p>采用空间换取时间安全的做法</p><p>适合读多写少的场景</p></blockquote><h2 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;h2 id=&quot;1、什么是链表？&quot;&gt;&lt;a href=&quot;#1、什么是链表？&quot; class=&quot;headerlink&quot; title=&quot;1、什么是链表？&quot;</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="数据结构" scheme="https://blog.yahyav2rayssr.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Vim 基本命令</title>
    <link href="https://blog.yahyav2rayssr.top/posts/154baef/"/>
    <id>https://blog.yahyav2rayssr.top/posts/154baef/</id>
    <published>2023-04-16T13:32:08.342Z</published>
    <updated>2023-04-16T13:32:08.344Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="跳至行首-x2F-行尾"><a href="#跳至行首-x2F-行尾" class="headerlink" title="跳至行首&#x2F;行尾"></a>跳至行首&#x2F;行尾</h2><p>跳至当前行行首</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">shift</span>+4命令可以敲出$字母</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash"></span><br><span class="language-bash"></span><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者数字0</span><br>0<br></code></pre></td></tr></table></figure><p>跳至当前行行尾</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">大写的A</span><br>A<br></code></pre></td></tr></table></figure><p></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h2 id=&quot;跳至行首-x2F-行尾&quot;&gt;&lt;a href=&quot;#跳至行首-x2F-行尾&quot; class=&quot;headerlink&quot; title=&quot;跳至行</summary>
      
    
    
    
    <category term="Vim" scheme="https://blog.yahyav2rayssr.top/categories/Vim/"/>
    
    
    <category term="vim" scheme="https://blog.yahyav2rayssr.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>Spring 基础</title>
    <link href="https://blog.yahyav2rayssr.top/posts/4e9ceea/"/>
    <id>https://blog.yahyav2rayssr.top/posts/4e9ceea/</id>
    <published>2023-04-16T13:30:00.702Z</published>
    <updated>2023-04-16T13:30:00.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AOP-详解"><a href="#AOP-详解" class="headerlink" title="AOP 详解"></a>AOP 详解</h1><h2 id="一、AOP-简介"><a href="#一、AOP-简介" class="headerlink" title="一、AOP 简介"></a>一、AOP 简介</h2><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP只允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志，事务，安全等。这些功能都是横向应用在业务处理中，而与它们对应的方法与其他代码基本没有联系，如异常处理和透明的持续性也都是如此，不仅增加了大量的代码量，还为程序后期的维护增生很多困难。</p><p>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p><h2 id="二、AOP-基本了解和通知方法"><a href="#二、AOP-基本了解和通知方法" class="headerlink" title="二、AOP 基本了解和通知方法"></a>二、AOP 基本了解和通知方法</h2><ol><li><strong>切面（Aspect）：一个关注点的模块化，这个关注点可能会横切多个对象。</strong><br>事务管理是J2EE应用中一个关于横切关注点的很好的例子。在spring AOP中，切面可以使用基于模式）或者基于Aspect注解方式来实现。通俗点说就是我们加入的切面类（比如log类），可以这么理解。</li><li><strong>连接点（Joinpoint）：在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。</strong><br>在Spring AOP中，一个连接点总是表示一个方法的执行。通俗的说就是加入切点的那个点</li><li><strong>通知（Advice）：在切面的某个特定的连接点上执行的动作。</strong><br>其中包括了“around”、“before”和“after”等不同类型的通知（通知的类型将在后面部分进行讨论）。许多AOP框架（包括Spring）都是以拦截器做通知模型，并维护一个以连接点为中心的拦截器链。</li><li><strong>切入点（Pointcut）：匹配连接点的断言。</strong><br>通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</li><li><strong>引入（Introduction）：用来给一个类型声明额外的方法或属性（也被称为连接类型声明（inter-type declaration））。</strong><br>Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。例如，你可以使用引入来使一个bean实现IsModified接口，以便简化缓存机制。</li><li><strong>目标对象（Target Object）： 被一个或者多个切面所通知的对象。</strong><br>也被称做被通知（advised）对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个被代理（proxied）对象。</li><li><strong>AOP代理（AOP Proxy）：AOP框架创建的对象，用来实现切面契约（例如通知方法执行等等）。</strong><br>在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</li><li><strong>织入（Weaving）：把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象。</strong><br>这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li></ol><h3 id="通知方法："><a href="#通知方法：" class="headerlink" title="通知方法："></a>通知方法：</h3><ol><li><p><strong>前置通知（Before advice）：</strong>在某连接点之前执行的通知，但这个通知不能阻止连接点之前的执行流程（除非它抛出一个异常）。</p></li><li><p><strong>后置通知（After returning advice）：</strong>在某连接点正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</p></li><li><p><strong>异常通知（After throwing advice）：</strong>在方法抛出异常退出时执行的通知。</p></li><li><p><strong>最终通知（After (finally) advice）：</strong>当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</p></li><li><p><strong>环绕通知（Around Advice）：</strong>包围一个连接点的通知，如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。</p><p>它也会选择是否继续执行连接点或直接返回它自己的返回值或抛出异常来结束执行。</p></li></ol><h2 id="三、Spring对AOP的支持"><a href="#三、Spring对AOP的支持" class="headerlink" title="三、Spring对AOP的支持"></a>三、Spring对AOP的支持</h2><p>Spring中AOP代理由Spring的IOC容器负责生成，管理，它的依赖关系也有IOC容器负责。因此，AOP代理可以直接使用容器中的其他bean示例作为目标，这种关系可由IOC容器的依赖注入提供(不熟悉依赖注入的可以看看我之前的博文)。Spring创建代理规则为:</p><p>  1、默认使用JDK动态代理来创建AOP代理，这样可以为任何接口示例创建代理</p><p>  2、当需要代理的类不是代理接口时，Spring会切换为使用CGLIB代理，也可强制使用CGLIB代理。(强制方法：在XML配置中修改 AOP 属性spring.aop.proxy-target-class&#x3D;true或在注释中修改@EnableAspectJAutoProxy(proxyTargetClass &#x3D; true)进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：代理对象的方法&#x3D;增强处理+被代理对象的方法。</p><p>exposeProxy：AOP生成对象时，绑定到ThreadLocal, 可以通过AopContext获取</p><h1 id="IOC（依赖注入）的基本实现方式"><a href="#IOC（依赖注入）的基本实现方式" class="headerlink" title="IOC（依赖注入）的基本实现方式"></a>IOC（依赖注入）的基本实现方式</h1><p>Java中创建一个对象分两步： </p><ol><li>通过关键字<strong>new创建一个对象</strong> </li><li>通过<strong>构造函数或setter函数为对象添加初始化参数 （参数可以是基本数据类型 也可以是引用数据类型（比如依赖的类））</strong></li></ol><p>当 Spring 出现后，<strong>对象的创建、成员变量的初始化、对象的销毁均由Spring完成。</strong> </p><p>那么，要让Spring帮助我们创建对象，我们首先需要将<strong>要创建的对象的类型</strong>、<strong>初始化的值</strong>告诉Spring，然后Spring会在程序启动的时候根据我们的要求创建对象。我们通过配置文件来告诉Spring要创建哪些对象，并告诉Spring如何创建这些对象。</p><h2 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h2><p><strong>在Spring中，默认情况下bean都是单例。也就是说，当我们向Spring请求一个bean对象时，Spring总给我们返回同一个bean对象。</strong><br><strong>注意：</strong>Spring 中所说的“单例”与Java中的单例稍有不同。Spring中的单例是指：在同一个ApplicationContext中相同名字的bean对象是同一个；而Java中的单例是指：整个JVM中单例的对象只有一个。<br>当然，我们可以通过改变bean标签的scope参数来设置bean的作用域。常用的scope对应的值有： </p><ul><li><p>singleton：在同一个Spring Context中，一个bean只有一个实例对象。(默认) </p></li><li><p>prototype：每次向Spring请求一个bean对象，Spring都会创建一个新的实例。</p></li><li><p><strong>会话（Session）</strong>：在web应用中，为每个会话创建一个bean实例。</p></li><li><p><strong>请求（Request）</strong>：在Web应用中，为每个请求创建一个bean实例。</p></li></ul><p><strong>依赖注入的方式分三种</strong></p><ol><li>构造函数注入</li><li>属性注入</li><li>set方法注入</li></ol><h2 id="自动装配与自动扫描"><a href="#自动装配与自动扫描" class="headerlink" title="自动装配与自动扫描"></a>自动装配与自动扫描</h2><p>简化Spring的配置主要分为两类： </p><ol><li>自动装配 </li><li>自动扫描</li></ol><h3 id="自动装配的种类"><a href="#自动装配的种类" class="headerlink" title="自动装配的种类"></a>自动装配的种类</h3><ol><li><p><strong>byName：根据属性的名字自动装配</strong></p><p>在bean标签中添加属性autowire&#x3D;”byName”。当Spring启动时，会寻找<strong>与person中成员变量名字相同的bean</strong>，并将该bean注给person的成员变量。</p></li><li><p><strong>byType：根据属性的类型自动装配</strong><br>在bean标签中添加属性autowire&#x3D;”byType”。当Spring启动时，会寻找<strong>与person中成员变量类型相同的bean</strong>，并将该bean注给person的成员变量。<br><strong>byType的缺点：</strong>如果某一类型的bean有多个，那Spring在通过byType为属性寻找同类型的bean时就会抛出异常。 </p></li><li><p><strong>constructor：根据构造器的参数类型自动装配</strong></p></li><li><p><strong>autodetect：最佳自动装配。首先采用constructor自动装配，若没有发现与构造器相匹配的Bean时，采用byType进行自动装配。</strong></p></li></ol><p><strong>@Autowired本质上采用byType进行自动装配，因此也存在与byType一样的问题：若同一类型的bean有多个时，或找不到该类型的bean，Spring就会抛出异常。</strong></p><h4 id="在注解中使用SpEL表达式"><a href="#在注解中使用SpEL表达式" class="headerlink" title="在注解中使用SpEL表达式"></a>在注解中使用SpEL表达式</h4><p>将名为father的bean注入给构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;#&#123;father&#125;&quot;)</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(Father father)</span>&#123;<br>      <span class="hljs-built_in">this</span>.father = father;<br>  &#125;<br></code></pre></td></tr></table></figure><p>将father对象中的id注入给id：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;#&#123;father.id&#125;&quot;)</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span>&#123;<br>       <span class="hljs-built_in">this</span>.id = id;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="自动检测"><a href="#自动检测" class="headerlink" title="自动检测"></a>自动检测</h2><p><strong>自动装配能够减少bean标签下property标签和constructor-arg标签的数量，而自动检测能降低bean标签的数量。</strong></p><h1 id="Spring-注解-Resource-和-Autowired-区别对比"><a href="#Spring-注解-Resource-和-Autowired-区别对比" class="headerlink" title="Spring 注解 @Resource 和 @Autowired 区别对比"></a>Spring 注解 @Resource 和 @Autowired 区别对比</h1><h2 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@<strong>Autowired</strong></h2><p>​@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualifier注解一起使用。(通过类型匹配找到多个candidate,在没有@Qualifier、@Primary注解的情况下，会使用对象名作为最后的fallback匹配)如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-meta">@Qualifier(&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">private</span> UserDao userDao; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a><strong>@Resource</strong></h2><p>​@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略。</p><p>​@Resourced标签是按照bean的名字来进行注入的，如果我们没有在使用@Resource时指定bean的名字，同时Spring容器中又没有该名字的bean,这时候@Resource就会退化为@Autowired即按照类型注入，这样就有可能违背了使用@Resource的初衷。所以建议在使用@Resource时都显示指定一下bean的名字@Resource(name&#x3D;”xxx”) </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br>    <span class="hljs-comment">// 下面两种@Resource只要使用一种即可</span><br>    <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">private</span> UserDao userDao; <span class="hljs-comment">// 用于字段上</span><br>    <br>    <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123; <span class="hljs-comment">// 用于属性的setter方法上</span><br>        <span class="hljs-built_in">this</span>.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结论：</strong></p><ul><li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li><li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li><li>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</li><li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li></ul><h1 id="Spring-中-Bean-的生命周期"><a href="#Spring-中-Bean-的生命周期" class="headerlink" title="Spring 中 Bean 的生命周期"></a>Spring 中 Bean 的生命周期</h1><p>对于普通的 Java 对象，当我们使用<code>new</code>关键字创建对象的时候，如果它没有任何引用，则其会被垃圾回收机制回收。而由 Spring IoC 容器托管的对象，它们的生命周期则是完全由容器控制。在 Spring 中，每个 Bean 的生命周期大致如下：</p><img src="/posts/4e9ceea/109.jpg" class><h2 id="实例化-Bean"><a href="#实例化-Bean" class="headerlink" title="实例化 Bean"></a>实例化 Bean</h2><p>对于BeanFactory容器来说，当用户向容器请求一个尚未初始化的 Bean 或初始化 Bean 的时候，如果需要注入另一个尚未初始化的依赖，容器就会调用createBean进行实例化；对于ApplicationContext容器来说，当容器启动结束后，便实例化所有的 Bean。</p><p>容器通过获取BeanDefinition对象中的信息进行实例化。并且这一步仅仅是简单的实例化，并未进行依赖注入。 实例化对象被包装在BeanWrapper对象中，BeanWrapper提供了设置对象属性的接口，从而避免了使用反射机制设置属性。</p><h2 id="设置对象属性（依赖注入）"><a href="#设置对象属性（依赖注入）" class="headerlink" title="设置对象属性（依赖注入）"></a>设置对象属性（依赖注入）</h2><p>实例化后的对象被封装在BeanWrapper对象中，并且此时对象仍然是一个原生的状态，并没有进行依赖注入。 紧接着，Spring 根据BeanDefinition中的信息进行依赖注入，并且通过BeanWrapper提供的设置属性的接口完成依赖注入。</p><h2 id="注入-Aware-接口"><a href="#注入-Aware-接口" class="headerlink" title="注入 Aware 接口"></a>注入 Aware 接口</h2><p>紧接着，Spring 会检测该对象是否实现了xxxAware接口，并将相关的xxxAware实例注入给 Bean：</p><p>如果 Bean 实现了BeanNameAware接口，Spring 将 Bean 的 ID 传递给setBeanName()方法。实现BeanNameAware主要是为了通过 Bean 的引用来获得 Bean 的 ID，一般业务中是很少有用到 Bean 的 ID 的。<br>如果 Bean 实现了BeanFactoryAware接口，Spring 将调用setBeanDactory(BeanFactory bf)方法并把BeanFactory容器实例作为参数传入。实现BeanFactoryAware主要目的是为了获取 Spring 容器，如 Bean 通过 Spring 容器发布事件等。<br>如果 Bean 实现了ApplicationContextAware接口，Spring 容器将调用setApplicationContext(ApplicationContext ctx)方法，把应用上下文作为参数传入，作用与BeanFactory类似都是为了获取 Spring 容器，不同的是 Spring 容器在调用setApplicationContext方法时会把它自己作为setApplicationContext的参数传入，而 Spring 容器在调用setBeanDactory前需要程序员自己指定（注入）setBeanDactory里的参数BeanFactory。</p><h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p>当经过上述几个步骤后，Bean 对象已经被正确构造，但如果你想要对象被使用前再进行一些自定义的处理，就可以通过BeanPostProcessor接口实现。 该接口提供了两个函数：</p><p>postProcessBeforeInitialzation(Object bean, String beanName)当前正在初始化的 Bean 对象会被传递进来，我们就可以对这个 Bean 作任何处理。这个函数会先于InitialzationBean执行，因此称为前置处理。 所有Aware接口的注入就是在这一步完成的。<br>postProcessAfterInitialzation(Object bean, String beanName)当前正在初始化的 Bean 对象会被传递进来，我们就可以对这个 Bean 作任何处理。这个函数会在InitialzationBean完成后执行，因此称为后置处理。</p><h2 id="InitializingBean-与-init-method"><a href="#InitializingBean-与-init-method" class="headerlink" title="InitializingBean 与 init-method"></a>InitializingBean 与 init-method</h2><p>当BeanPostProcessor的前置处理完成后就会进入本阶段。 InitializingBean接口只有一个函数：</p><p>afterPropertiesSet()<br>这一阶段也可以在 Bean 正式构造完成前增加我们自定义的逻辑，但它与前置处理不同，由于该函数并不会把当前 Bean 对象传进来，因此在这一步没办法处理对象本身，只能增加一些额外的逻辑。 若要使用它，我们需要让 Bean 实现该接口，并把要增加的逻辑写在该函数中。然后，Spring 会在前置处理完成后检测当前 Bean 是否实现了该接口，并执行afterPropertiesSet函数。</p><p>当然，Spring 为了降低对客户代码的侵入性，给 Bean 的配置提供了init-method属性，该属性指定了在这一阶段需要执行的函数名。Spring 便会在初始化阶段执行我们设置的函数。init-method本质上仍然使用了InitializingBean接口。</p><h2 id="DisposableBean-和-destroy-method"><a href="#DisposableBean-和-destroy-method" class="headerlink" title="DisposableBean 和 destroy-method"></a>DisposableBean 和 destroy-method</h2><p>如果 Bean 实现了DispostbleBean接口，Spring 将调用它的destory方法，作用与在配置文件中对 Bean 使用destory-method属性的作用一样，都是在 Bean 实例销毁前执行的方法。</p><p>至此，Spring 中 Bean 的经历了从创建到消耗的整个生命周期的过程。</p><h1 id="Spring-事务传播行为"><a href="#Spring-事务传播行为" class="headerlink" title="Spring 事务传播行为"></a>Spring 事务传播行为</h1><h2 id="什么是事务传播行为？"><a href="#什么是事务传播行为？" class="headerlink" title="什么是事务传播行为？"></a>什么是事务传播行为？</h2><p>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</p><h2 id="Spring中七种事务传播行为"><a href="#Spring中七种事务传播行为" class="headerlink" title="Spring中七种事务传播行为"></a>Spring中七种事务传播行为</h2><table><thead><tr><th><strong>事务传播行为类型</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><h2 id="REQUIRED-REQUIRES-NEW-NESTED-异同"><a href="#REQUIRED-REQUIRES-NEW-NESTED-异同" class="headerlink" title="REQUIRED, REQUIRES_NEW, NESTED 异同"></a>REQUIRED, REQUIRES_NEW, NESTED 异同</h2><ul><li><p>NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。</p><p>但是REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，</p><p>外围方法事务也将被回滚。而NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。</p></li><li><p>NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。</p><p>但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。</p><p>而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。</p></li></ul><h1 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h1><img src="/posts/4e9ceea/207.png" class alt="img"><ol><li>开始实例化 person </li><li>设置 name 属性</li><li>Person 实现了 BeanNameAware 接口，Spring 将 Person 的 ID&#x3D;person传递给 setBeanName 方法</li><li>Person 实现了 BeanFactoryAware 接口，Spring 调用 setBeanFactory()方法，将 BeanFactory 容器实例传入</li><li>Person 实现了 ApplicationContextAware 接口，Spring 调用 setApplicationContext()方法，将 person 所在的应用上下文的引用传入进来</li><li>初始化 Person 之前执行的方法（BeanPostProcessor 的 postProcessBeforeInitialization 方法）</li><li>@PostConstruct 调用自定义的初始化方法</li><li>Person 实现了 InitializingBean 接口，Spring 调用它的afterPropertiesSet()方法。类似地，如果 person 使用 init-method 声明了初始化方法，该方法也会被调用</li><li>xml 中声明的 init-method 方法</li><li>初始化 Person 完成之后执行的方法（BeanPostProcessor 的 postProcessAfterInitialization 方法）</li><li>实例化完成使用属性：Person name &#x3D; nasus（main结束方法）</li><li>@PreDestory 调用自定义销毁方法</li><li>Person 实现了 DisposableBean 接口，Spring 调用它的destroy() 接口方法。同样，如果 person 使用 destroy-method 声明了销毁方法，该方法也会被调用</li><li>xml 中声明的 destroy-method 方法</li></ol><h1 id="servlet-执行流程"><a href="#servlet-执行流程" class="headerlink" title="servlet 执行流程"></a>servlet 执行流程</h1><img src="/posts/4e9ceea/12546411-497191fff892d42b.jpg" class alt="img"><h1 id="Java-SPI-和-Spring-SPI"><a href="#Java-SPI-和-Spring-SPI" class="headerlink" title="Java SPI 和 Spring SPI"></a>Java SPI 和 Spring SPI</h1><p>service provider framework是一个系统， 实现了SPI， 在系统里多个服务提供者模块可以提供一个服务的实现， 系统让客户端可以使用这些实现， 从而实现解耦。</p><p>一个service provider framework有3个主要的组成部分:</p><ol><li>一个服务接口， 供服务提供者实现。</li><li>一个注册API， 系统使用这个API来注册服务接口的实现， 从而让客户端使用。</li><li>一个service access API， 客户端可以选择获取一个服务的实例。</li></ol><h2 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI:"></a>Java SPI:</h2><p>Service Provider Interface(SPI)是一个可以被第三方扩展或实现的API， 它可以用来实现框架扩展和可替换的模块。</p><p>使用步骤：</p><ol><li>服务调用方通过 <code>ServiceLoader.load</code> 加载服务接口的实现类实例</li><li>服务提供方实现服务接口后， 在自己Jar包的META-INF&#x2F;services目录下新建一个接口名全名的文件， 并将具体实现类全名写入。</li></ol><h2 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h2><p>很多开源库中都直接或间接地使用了Java的SPI机制， 如Spring中就有类似的SPI机制， 通过SpringFactoriesLoader代替JDK中的ServiceLoader， 通过META-INF&#x2F;spring.factories文件代替META-INF&#x2F;service目录下的描述文件, 原理都是使用了Java的反射机制。</p><p>Spring提供的SPI只需要且只有一个文件， 就是META-INF&#x2F;spring.factories</p><p>Spring的SPI也更加灵活， 不必要key是接口， 值是实现类， 例如Spring boot使用这种方式来处理自动配置的bean: key是注解(如org.springframework.boot.autoconfig.EnableAutoConfiguration)， 值是被标记@Configuration的类。</p><p>另外Spring中还有converter spi和formatter spi。</p><p>converter可以用做任意两个类型之间的转换， formatter spi用做string类型和其他类型之间的转换。</p><p>Converter和Formatter接口即服务接口</p><p>ConersionService实现了ConverterRegistry接口， 提供服务实现的注册， 同时也提供可访问功能。</p><p>而<code>FormattingConversionService</code> 则实现了FormatterRegistry接口， 实现了formatter实现类的注册和调用。 同时FormattingConversionService也实现了ConversionService接口。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;AOP-详解&quot;&gt;&lt;a href=&quot;#AOP-详解&quot; class=&quot;headerlink&quot; title=&quot;AOP 详解&quot;&gt;&lt;/a&gt;AOP 详解&lt;/h1&gt;&lt;h2 id=&quot;一、AOP-简介&quot;&gt;&lt;a href=&quot;#一、AOP-简介&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="Spring" scheme="https://blog.yahyav2rayssr.top/categories/Java/Spring/"/>
    
    
    <category term="spring" scheme="https://blog.yahyav2rayssr.top/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud 组件概念</title>
    <link href="https://blog.yahyav2rayssr.top/posts/b27a891c/"/>
    <id>https://blog.yahyav2rayssr.top/posts/b27a891c/</id>
    <published>2023-04-16T13:28:04.657Z</published>
    <updated>2023-04-16T13:28:04.657Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>Spring Cloud是一系列框架的有序集合</strong>。它利用<strong>Spring Boot</strong>的开发便利性巧妙地简化了分布式系统基础设施的开发，如<strong>服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控</strong>等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 <strong>Spring Cloud正是对Netflix的多个开源组件进一步的封装而成</strong>，同时又实现了和云端平台，和Spring Boot开发框架很好的集成。 Spring Cloud是一个相对比较新的微服务框架，<strong>2016年才推出1.0的release版本</strong>. 虽然Spring Cloud时间最短, 但是相比Dubbo等RPC框架, <strong>Spring Cloud提供的全套的分布式系统解决方案</strong>。 Spring Cloud 为开发者提供了在分布式系统（<strong>配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全居琐，leader选举，分布式session，集群状态</strong>）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。</p><img src="/posts/b27a891c/155.jpg" style="zoom: 80%;"><p>从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。</p><ul><li>其中Eureka负责服务的注册与发现，很好将各服务连接起来</li><li>Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。</li><li>Hystrix dashboard,Turbine 负责监控 Hystrix的熔断情况，并给予图形化的展示</li><li>Spring Cloud Config 提供了统一的配置中心服务</li><li>当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息</li><li>所有对外的请求和服务，我们都通过Zuul来进行转发，起到API网关的作用</li><li>最后我们使用Sleuth+Zipkin将所有的请求数据记录下来，方便我们进行后续分析</li></ul><h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如<strong>Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色</strong>。对于我们想快速实践微服务的开发者来说，第一类子项目就已经足够使用，如：<strong>Spring Cloud Netflix</strong>，是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。 通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。</p><h2 id="Eureka-服务发现"><a href="#Eureka-服务发现" class="headerlink" title="Eureka 服务发现"></a>Eureka 服务发现</h2><p>涉及注解：@EnableEurekaServer、@EnableEurekaClient</p><img src="/posts/b27a891c/156.jpg" style="zoom:80%;"><img src="/posts/b27a891c/157.jpg" style="zoom:80%;"><p>Eureka两个组件组成：<strong>Eureka服务器和Eureka客户端</strong>。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</p><h2 id="Ribbon-客户端负载均衡"><a href="#Ribbon-客户端负载均衡" class="headerlink" title="Ribbon 客户端负载均衡"></a>Ribbon 客户端负载均衡</h2><p>涉及注解：@LoadBalanced、@RibbonClient(配置)</p><img src="/posts/b27a891c/158.jpg" style="zoom:80%;"><p>Ribbon，主要提供客户侧的软件负载均衡算法。 Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。下面是用到的一些<strong>负载均衡策略</strong>：</p><ul><li><p>轮询策略（RoundRobinRule）</p><p>轮询策略理解起来比较简单，就是拿到所有的server集合，然后根据id进行遍历。这里的id是ip+端口，Server实体类中定义的id属性如下：</p></li><li><p>随机策略（RandomRule）</p><p>随机策略：使用jdk自带的随机数生成工具，生成一个随机数，然后去可用服务列表中拉取服务节点Server。如果当前节点不可用，则进入下一轮随机策略，直到选到可用服务节点为止。</p></li><li><p>可用过滤策略（AvailabilityFilteringRule）</p><p>策略描述：过滤掉连接失败的服务节点，并且过滤掉高并发的服务节点，然后从健康的服务节点中，使用轮询策略选出一个节点返回。</p></li><li><p>响应时间权重策略（WeightedResponseTimeRule）</p><p>策略描述：根据响应时间，分配一个权重weight，响应时间越长，weight越小，被选中的可能性越低。</p></li><li><p>轮询失败重试策略（RetryRule）</p><p>轮询失败重试策略（RetryRule）是这样工作的，首先使用轮询策略进行负载均衡，如果轮询失败，则再使用轮询策略进行一次重试，相当于重试下一个节点，看下一个节点是否可用，如果再失败，则直接返回失败。</p></li><li><p>并发量最小可用策略（BestAvailableRule）</p><p>选择一个并发量最小的server返回。如何判断并发量最小呢？ServerStats有个属性activeRequestCount，这个属性记录的就是server的并发量。轮询所有的server，选择其中activeRequestCount最小的那个server，就是并发量最小的服务节点。</p></li><li><p>ZoneAvoidanceRule</p><p>复合判断server所在区域的性能和server的可用性，来选择server返回。</p></li></ul><p>综述负载均衡策略如下：</p><ol><li>轮询策略</li><li>随机策略</li><li>可用过滤策略</li><li>响应时间权重策略</li><li>轮询失败重试策略</li><li>并发量最小可用策略</li></ol><p>Ribbon中还包括以下功能：</p><ul><li>易于与服务发现组件（比如Netflix的Eureka）集成</li><li>使用Archaius完成运行时配置</li><li>使用JMX暴露运维指标，使用Servo发布</li><li>多种可插拔的序列化选择</li><li>异步和批处理操作（即将推出）</li><li>自动SLA框架（即将推出）</li><li>系统管理&#x2F;指标控制台（即将推出）</li></ul><p><strong>ribbon架构示例</strong></p><img src="/posts/b27a891c/159.jpg" style="zoom:80%;"><ul><li>一个服务注册中心，eureka server,端口为8761</li><li>service-hi工程跑了两个实例，端口分别为8762,8763，分别向服务注册中心注册</li><li>sercvice-ribbon端口为8764,向服务注册中心注册</li><li>当sercvice-ribbon通过restTemplate调用service-hi的hi接口时，因为用ribbon进行了负载均衡，会轮流的调用service-hi：8762和8763 两个端口的hi接口；</li></ul><h2 id="Config-Server"><a href="#Config-Server" class="headerlink" title="Config Server"></a>Config Server</h2><p>涉及注解：@EnableConfigServer</p><p>俗称的配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，<strong>目前支持本地存储、Git以及Subversion</strong>。</p><img src="/posts/b27a891c/160.jpg" style="zoom:80%;"><blockquote><p>将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件。这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p></blockquote><img src="/posts/b27a891c/161.jpg" style="zoom:80%;"><p>Spring Cloud Config就是我们通常意义上的配置中心。Spring Cloud Config-把应用原本放在本地文件的配置抽取出来放在<strong>中心服务器</strong>，本质是配置信息从本地迁移到云端。从而能够提供更好的管理、发布能力。 Spring Cloud Config分服务端和客户端，服务端负责将git（svn）中存储的配置文件发布成REST接口，客户端可以从服务端REST接口获取配置。但客户端并不能主动感知到配置的变化，从而主动去获取新的配置，这需要每个客户端通过POST方法触发各自的&#x2F;refresh。</p><h2 id="Hystrix-熔断器"><a href="#Hystrix-熔断器" class="headerlink" title="Hystrix 熔断器"></a>Hystrix 熔断器</h2><p>涉及注解：@HystrixCommad(fallback&#x3D;”方法名”)、结合@FeignClient(fallbackFactory&#x3D;xxx.class)</p><p>熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</p><img src="/posts/b27a891c/162.jpg" style="zoom:80%;"><p>断路器(Cricuit Breaker)是一种能够在远程服务不可用时自动熔断(打开开关)，并在远程服务恢复时自动恢复(闭合开关)的设施，Spring Cloud通过Netflix的<strong>Hystrix组件</strong>提供断路器、资源隔离与自我修复功能。</p><p>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p><img src="/posts/b27a891c/163.jpg" alt="img" style="zoom:80%;"><p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p><img src="/posts/b27a891c/164.jpg" alt="img" style="zoom:80%;"><img src="/posts/b27a891c/165.jpg" alt="img" style="zoom:80%;"><p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p><img src="/posts/b27a891c/166.jpg" alt="img" style="zoom:80%;"><p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p><img src="/posts/b27a891c/167.jpg" alt="img" style="zoom:80%;"><p><strong>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值</strong>。</p><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p><p>如下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成了。</p><img src="/posts/b27a891c/168.jpg" alt="img" style="zoom:80%;"><p>在这种情况下就需要整个服务机构具有故障隔离的功能，避免某一个服务挂掉影响全局。<strong>在Spring Cloud 中Hystrix组件就扮演这个角色</strong>。 Hystrix会在某个服务连续调用N次不响应的情况下，立即通知调用端调用失败，避免调用端持续等待而影响了整体服务。Hystrix间隔时间会再次检查此服务，如果服务恢复将继续提供服务。</p><p><strong>Hystrix Dashboard和Turbine</strong> 当熔断发生的时候需要迅速的响应来解决问题，避免故障进一步扩散，那么对熔断的监控就变得非常重要。熔断的监控现在有两款工具：<strong>Hystrix-dashboard</strong>和<strong>Turbine</strong></p><p>Hystrix-dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以直观地看到各Hystrix Command的请求响应时间, 请求成功率等数据。但是只使用Hystrix Dashboard的话, 你只能看到单个应用内的服务信息, 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到Hystrix Dashboard上, 这个工具就是<strong>Turbine</strong>. 监控的效果图如下：</p><img src="/posts/b27a891c/169.jpg" alt="img" style="zoom:80%;"><h2 id="Zuul-服务网关，智能路由"><a href="#Zuul-服务网关，智能路由" class="headerlink" title="Zuul 服务网关，智能路由"></a>Zuul 服务网关，智能路由</h2><p>涉及注解：@EnableZuulProxy</p><p>在微服务架构模式下，后端服务的实例数一般是动态的，对于客户端而言很难发现动态改变的服务实例的访问地址信息。因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。</p><img src="/posts/b27a891c/170.jpg" alt="img" style="zoom:80%;"><p>Spring Cloud体系中支持API Gateway落地的技术就是<strong>Zuul</strong>。Spring Cloud Zuul路由是微服务架构中不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p><p>它的具体作用<strong>就是服务转发，接收并转发所有内外部的客户端调用。使用Zuul可以作为资源的统一访问入口，同时也可以在网关做一些权限校验等类似的功能</strong>。</p><p>Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。</p><img src="/posts/b27a891c/171.jpg" alt="img" style="zoom:80%;"><img src="/posts/b27a891c/172.jpg" alt="img" style="zoom:80%;"><p>类似Nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p><h2 id="Netflix-Archaius"><a href="#Netflix-Archaius" class="headerlink" title="Netflix Archaius"></a>Netflix Archaius</h2><img src="/posts/b27a891c/173.jpg" alt="img" style="zoom:80%;"><p>配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置，原理是<strong>每隔60s（默认，可配置）从配置源读取一次内容</strong>，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用archaius的API来读取。</p><h2 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h2><img src="/posts/b27a891c/174.jpg" alt="img" style="zoom:80%;"><p>事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，<strong>可与Spring Cloud Config联合实现热部署</strong>。相当于水浒传中日行八百里的神行太保戴宗，确保各个小弟之间消息保持畅通。</p><p>分布式消息队列，是对Kafka, MQ的封装；事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现<strong>热部署</strong>。 Spring cloud bus通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其他的消息指令。<strong>Spring bus的一个核心思想是通过分布式的启动器对spring boot应用进行扩展，也可以用来建立一个多个应用之间的通信频道。</strong>目前唯一实现的方式是用AMQP消息代理作为通道，同样特性的设置（有些取决于通道的设置）在更多通道的文档中。 Spring cloud bus被国内很多都翻译为消息总线，也挺形象的。大家可以将它理解为管理和传播所有分布式项目中的消息既可，其实本质是利用了MQ的广播机制在分布式的系统中传播消息，目前常用的有Kafka和RabbitMQ。利用bus的机制可以做很多的事情，其中配置中心客户端刷新就是典型的应用场景之一，我们用一张图来描述bus在配置中心使用的机制。</p><img src="/posts/b27a891c/176.jpg" alt="img" style="zoom:80%;"><p>根据此图我们可以看出利用Spring Cloud Bus做配置更新的步骤:</p><ol><li>提交代码触发post给客户端A发送bus&#x2F;refresh</li><li>客户端A接收到请求从Server端更新配置并且发送给Spring Cloud Bus</li><li>Spring Cloud bus接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求Server端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ol><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><img src="/posts/b27a891c/175.jpg" alt="img" style="zoom:80%;"><p>对Spring Security的封装，并能配合Netflix使用，安全工具包，为你的应用程序添加安全控制，<strong>主要是指OAuth2</strong>。 基于spring security的安全工具包，为你的应用程序添加安全控制</p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><img src="/posts/b27a891c/177.jpg" alt="img" style="zoom:80%;"><p>对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用；操作Zookeeper的工具包，<strong>用于使用zookeeper方式的服务注册和发现</strong>。 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理，抱了Zookeeper的大腿。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><img src="/posts/b27a891c/178.jpg" alt="img" style="zoom:80%;"><p>数据流；数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。 Spring Cloud Stream是创建消息驱动微服务应用的框架。Spring Cloud Stream是基于spring boot创建，用来建立单独的／工业级spring应用，使用spring integration提供与消息代理之间的连接。数据流操作开发包，封装了与Redis、Rabbit、Kafka等发送接收消息。 一个业务会牵扯到多个任务，任务之间是通过事件触发的。</p><h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><img src="/posts/b27a891c/179.jpg" alt="img" style="zoom:80%;"><p>随着服务的越来越多，对调用链的分析会越来越复杂，如服务之间的调用关系、某个请求对应的调用链、调用之间消费的时间等，对这些信息进行监控就成为一个问题。在实际的使用中我们需要监控服务和服务之间通讯的各项指标，这些数据将是我们改进系统架构的主要依据。因此分布式的链路跟踪就变的非常重要，<strong>Spring Cloud也给出了具体的解决方案：Spring Cloud Sleuth和Zipkin</strong>。</p><p>服务跟踪；日志收集工具包，封装了Dapper,Zipkin和HTrace操作。 日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。</p><p><strong>简介</strong></p><p>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。</p><p><strong>服务追踪分析</strong></p><p>微服务架构上通过业务来划分服务的，通过<strong>REST调用</strong>，对外暴露的一个接口，<strong>可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败</strong>。随着业务的不断扩张，服务之间互相调用会越来越复杂。</p><img src="/posts/b27a891c/180.jpg" alt="img" style="zoom:80%;"><p>随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下：</p><img src="/posts/b27a891c/181.jpg" alt="img" style="zoom:80%;"><p><strong>术语</strong></p><ul><li>Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址) span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。</li><li>Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。</li><li>Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束 cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始 sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟 ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间 cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间 将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</li></ul><img src="/posts/b27a891c/182.jpg" alt="img" style="zoom:80%;"><h2 id="Feign-使用HTTP请求远程服务"><a href="#Feign-使用HTTP请求远程服务" class="headerlink" title="Feign 使用HTTP请求远程服务"></a>Feign 使用HTTP请求远程服务</h2><p>涉及注解：@FeignClient(“微服务名称”)　　注：此注解用于接口</p><img src="/posts/b27a891c/183.jpg" alt="img" style="zoom:80%;"><p>在Spring Cloud Netflix栈中，各个微服务都是以HTTP接口的形式暴露自身服务的，因此在调用远程服务时就必须使用HTTP客户端。我们可以使用JDK原生的URLConnection、Apache的Http Client、Netty的异步HTTP Client, Spring的RestTemplate。但是，用起来最方便、最优雅的还是要属Feign了。 <strong>Feign是一种声明式、模板化的HTTP客户端</strong>。在Spring Cloud中使用Feign, 我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。 通过Feign， 我们能把HTTP远程调用对开发者完全透明，得到与调用本地方法一致的编码体验。这一点与阿里Dubbo中暴露远程服务的方式类似，<strong>区别在于Dubbo是基于私有二进制协议，而Feign本质上还是个HTTP客户端</strong>。如果是在用Spring Cloud Netflix搭建微服务，那么Feign无疑是最佳选择。</p><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p><p>简而言之：</p><ul><li>Feign 采用的是基于接口的注解</li><li>Feign 整合了ribbon</li></ul><h2 id="Cloud-Foundry"><a href="#Cloud-Foundry" class="headerlink" title="Cloud Foundry"></a>Cloud Foundry</h2><img src="/posts/b27a891c/184.jpg" alt="img" style="zoom:80%;"><p>Cloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题 其实就是与CloudFoundry进行集成的一套解决方案，抱了<strong>Cloud Foundry</strong>的大腿。</p><h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><img src="/posts/b27a891c/185.jpg" alt="img" style="zoom:80%;"><p>Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：<strong>选举、集群的状态一致性、全局锁、tokens等</strong>常见状态模式的抽象和实现。 如果把不同的帮派组织成统一的整体，Spring Cloud Cluster已经帮你提供了很多方便组织成统一的工具。</p><h2 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h2><img src="/posts/b27a891c/186.jpg" alt="img" style="zoom:80%;"><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,<strong>由 HashiCorp 公司用 Go 语言开发</strong>, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对. Spring Cloud Consul 封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</p><h2 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h2><img src="/posts/b27a891c/187.jpg" alt="img" style="zoom:80%;"><p>Data flow 是一个用于开发和执行大范围数据处理其模式包括ETL，批量运算和持续运算的统一编程模型和托管服务。 对于在现代运行环境中可组合的微服务程序来说，Spring Cloud data flow是一个原生云可编配的服务。使用Spring Cloud data flow，开发者可以为像数据抽取，实时分析，和数据导入&#x2F;导出这种常见用例创建和编配数据通道 （data pipelines）。 Spring Cloud data flow 是基于原生云对 spring XD的重新设计，该项目目标是简化大数据应用的开发。Spring XD 的流处理和批处理模块的重构分别是基于 spring boot的stream 和 task&#x2F;batch 的微服务程序。这些程序现在都是自动部署单元而且他们原生的支持像 Cloud Foundry、Apache YARN、Apache Mesos和Kubernetes 等现代运行环境。 Spring Cloud data flow 为基于微服务的分布式流处理和批处理数据通道提供了一系列模型和最佳实践。</p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><img src="/posts/b27a891c/188.jpg" alt="img" style="zoom:80%;"><p>Spring Cloud Task 主要解决短命微服务的任务管理，任务调度的工作，比如说某些定时任务晚上就跑一次，或者某项数据分析临时就跑几次。</p><h2 id="Spring-Cloud-Connectors"><a href="#Spring-Cloud-Connectors" class="headerlink" title="Spring Cloud Connectors"></a>Spring Cloud Connectors</h2><img src="/posts/b27a891c/189.jpg" alt="img" style="zoom:80%;"><p>Spring Cloud Connectors 简化了连接到服务的过程和从云平台获取操作的过程，有很强的扩展性，可以利用Spring Cloud Connectors来构建你自己的云平台。 便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。</p><h2 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h2><img src="/posts/b27a891c/192.jpg" alt="img" style="zoom:80%;"><p>Spring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。</p><p><strong>3.20、Spring Cloud CLI</strong></p><img src="/posts/b27a891c/190.jpg" alt="img" style="zoom:80%;"><p>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</p><h2 id="Netflix-Turbine"><a href="#Netflix-Turbine" class="headerlink" title="Netflix Turbine"></a>Netflix Turbine</h2><img src="/posts/b27a891c/191.jpg" alt="img" style="zoom:80%;"><p>Turbine是聚合服务器发送事件流数据的一个工具，用来监控集群下hystrix的metrics情况。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Spring Cloud是一系列框架的有序集合&lt;/strong&gt;。它利用&lt;strong&gt;Spring Boot&lt;/stron</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="Spring" scheme="https://blog.yahyav2rayssr.top/categories/Java/Spring/"/>
    
    
    <category term="springcloud" scheme="https://blog.yahyav2rayssr.top/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>Spring 启动流程</title>
    <link href="https://blog.yahyav2rayssr.top/posts/2547f24d/"/>
    <id>https://blog.yahyav2rayssr.top/posts/2547f24d/</id>
    <published>2023-04-16T13:27:33.944Z</published>
    <updated>2023-04-16T13:27:33.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="springboot-启动过程"><a href="#springboot-启动过程" class="headerlink" title="springboot 启动过程"></a>springboot 启动过程</h2><p>每个SpringBoot程序都有一个主入口，也就是main方法，main里面调用SpringApplication.run()启动整个spring-boot程序，该方法所在类需要使用@SpringBootApplication注解，以及@ImportResource注解(if need)，@SpringBootApplication包括三个注解，功能如下：@EnableAutoConfiguration：SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置<br>@SpringBootConfiguration(内部为@Configuration)：被标注的类等于在spring的XML配置文件中(applicationContext.xml)，装配所有bean事务，提供了一个spring的上下文环境</p><p>@ComponentScan：组件扫描，可自动发现和装配Bean，默认扫描SpringApplication的run方法里的Booter.class所在的包路径下文件，所以最好将该启动类放到根包路径下| <img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70.png" class alt="在这里插入图片描述"></p><p>SpringBoot启动类</p><p>首先进入run方法</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157186504864.png" class alt="在这里插入图片描述"><p>run方法中去创建了一个SpringApplication实例，在该构造方法内，我们可以发现其调用了一个初始化的initialize方法</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157187036467.png" class alt="在这里插入图片描述"><p>这里主要是为SpringApplication对象赋一些初值。构造函数执行完毕后，我们回到run方法</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157187444670.png" class alt="在这里插入图片描述"><p>该方法中实现了如下几个关键步骤：</p><p>1.创建了应用的监听器SpringApplicationRunListeners并开始监听</p><p>2.加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment，类图如下</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157188032073.png" class alt="在这里插入图片描述"><p>可以看出，*Environment最终都实现了PropertyResolver接口，我们平时通过environment对象获取配置文件中指定Key对应的value方法时，就是调用了propertyResolver接口的getProperty方法</p><p>3.配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</p><p>4.创建run方法的返回对象：ConfigurableApplicationContext(应用配置上下文)，我们可以看一下创建方法：</p>，如果不存在，再加载默认的环境配置（通过是否是web environment判断），默认选择AnnotationConfigApplicationContext注解上下文（通过扫描所有注解类来加载bean），最后通过BeanUtils实例化上下文对象，并返回，ConfigurableApplicationContext类图如下：<img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157188495079.png" class alt="在这里插入图片描述">主要看其继承的两个方向：<p>LifeCycle：生命周期类，定义了start启动、stop结束、isRunning是否运行中等生命周期空值方法</p><p>ApplicationContext：应用上下文类，其主要继承了beanFactory(bean的工厂类)</p><p>5.回到run方法内，prepareContext方法将listeners、environment、applicationArguments、banner等重要组件与上下文对象关联</p><p>6.接下来的refreshContext(context)方法(初始化方法如下)将是实现spring-boot-starter-*(mybatis、redis等)自动化配置的关键，包括spring.factories的加载，bean的实例化等核心工作。</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157188777782.png" class alt="在这里插入图片描述"><p>refresh方法</p><p>配置结束后，Springboot做了一些基本的收尾工作，返回了应用环境上下文。回顾整体流程，Springboot的启动，主要创建了配置环境(environment)、事件监听(listeners)、应用上下文(applicationContext)，并基于以上条件，在容器中开始实例化我们需要的Bean，至此，通过SpringBoot启动的程序已经构造完成，接下来我们来探讨自动化配置是如何实现。</p><h2 id="自动化配置"><a href="#自动化配置" class="headerlink" title="自动化配置"></a>自动化配置</h2><p>之前的启动结构图中，我们注意到无论是应用初始化还是具体的执行过程，都调用了SpringBoot自动配置模块</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157189094485.png" class alt="在这里插入图片描述">SpringBoot自动配置模块<p>该配置模块的主要使用到了SpringFactoriesLoader，即Spring工厂加载器，该对象提供了loadFactoryNames方法，入参为factoryClass和classLoader，即需要传入上图中的工厂类名称和对应的类加载器，方法会根据指定的classLoader，加载该类加器搜索路径下的指定文件，即spring.factories文件，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，所以文件中一般为如下图这种一对多的类名集合，获取到这些实现类的类名后，loadFactoryNames方法返回类名集合，方法调用方得到这些集合后，再通过反射获取这些类的类对象、构造方法，最终生成实例</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157189311788.png" class alt="在这里插入图片描述"><p>工厂接口与其若干实现类接口名称</p><p>下图有助于我们形象理解自动配置流程</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157189576091.png" class alt="在这里插入图片描述">SpringBoot自动化配置关键组件关系图<p>mybatis-spring-boot-starter、spring-boot-starter-web等组件的META-INF文件下均含有spring.factories文件，自动配置模块中，SpringFactoriesLoader收集到文件中的类全名并返回一个类全名的数组，返回的类全名通过反射被实例化，就形成了具体的工厂实例，工厂实例来生成组件具体需要的bean。</p><p>之前我们提到了EnableAutoConfiguration注解，其类图如下</p>，重点关注一下AutoConfigurationImportSelector的selectImports方法<img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-168157190157197.png" class alt="在这里插入图片描述"><p>该方法在springboot启动流程——bean实例化前被执行，返回要实例化的类信息列表。我们知道，如果获取到类信息，spring自然可以通过类加载器将类加载到jvm中，现在我们已经通过spring-boot的starter依赖方式依赖了我们需要的组件，那么这些组建的类信息在select方法中也是可以被获取到的，不要急我们继续向下分析</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-1681571903780100.png" class alt="在这里插入图片描述">该方法中的getCandidateConfigurations方法，通过方法注释了解到，其返回一个自动配置类的类名列表，方法调用了loadFactoryNames方法，查看该方法到项目系统路径下所有的spring.factories文件中找到相应的key，从而加载里面的类。我们就选取这个mybatis-spring-boot-autoconfigure下的spring.factories文件<img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-1681571911818109.png" class alt="在这里插入图片描述">进入org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration中，主要看一下类头<img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-1681571913850112.png" class alt="在这里插入图片描述"><p>发现@Spring的Configuration，俨然是一个通过注解标注的springBean，继续向下看，</p><p>@ConditionalOnClass({ SqlSessionFactory.class, SqlSessionFactoryBean.class})这个注解的意思是：当存在SqlSessionFactory.class, SqlSessionFactoryBean.class这两个类时才解析MybatisAutoConfiguration配置类,否则不解析这一个配置类，make sence，我们需要mybatis为我们返回会话对象，就必须有会话工厂相关类</p><p>@CondtionalOnBean(DataSource.class):只有处理已经被声明为bean的dataSource</p><p>@ConditionalOnMissingBean(MapperFactoryBean.class)这个注解的意思是如果容器中不存在name指定的bean则创建bean注入，否则不执行（该类源码较长，篇幅限制不全粘贴）</p><p>以上配置可以保证sqlSessionFactory、sqlSessionTemplate、dataSource等mybatis所需的组件均可被自动配置，@Configuration注解已经提供了Spring的上下文环境，所以以上组件的配置方式与Spring启动时通过mybatis.xml文件进行配置起到一个效果。通过分析我们可以发现，只要一个基于SpringBoot项目的类路径下存在SqlSessionFactory.class, SqlSessionFactoryBean.class，并且容器中已经注册了dataSourceBean，就可以触发自动化配置，意思说我们只要在maven的项目中加入了mybatis所需要的若干依赖，就可以触发自动配置，但引入mybatis原生依赖的话，每集成一个功能都要去修改其自动化配置类，那就得不到开箱即用的效果了。所以Spring-boot为我们提供了统一的starter可以直接配置好相关的类，触发自动配置所需的依赖(mybatis)如下：</p><img src="/posts/2547f24d/20190903091234532.png" class alt="在这里插入图片描述"><p>这里是截取的mybatis-spring-boot-starter的源码中pom.xml文件中所有依赖:</p><img src="/posts/2547f24d/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hmbWJvb2s=,size_16,color_FFFFFF,t_70-1681571923035117.png" class alt="在这里插入图片描述">]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;目录&quot;&gt;&lt;a href=&quot;#目录&quot; class=&quot;headerlink&quot; title=&quot;目录&quot;&gt;&lt;/a&gt;目录&lt;/h1&gt;&lt;h2 id=&quot;springboot-启动过程&quot;&gt;&lt;a href=&quot;#springboot-启动过程&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="Java" scheme="https://blog.yahyav2rayssr.top/categories/Java/"/>
    
    <category term="Spring" scheme="https://blog.yahyav2rayssr.top/categories/Java/Spring/"/>
    
    
    <category term="spring" scheme="https://blog.yahyav2rayssr.top/tags/spring/"/>
    
    <category term="springboot" scheme="https://blog.yahyav2rayssr.top/tags/springboot/"/>
    
  </entry>
  
</feed>
