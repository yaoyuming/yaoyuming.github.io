<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yahya"><meta name="keywords" content=""><meta name="description" content="RabbitMQ详解RabbitMQ的优点：  开源, 性能有效, 稳定性好 提供可靠性消息投递模式(confirm), 返回模式(return)等 与Spring完美整合, API丰富 集群模式丰富, 支持表达式配置, 高可用HA模式, 镜像队列模型 可以保证数据不丢失的前提下做到高可靠性, 可用性  RabbitMQ高性能原因：  由Erlang语言开发，继承其天生的并发性，稳定性和安全性有保"><meta property="og:type" content="article"><meta property="og:title" content="RabbitMQ 详解"><meta property="og:url" content="https://blog.yahyav2rayssr.top/posts/8e078847/index.html"><meta property="og:site_name" content="yahya的博客"><meta property="og:description" content="RabbitMQ详解RabbitMQ的优点：  开源, 性能有效, 稳定性好 提供可靠性消息投递模式(confirm), 返回模式(return)等 与Spring完美整合, API丰富 集群模式丰富, 支持表达式配置, 高可用HA模式, 镜像队列模型 可以保证数据不丢失的前提下做到高可靠性, 可用性  RabbitMQ高性能原因：  由Erlang语言开发，继承其天生的并发性，稳定性和安全性有保"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/85.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/86.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/87.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/88.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/89.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/90.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/91.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/92.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/93.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/94.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/95.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/96.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/97.jpg"><meta property="article:published_time" content="2023-04-18T15:31:24.497Z"><meta property="article:modified_time" content="2023-04-18T15:31:24.498Z"><meta property="article:author" content="Yahya"><meta property="article:tag" content="rabbitmq"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog.yahyav2rayssr.top/posts/8e078847/85.jpg"><title>RabbitMQ 详解 - yahya的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"blog.yahyav2rayssr.top",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!1,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!1,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:6},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="yahya的博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yahya的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">RabbitMQ 详解</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-18 23:31" pubdate>2023年4月18日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8.7k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 73 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="中间件" id="heading-3cbfec336978067fe5295fb69a0ca202" role="tab" data-toggle="collapse" href="#collapse-3cbfec336978067fe5295fb69a0ca202" aria-expanded="true">中间件 <span class="list-group-count">(11)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-3cbfec336978067fe5295fb69a0ca202" role="tabpanel" aria-labelledby="heading-3cbfec336978067fe5295fb69a0ca202"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="MySQL" id="heading-62a004b95946bb97541afa471dcca73a" role="tab" data-toggle="collapse" href="#collapse-62a004b95946bb97541afa471dcca73a" aria-expanded="false">MySQL <span class="list-group-count">(7)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-62a004b95946bb97541afa471dcca73a" role="tabpanel" aria-labelledby="heading-62a004b95946bb97541afa471dcca73a"><div class="category-post-list"><a href="/posts/47eac6e4/" title="MySQL 基础" class="list-group-item list-group-item-action"><span class="category-post">MySQL 基础</span> </a><a href="/posts/b2e36861/" title="MySQL 常用 SQL" class="list-group-item list-group-item-action"><span class="category-post">MySQL 常用 SQL</span> </a><a href="/posts/31eec5f6/" title="MySQL 常用命令" class="list-group-item list-group-item-action"><span class="category-post">MySQL 常用命令</span> </a><a href="/posts/3aad583d/" title="MySQL 时区问题" class="list-group-item list-group-item-action"><span class="category-post">MySQL 时区问题</span> </a><a href="/posts/8c2abb3e/" title="MySQL 时间基本概念" class="list-group-item list-group-item-action"><span class="category-post">MySQL 时间基本概念</span> </a><a href="/posts/18ea587c/" title="MySQL 时间数据类型对照表" class="list-group-item list-group-item-action"><span class="category-post">MySQL 时间数据类型对照表</span> </a><a href="/posts/c24675b4/" title="MySQL 索引" class="list-group-item list-group-item-action"><span class="category-post">MySQL 索引</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Redis" id="heading-e111446745a1825b862f8727ae63bce4" role="tab" data-toggle="collapse" href="#collapse-e111446745a1825b862f8727ae63bce4" aria-expanded="false">Redis <span class="list-group-count">(2)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-e111446745a1825b862f8727ae63bce4" role="tabpanel" aria-labelledby="heading-e111446745a1825b862f8727ae63bce4"><div class="category-post-list"><a href="/posts/17835f44/" title="Redis 三种集群架构" class="list-group-item list-group-item-action"><span class="category-post">Redis 三种集群架构</span> </a><a href="/posts/99f6ec28/" title="Redis 常用命令" class="list-group-item list-group-item-action"><span class="category-post">Redis 常用命令</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="容器" id="heading-22c799040acdb2601b437ed5449de076" role="tab" data-toggle="collapse" href="#collapse-22c799040acdb2601b437ed5449de076" aria-expanded="false">容器 <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-22c799040acdb2601b437ed5449de076" role="tabpanel" aria-labelledby="heading-22c799040acdb2601b437ed5449de076"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Jetty" id="heading-95dd2e7e150f2e8a04c35a78cb15b3e5" role="tab" data-toggle="collapse" href="#collapse-95dd2e7e150f2e8a04c35a78cb15b3e5" aria-expanded="false">Jetty <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-95dd2e7e150f2e8a04c35a78cb15b3e5" role="tabpanel" aria-labelledby="heading-95dd2e7e150f2e8a04c35a78cb15b3e5"><div class="category-post-list"><a href="/posts/849606ff/" title="Jetty 基础概念" class="list-group-item list-group-item-action"><span class="category-post">Jetty 基础概念</span></a></div></div></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="消息队列" id="heading-8bedb7aae7ae74964d0363a1556c7a59" role="tab" data-toggle="collapse" href="#collapse-8bedb7aae7ae74964d0363a1556c7a59" aria-expanded="true">消息队列 <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-8bedb7aae7ae74964d0363a1556c7a59" role="tabpanel" aria-labelledby="heading-8bedb7aae7ae74964d0363a1556c7a59"><div class="category-post-list"></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="RabbitMQ" id="heading-7eaa993723e57b3bfc99923c196e2e17" role="tab" data-toggle="collapse" href="#collapse-7eaa993723e57b3bfc99923c196e2e17" aria-expanded="true">RabbitMQ <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-7eaa993723e57b3bfc99923c196e2e17" role="tabpanel" aria-labelledby="heading-7eaa993723e57b3bfc99923c196e2e17"><div class="category-post-list"><a href="/posts/8e078847/" title="RabbitMQ 详解" class="list-group-item list-group-item-action active"><span class="category-post">RabbitMQ 详解</span></a></div></div></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">RabbitMQ 详解</h1><p class="note note-info">本文最后更新于：2023年4月18日 晚上</p><div class="markdown-body"><h1 id="RabbitMQ详解"><a href="#RabbitMQ详解" class="headerlink" title="RabbitMQ详解"></a>RabbitMQ详解</h1><p><strong>RabbitMQ的优点：</strong></p><ul><li>开源, 性能有效, 稳定性好</li><li>提供可靠性消息投递模式(confirm), 返回模式(return)等</li><li>与Spring完美整合, API丰富</li><li>集群模式丰富, 支持表达式配置, 高可用HA模式, 镜像队列模型</li><li>可以保证数据不丢失的前提下做到高可靠性, 可用性</li></ul><p><strong>RabbitMQ高性能原因：</strong></p><ul><li>由Erlang语言开发，继承其天生的并发性，稳定性和安全性有保障</li></ul><p><strong>RabbitMQ的协议：</strong></p><p>AMQP（Advanced Message Queuing Protocol）高级消息队列协议，是一个异步消息传递所使用应用层协议规范，为面向消息中间件设计，基于此协议的客户端与消息中间件可以无视消息来源传递消息，不受客户端、消息中间件、不同的开发语言环境等条件的限制。</p><img src="/posts/8e078847/85.jpg" srcset="/img/loading.gif" lazyload><p>设计概念解释：</p><ul><li>Server : 又称Broker, 接受客户端连接, 实现AMQP实体服务</li><li>Connection : 连接, 应用程序与Broker的网络连接</li><li>Channel : 网络信道, 几乎所有的操作都在Channel中进行, Channel是进行消息读写的通道。客户端可以建立多个Channel, 每个Channel代表一个会话任务。</li><li>Message : 消息, 服务器和应用程序之间传送的数据, 有Properties和Body组成。Properties可以对消息进行修饰, 比如消息的优先级, 延迟等高级特性; Body就是消息体内容。</li><li>Virtual Host : 虚拟地址, 用于进行逻辑隔离, 最上层的消息路由。一个Virtual Host里面可以有若干个Exchange和Queue, 同一个Virtual Host里面不能有相同名称的Exchange或Queue</li><li>Exchange : 交换机, 用于接收消息, 根据路由键转发消息到绑定的队列</li><li>Binding : Exchange和Queue之间的虚拟连接, binding中可以包含routing key</li><li>Routing Key : 一个路由规则, 虚拟机可用它来确定如何路由一个特定消息</li><li>Queue : 也成Message Queue, 消息队列, 用于保存消息并将它们转发给消费者</li></ul><p><strong>RabbitMQ整体架构</strong></p><img src="/posts/8e078847/86.jpg" srcset="/img/loading.gif" lazyload><h1 id="RabbitMQ成员简介"><a href="#RabbitMQ成员简介" class="headerlink" title="RabbitMQ成员简介"></a>RabbitMQ成员简介</h1><h2 id="Binding-绑定"><a href="#Binding-绑定" class="headerlink" title="Binding-绑定"></a>Binding-绑定</h2><ul><li>Exchange和Exchange, Queue之间的连接关系</li><li>绑定中可以包含RoutingKey或者参数</li></ul><h2 id="Queue-消息队列"><a href="#Queue-消息队列" class="headerlink" title="Queue-消息队列"></a>Queue-消息队列</h2><ul><li>消息队列, 实际存储消息数据</li><li>Durability : 是否持久化</li><li>Auto delete : 如选yes,代表当最后一个监听被移除之后, 该Queue会自动被删除</li></ul><h2 id="Message-消息"><a href="#Message-消息" class="headerlink" title="Message-消息"></a>Message-消息</h2><ul><li>服务和应用程序之间传送的数据</li><li>本质上就是一段数据, 由Properties和Payload(Body)组成</li><li>常用属性 : delivery mode, headers(自定义属性)</li><li>其他属性<ul><li>content_type, content_encoding, priority</li><li>correlation_id : 可以认为是消息的唯一id</li><li>replay_to : 重回队列设定</li><li>expiration : 消息过期时间</li><li>message_id : 消息id</li><li>timestamp, type, user_id, app_id, cluster_id</li></ul></li></ul><h2 id="Virtual-Host-虚拟主机"><a href="#Virtual-Host-虚拟主机" class="headerlink" title="Virtual Host-虚拟主机"></a>Virtual Host-虚拟主机</h2><ul><li>虚拟地址, 用于进行逻辑隔离, 最上层的消息路由</li><li>一个Virtual Host里面可以有若干个Exchange和Queue</li><li>同一个Virtual Host里面不能有相同名称的Exchange或Queue</li></ul><h2 id="Exchange-交换机"><a href="#Exchange-交换机" class="headerlink" title="Exchange-交换机"></a>Exchange-交换机</h2><p>接收消息，并根据路由键转发消息到所绑定的队列</p><p>注：交换机不会存储消息，如果消息发送到没有绑定消费队列的交换机，消息则丢失。</p><img src="/posts/8e078847/87.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><p><strong>交换机的属性</strong></p><ul><li>Name : 交换机名称</li><li>Type : 交换机类型, direct, topic, fanout, headers</li><li>Durability : 是否需要持久化, true为持久化</li><li>Auto Delete : 当最后一个绑定到Exchange上的队列删除后, 自动删除该Exchange</li><li>Internal : 当前Exchange是否用于RabbitMQ内部使用, 默认为False, 这个属性很少会用到</li><li>Arguments : 扩展参数, 用于扩展AMQP协议制定化使用</li></ul><p><strong>交换机的四种类型</strong></p><ul><li>Direct exchange（直连交换机）是根据消息携带的路由键（routing key）将消息投递给对应队列的<ul><li>注意 : Direct模式可以使用RabbitMQ自带的Exchange(default Exchange), 所以不需要将Exchange进行任何绑定(binding)操作, 消息传递时, RoutingKey必须完全匹配才会被队列接收, 否则该消息会被抛弃</li></ul></li></ul><img src="/posts/8e078847/88.jpg" srcset="/img/loading.gif" lazyload><ul><li>Fanout exchange（扇型交换机）将消息路由给绑定到它身上的所有队列<ul><li>不处理路由键, 只需要简单的将队列绑定到交换机上</li><li>发送到交换机的消息都会被转发到与该交换机绑定的所有队列上</li><li>Fanout交换机转发消息是最快的</li></ul></li></ul><img src="/posts/8e078847/89.jpg" srcset="/img/loading.gif" lazyload style="zoom:67%"><ul><li>Topic exchange（主题交换机）队列通过路由键绑定到交换机上，然后，交换机根据消息里的路由值，将消息路由给一个或多个绑定队列（模糊匹配）<ul><li>“#” : 匹配一个或多个词</li><li>“*” : 匹配一个词</li></ul></li></ul><img src="/posts/8e078847/90.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><ul><li>Headers exchange（头交换机）类似主题交换机，但是头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。</li></ul><h1 id="RabbitMQ常用的5种工作模式"><a href="#RabbitMQ常用的5种工作模式" class="headerlink" title="RabbitMQ常用的5种工作模式"></a>RabbitMQ常用的5种工作模式</h1><h2 id="1、点对点-简单-的队列"><a href="#1、点对点-简单-的队列" class="headerlink" title="1、点对点(简单)的队列"></a>1、点对点(简单)的队列</h2><img src="/posts/8e078847/91.jpg" srcset="/img/loading.gif" lazyload alt="img"><ul><li>不需要交换机</li><li>一个生产者，一个消费者</li></ul><h2 id="2、工作队列（公平性）"><a href="#2、工作队列（公平性）" class="headerlink" title="2、工作队列（公平性）"></a>2、工作队列（公平性）</h2><img src="/posts/8e078847/92.jpg" srcset="/img/loading.gif" lazyload alt="img"><ul><li>不需要交换机</li><li>一个生产者，多个消费者，但是一个消息只会发送给一个队列（竞争的消费者模式）</li><li>默认是轮询，即会将消息轮流发给多个消费者，但这样对消费得比较慢的消费者不公平</li><li>可采用公平分配，即能者多劳<ul><li>channel.basicQos(1); &#x2F;&#x2F; 限定：发送一条信息给消费者A，消费者A未反馈处理结果之前，不会再次发送信息给消费者A</li><li>boolean autoAck &#x3D; false; &#x2F;&#x2F; 取消自动反馈 channel.basicConsume(QUEUE_NAME, autoAck, consumer); &#x2F;&#x2F; 接收信息</li><li>channel.basicAck(envelope.getDeliveryTag(), false); &#x2F;&#x2F; 反馈消息处理完毕</li></ul></li></ul><h2 id="3、发布-x2F-订阅"><a href="#3、发布-x2F-订阅" class="headerlink" title="3、发布&#x2F;订阅"></a>3、发布&#x2F;订阅</h2><img src="/posts/8e078847/93.jpg" srcset="/img/loading.gif" lazyload alt="img"><ul><li>一个生产者，多个消费者</li><li>每一个消费者都有自己的一个队列</li><li>生产者没有直接发消息到队列中，而是发送到交换机</li><li>每个消费者的队列都绑定到交换机上</li><li>消息通过交换机到达每个消费者的队列</li></ul><p>该模式就是Fanout Exchange（扇型交换机）将消息路由给绑定到它身上的所有队列</p><h2 id="4、路由"><a href="#4、路由" class="headerlink" title="4、路由"></a>4、路由</h2><img src="/posts/8e078847/94.jpg" srcset="/img/loading.gif" lazyload alt="img"><p>生产者发送消息到交换机并指定一个路由key，消费者队列绑定到交换机时要制定路由key（key匹配就能接受消息，key不匹配就不能接受消息）</p><p>该模式采用Direct exchange（直连交换机）</p><h2 id="5、主题（通配符）"><a href="#5、主题（通配符）" class="headerlink" title="5、主题（通配符）"></a>5、主题（通配符）</h2><img src="/posts/8e078847/95.jpg" srcset="/img/loading.gif" lazyload alt="img"><p>此模式实在路由key模式的基础上，使用了通配符来管理消费者接收消息。生产者P发送消息到交换机X，交换机根据绑定队列的routing key的值进行通配符匹配</p><p>符号#：匹配一个或者多个词lazy.# 可以匹配lazy.irs或者lazy.irs.cor</p><p>符号<em>：只能匹配一个词 lazy.</em> 可以匹配 lazy.irs 或者 lazy.cor</p><p>该模式采用Topic exchange（主题交换机）</p><h1 id="消息可靠性传递或回退（生产者端）"><a href="#消息可靠性传递或回退（生产者端）" class="headerlink" title="消息可靠性传递或回退（生产者端）"></a>消息可靠性传递或回退（生产者端）</h1><p>生产者发送消息出去之后，不知道到底有没有发送到RabbitMQ服务器， 默认是不知道的。而且有的时候我们在发送消息之后，后面的逻辑出问题了，我们不想要发送之前的消息了，需要撤回该怎么做。</p><p><strong>AMQP 事务机制</strong></p><ul><li>txSelect 将当前channel设置为transaction模式</li><li>txCommit 提交当前事务</li><li>txRollback 事务回滚</li></ul><p><strong>Confirm 模式</strong></p><p>消息的确认, 是指生产者投递消息后, 如果Broker收到消息, 则会给我们产生一个应答</p><p>生产者进行接收应答, 用来确定这条消息是否正常发送到Broker, 这种方式也是消息的可靠性投递的核心保障</p><ul><li>在channel上开启确认模式 : channel.confirmSelect()</li><li>在channel上添加监听 : addConfirmListener, 监听成功和失败的返回结果, 根据具体的结果对消息进行重新发送, 或记录日志等后续处理</li></ul><p><strong>Return消息机制</strong></p><p>Return Listener用于处理一些不可路由的消息</p><p>正常情况下消息生产者通过指定一个Exchange和RoutingKey, 把消息送到某一个队列中去, 然后消费者监听队列, 进行消费，但在某些情况下, 如果在发送消息的时候, 当前的exchange不存在或者指定的路由key路由不到,这个时候如果我们需要监听这种不可达的消息, 就要使用Return Listener。</p><p>在基础API中有一个关键的配置项Mandatory : 如果为true, 则监听器会接收到路由不可达的消息, 然后进行后续处理（补偿或人工处理）, 如果为false, 那么broker端自动删除该消息。</p><p><strong>如何保障消息可靠传递</strong></p><ul><li>保障消息的成功发出</li><li>保障MQ节点的成功接收</li><li>发送端收到MQ节点(Broker)的确认应答</li><li>完善的消息补偿机制</li></ul><p>方案：</p><p>1、消息落库, 对消息状态进行标记</p><img src="/posts/8e078847/96.jpg" srcset="/img/loading.gif" lazyload alt="img"><ul><li>step1:消息入库</li><li>step2:消息发送</li><li>step3:消费端消息确认</li><li>step4:更新库中消息状态为已确认</li><li>step5:定时任务读取数据库中未确认的消息</li><li>step6:未收到确认结果的消息重新发送</li><li>step7:如果重试几次之后仍然失败, 则将消息状态更改为投递失败的终态, 后面需要人工介入</li></ul><p>2、消息的延迟投递, 做二次确认, 回调检查</p><img src="/posts/8e078847/97.jpg" srcset="/img/loading.gif" lazyload alt="img"><ul><li>step1 : 第一次消息发送, 必须业务数据落库之后才能进行消息发送</li><li>step2 : 第二次消息延迟发送, 设定延迟一段时间发送第二次check消息</li><li>step3 : 消费端监听Broker, 进行消息消费</li><li>step4 : 消费成功之后, 发送确认消息到确认消息队列</li><li>step5 : Callback Service监听step4中的确认消息队列, 维护消息状态, 是否消费成功等状态</li><li>step6 : Callback Service监听step2发送的Delay Check的消息队列, 检测内部的消息状态, 如果消息是发送成功状态, 则流程结束, 如果消息是失败状态, 或者查不到当前消息状态时, 会通知生产者, 进行消息重发, 重新上述步骤</li></ul><h1 id="重试机制和幂等性保障（消费者端）"><a href="#重试机制和幂等性保障（消费者端）" class="headerlink" title="重试机制和幂等性保障（消费者端）"></a>重试机制和幂等性保障（消费者端）</h1><p><strong>重试机制</strong></p><p>消费者在消费消息的时候，如果消费者业务逻辑出现程序异常，会使用消息重试机制。</p><ul><li>情况1: 消费者获取到消息后，调用第三方接口，但接口暂时无法访问，是否需要重试? （需要重试机制）</li><li>情况2: 消费者获取到消息后，抛出数据转换异常，是否需要重试?（不需要重试机制）需要发布进行解决。</li></ul><p>对于情况2，如果消费者代码抛出异常是需要发布新版本才能解决的问题，那么不需要重试，重试也无济于事。应该采用日志记录+定时任务job健康检查+人工进行补偿</p><p><strong>重试机制的实现</strong></p><p>在SpringBoot中，@RabbitListener(queue&#x3D;””)用于消费者监听队列。底层使用Aop进行拦截，如果程序没有抛出异常，则自动提交事务。如果抛出异常，该消息会缓存到RabbitMQ服务器，自动实施重试机制，一直到成功为止。可以配置重试间隔时间和重试的次数。</p><p><strong>幂等性保障</strong></p><p>幂等性：多次执行, 结果保持一致</p><p>网络延迟传输中，消费出现异常或者是消费延迟消费，会造成MQ进行重试补偿，在重试过程中，可能会造成重复消费。</p><p>解决方案：</p><ul><li>唯一ID+指纹码机制<ul><li>唯一ID + 指纹码机制，利用数据库主键去重</li><li>SELECT COUNT(1) FROM T_ORDER WHERE ID &#x3D; 唯一ID +指纹码</li><li>好处：实现简单</li><li>坏处：高并发下有数据库写入的性能瓶颈</li><li>解决方案：跟进ID进行分库分表进行算法路由</li></ul></li><li>利用Redis的原子性去实现<ul><li>在接收到消息后将消息ID作为key执行 setnx 命令，如果执行成功就表示没有处理过这条消息，可以进行消费了，执行失败表示消息已经被消费了。</li></ul></li></ul><h1 id="自动签收与手动签收（消费端）"><a href="#自动签收与手动签收（消费端）" class="headerlink" title="自动签收与手动签收（消费端）"></a>自动签收与手动签收（消费端）</h1><p>默认是自动签收</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicConsume(QUEUE_NAME, <span class="hljs-literal">false</span>, defaultConsumer); <span class="hljs-comment">//关闭自动签收，变为手动签收</span><br>channel.basicAck(envelope.getDeliveryTag(), <span class="hljs-literal">false</span>); <span class="hljs-comment">// 手工签收, 第二个参数表示是否批量签收</span><br></code></pre></td></tr></table></figure><h1 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h1><p>消息队列中囤积了大量的消息, 或者某些时刻生产的消息远远大于消费者处理能力的时候, 这个时候如果消费者一次取出大量的消息, 但是客户端又无法处理, 就会出现问题, 甚至可能导致服务崩溃, 所以需要对消费端进行限流</p><p>RabbitMQ提供了一种qos(服务质量保证)功能, 即在非自动确认消息的前提下, 如果一定数目的消息(通过consumer或者channel设置qos的值)未被确认前, 不进行消费新的消息</p><ul><li>自动签收要设置成false, 建议实际工作中也设置成false</li><li><code>void basicQos(int prefetchSize, int prefetchCount, boolean global) throws IOException;</code><ul><li><code>prefetchSize</code> : 消息大小限制, 一般设置为0, 消费端不做限制</li><li><code>prefetchCount</code> : 会告诉RabbitMQ不要同时给一个消费者推送多于N个消息, 即一旦有N个消息还没有ack, 则该consumer将block(阻塞), 直到有消息ack</li><li><code>global</code> : true&#x2F;false 是否将上面设置应用于channel, 简单来说就是上面的限制是channel级别的还是consumer级别 注意 :</li></ul></li></ul><p>prefetchSize和global这两项，RabbitMQ没有实现，暂且不关注，prefetchCount在autoAck设置false的情况下生效,即在自动确认的情况下这个值是不生效的</p><p>限流可实现公平队列。</p><h1 id="消费端ACK和重回队列"><a href="#消费端ACK和重回队列" class="headerlink" title="消费端ACK和重回队列"></a>消费端ACK和重回队列</h1><p><strong>消费端ACK</strong></p><ul><li>消费端的手工ACK和NACK, ACK是确认成功消费, NACK表示消息处理失败, 会重发消息</li><li>消费端进行消费的时候, 如果由于业务异常我们可以进行日志的记录, 然后进行补偿</li><li>如果由于服务器宕机等严重问题, 就需要手工进行ACK保障消费端消费成功</li></ul><p><strong>重回队列</strong></p><ul><li>消费端重回队列是为了对没有处理成功的消息, 把消息重新回递给Broker</li><li>一般在实际应用中, 都会关闭重回队列, 也就是设置为False</li></ul><h1 id="TTL队列-x2F-消息"><a href="#TTL队列-x2F-消息" class="headerlink" title="TTL队列&#x2F;消息"></a>TTL队列&#x2F;消息</h1><ul><li>TTL是Time To Live的缩写, 也就是生存时间</li><li>RabbitMQ支持消息的过期时间, 在消息发送时可以进行指定</li><li>RabbitMQ支持队列的过期时间, 从消息入队列开始计算, 只要超过了队列的超时时间配置, 那么消息会自动清除</li></ul><h1 id="死信队列（DLX）"><a href="#死信队列（DLX）" class="headerlink" title="死信队列（DLX）"></a>死信队列（DLX）</h1><ul><li>Dead-Letter-Exchange</li><li>利用DLX, 当消息在一个队列中变成死信(dead message)之后, 它能被重新publish到另一个Exchange, 这个Exchange就是DLX</li><li>DLX也是一个正常的Exchange, 和一般的Exchange没有区别, 它能在任何队列上被指定, 实际上就是设置某个队列的属性为死信队列</li><li>当这个队列中有死信时, RabbitMQ就会自动将这个消息重新发布到设置的Exchange上去, 进而被路由到另一个队列</li><li>可以监听这个队列中消息做相应的处理, 这个特性可以弥补RabbitMQ3.0以前支持的immediate参数的功能</li></ul><p><strong>消息变成死信有以下几种情况 :</strong></p><ul><li>消息被拒绝(basic.reject&#x2F;basic.nack) 并且requeue重回队列设置成false<ul><li>channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); &#x2F;&#x2F;丢弃消息</li></ul></li><li>消息TTL过期</li><li>队列达到最大长度</li></ul><p><strong>死信队列的设置 :</strong></p><ol><li>设置死信队列属性实现</li></ol><ul><li>首先要设置死信队列的exchange和queue, 然后进行绑定<ul><li>Exchange : dlx.exchange</li><li>Queue : dlx.queue</li><li>RoutingKey : #</li></ul></li><li>然后正常声明交换机, 队列, 绑定, 只不过需要在队列加上一个扩展参数即可 : arguments.put(“x-dead-letter-exchange”, “dlx.exchange”);</li><li>这样消息在过期, reject或nack(requeue要设置成false), 队列在达到最大长度时, 消息就可以直接路由到死信队列。</li></ul><ol start="2"><li>用rabbitmq-delayed-message-exchange插件实现延迟队列</li></ol><h1 id="RabbitMQ负载均衡"><a href="#RabbitMQ负载均衡" class="headerlink" title="RabbitMQ负载均衡"></a>RabbitMQ负载均衡</h1><ol><li><p><strong>轮询法</strong></p></li><li><p><strong>随机法</strong></p></li><li><p><strong>源地址哈希法</strong></p></li><li><p><strong>加权轮询法</strong></p></li><li><p><strong>加权随机法</strong></p></li><li><p><strong>最小连接数法</strong></p></li></ol><h1 id="RabbitMQ之如何保障数据不丢失"><a href="#RabbitMQ之如何保障数据不丢失" class="headerlink" title="RabbitMQ之如何保障数据不丢失"></a>RabbitMQ之如何保障数据不丢失</h1><h2 id="1、费者实例宕机的时候，如何保障数据是不会丢失？"><a href="#1、费者实例宕机的时候，如何保障数据是不会丢失？" class="headerlink" title="1、费者实例宕机的时候，如何保障数据是不会丢失？"></a>1、费者实例宕机的时候，如何保障数据是不会丢失？</h2><p>手动ack机制非常的简单，必须要消费者确保自己处理完毕了一个消息，才能手动发送ack给MQ，MQ收到ack之后才会删除这个消息，如果消费者还没发送ack，消费者自己就宕机了，此时MQ感知到它的宕机，就会重新投递这条消息给其他的消费者实例。通过这种机制保证消费者实例宕机的时候，数据是不会丢失的。</p><p>如果采用手动ack机制，实际上消费者服务每次消费了一条消息，处理完毕完成消费之后，就会发送一个ack消息给RabbitMQ服务器，这个ack消息是会带上自己本次消息的delivery tag的。</p><p>这里大家必须注意的一点，就是delivery tag仅仅在一个channel内部是唯一标识消息投递的。所以说，你ack一条消息的时候，必须是通过接受这条消息的同一个channel来进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">channel.basicAck(delivery.getEnvelope().getDeliveryTag(), <span class="hljs-literal">false</span>);<span class="hljs-comment">//表给示消费者成功消费，返回给MQ</span><br></code></pre></td></tr></table></figure><h2 id="2、分析手动ack和默认自动ack区别？"><a href="#2、分析手动ack和默认自动ack区别？" class="headerlink" title="2、分析手动ack和默认自动ack区别？"></a>2、分析手动ack和默认自动ack区别？</h2><p>①实际上默认用自动ack，是非常简单的。RabbitMQ只要投递一个消息出去给仓储服务，那么他立马就把这个消息给标记为删除，因为他是不管消费者服务到底接收到没有，或者处理完没有。所以这种情况下，<strong>性能很好，但是数据容易丢失</strong>。</p><p>②如果手动ack，那么就是必须等消费者服务完成消费以后，才会手动发送ack给RabbitMQ，此时RabbitMQ才会认为消息处理完毕，然后才会标记消息为删除。这样在发送ack之前，消费者服务宕机，<strong>RabbitMQ会重发消息给另外一个消费者服务实例，保证数据不丢失</strong>。</p><h2 id="3、如何保证生产者投递到消息中间件-MQ-的消息不丢失？"><a href="#3、如何保证生产者投递到消息中间件-MQ-的消息不丢失？" class="headerlink" title="3、如何保证生产者投递到消息中间件(MQ)的消息不丢失？"></a>3、如何保证生产者投递到消息中间件(MQ)的消息不丢失？</h2><p><strong>问题：</strong>如果投递出去的消息在网络传输过程中丢失，或者在RabbitMQ的内存中还没写入磁盘的时候宕机，都会导致生产端投递到MQ的数据丢失。而且丢失之后，生产者自己还感知不到，同时还没办法来补救。</p><p>生产者需要开启confirm模式，投递消息到MQ，如果MQ一旦将消息持久化到磁盘之后，必须也要回传一个confirm消息给生产端。这样的话，如果生产端的服务接收到了这个confirm消息，就知道是已经持久化到磁盘了。如果没有接收到confirm消息，那么就说明这条消息半路可能丢失了，此时你就可以重新投递消息到MQ去，确保消息不要丢失。</p><p>而且一旦你开启了confirm模式之后，每次消息投递也同样是有一个delivery tag的，也是起到唯一标识一次消息投递的作用。这样，MQ回传ack给生产端的时候，会带上这个delivery tag。你就知道具体对应着哪一次消息投递了，可以删除这条消息。</p><p>此外，如果RabbitMQ接收到一条消息之后，结果内部出错发现无法处理这条消息，那么MQ会回传一个nack消息给生产者。此时生产者就会感知到这条消息可能处理有问题，你可以选择重新再次投递这条消息到MQ去。</p><p>或者另一种情况，如果某条消息很长时间都没给你回传ack&#x2F;nack，那可能是极端意外情况发生了，数据也丢了，你也可以自己重新投递消息到MQ去。</p><h2 id="4、confirm机制投递消息的高延迟性"><a href="#4、confirm机制投递消息的高延迟性" class="headerlink" title="4、confirm机制投递消息的高延迟性"></a>4、<strong>confirm机制投递消息的高延迟性</strong></h2><p>一旦启用了confirm机制投递消息到MQ之后，MQ是不保证什么时候会给你一个ack或者nack的。</p><p>因为RabbitMQ自己内部将消息持久化到磁盘，本身就是通过异步批量的方式来进行的。正常情况下，你投递到RabbitMQ的消息都会先驻留在内存里，然后过了几百毫秒的延迟时间之后，再一次性批量把多条消息持久化到磁盘里去。这样做，是为了兼顾高并发写入的吞吐量和性能的，因为要是你来一条消息就写一次磁盘，那么性能会很差，每次写磁盘都是一次fsync强制刷入磁盘的操作，是很耗时的。</p><p><strong>那如何解决呢？</strong></p><p>绝对不能以****同步*<em><strong>写消息 + 等待ack的方式来投递消息，用来临时存放未ack消息的存储需要承载高并发写入，而且我们不需要什么复杂的运算操作，这种存储首选绝对不是MySQL之类的关系数据库，而</strong>建议采用kv存储</em>*。kv存储承载高并发能力极强，而且kv操作性能很高。</p><p>生产者消息投递出去之后并且在kv存储器存储，这个投递的线程其实就可以返回了，至于每个消息的异步回调，是通过在channel注册一个confirm监听器实现的。生产者收到一个消息ack之后，就从kv存储中删除这条临时消息；收到一个消息nack之后，就从kv存储提取这条消息然后重新投递一次即可；也可以自己对kv存储里的消息做监控，如果超过一定时长没收到ack，就主动重发消息。                      </p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="category-chain-item">中间件</a> <span>></span> <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" class="category-chain-item">消息队列</a> <span>></span> <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/" class="category-chain-item">RabbitMQ</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/rabbitmq/">#rabbitmq</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/c9844e82/" title="Java 数据结构基础"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Java 数据结构基础</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/d2341114/" title="大数据常见错误：重新format namenode后，datanode无法正常启动"><span class="hidden-mobile">大数据常见错误：重新format namenode后，datanode无法正常启动</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>