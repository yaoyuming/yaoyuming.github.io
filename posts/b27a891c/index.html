<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yahya"><meta name="keywords" content=""><meta name="description" content="概念Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏"><meta property="og:type" content="article"><meta property="og:title" content="SpringCloud 组件概念"><meta property="og:url" content="https://blog.yahyav2rayssr.top/posts/b27a891c/index.html"><meta property="og:site_name" content="yahya的博客"><meta property="og:description" content="概念Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/155.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/156.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/157.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/158.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/159.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/160.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/161.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/162.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/163.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/164.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/165.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/166.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/167.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/168.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/169.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/170.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/171.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/172.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/173.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/174.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/176.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/175.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/177.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/178.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/179.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/180.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/181.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/182.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/183.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/184.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/185.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/186.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/187.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/188.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/189.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/192.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/190.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/191.jpg"><meta property="article:published_time" content="2023-04-16T13:28:04.657Z"><meta property="article:modified_time" content="2023-04-16T13:28:04.657Z"><meta property="article:author" content="Yahya"><meta property="article:tag" content="springcloud"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog.yahyav2rayssr.top/posts/b27a891c/155.jpg"><title>SpringCloud 组件概念 - yahya的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"blog.yahyav2rayssr.top",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!1,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!1,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:6},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="yahya的博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yahya的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="SpringCloud 组件概念"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-16 21:28" pubdate>2023年4月16日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 82 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">SpringCloud 组件概念</h1><div class="markdown-body"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>Spring Cloud是一系列框架的有序集合</strong>。它利用<strong>Spring Boot</strong>的开发便利性巧妙地简化了分布式系统基础设施的开发，如<strong>服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控</strong>等，都可以用Spring Boot的开发风格做到一键启动和部署。Spring并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 <strong>Spring Cloud正是对Netflix的多个开源组件进一步的封装而成</strong>，同时又实现了和云端平台，和Spring Boot开发框架很好的集成。 Spring Cloud是一个相对比较新的微服务框架，<strong>2016年才推出1.0的release版本</strong>. 虽然Spring Cloud时间最短, 但是相比Dubbo等RPC框架, <strong>Spring Cloud提供的全套的分布式系统解决方案</strong>。 Spring Cloud 为开发者提供了在分布式系统（<strong>配置管理，服务发现，熔断，路由，微代理，控制总线，一次性token，全居琐，leader选举，分布式session，集群状态</strong>）中快速构建的工具，使用Spring Cloud的开发者可以快速的启动服务或构建应用、同时能够快速和云平台资源进行对接。</p><img src="/posts/b27a891c/155.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><p>从上图可以看出Spring Cloud各个组件相互配合，合作支持了一套完整的微服务架构。</p><ul><li>其中Eureka负责服务的注册与发现，很好将各服务连接起来</li><li>Hystrix 负责监控服务之间的调用情况，连续多次失败进行熔断保护。</li><li>Hystrix dashboard,Turbine 负责监控 Hystrix的熔断情况，并给予图形化的展示</li><li>Spring Cloud Config 提供了统一的配置中心服务</li><li>当配置文件发生变化的时候，Spring Cloud Bus 负责通知各服务去获取最新的配置信息</li><li>所有对外的请求和服务，我们都通过Zuul来进行转发，起到API网关的作用</li><li>最后我们使用Sleuth+Zipkin将所有的请求数据记录下来，方便我们进行后续分析</li></ul><h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><p>Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架”Spring Boot化”的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如<strong>Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色</strong>。对于我们想快速实践微服务的开发者来说，第一类子项目就已经足够使用，如：<strong>Spring Cloud Netflix</strong>，是对Netflix开发的一套分布式服务框架的封装，包括服务的发现和注册，负载均衡、断路器、REST客户端、请求路由等。该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。 通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。</p><h2 id="Eureka-服务发现"><a href="#Eureka-服务发现" class="headerlink" title="Eureka 服务发现"></a>Eureka 服务发现</h2><p>涉及注解：@EnableEurekaServer、@EnableEurekaClient</p><img src="/posts/b27a891c/156.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"> <img src="/posts/b27a891c/157.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><p>Eureka两个组件组成：<strong>Eureka服务器和Eureka客户端</strong>。Eureka服务器用作服务注册服务器。Eureka客户端是一个java客户端，用来简化与服务器的交互、作为轮询负载均衡器，并提供服务的故障切换支持。</p><h2 id="Ribbon-客户端负载均衡"><a href="#Ribbon-客户端负载均衡" class="headerlink" title="Ribbon 客户端负载均衡"></a>Ribbon 客户端负载均衡</h2><p>涉及注解：@LoadBalanced、@RibbonClient(配置)</p><img src="/posts/b27a891c/158.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><p>Ribbon，主要提供客户侧的软件负载均衡算法。 Ribbon客户端组件提供一系列完善的配置选项，比如连接超时、重试、重试算法等。Ribbon内置可插拔、可定制的负载均衡组件。下面是用到的一些<strong>负载均衡策略</strong>：</p><ul><li><p>轮询策略（RoundRobinRule）</p><p>轮询策略理解起来比较简单，就是拿到所有的server集合，然后根据id进行遍历。这里的id是ip+端口，Server实体类中定义的id属性如下：</p></li><li><p>随机策略（RandomRule）</p><p>随机策略：使用jdk自带的随机数生成工具，生成一个随机数，然后去可用服务列表中拉取服务节点Server。如果当前节点不可用，则进入下一轮随机策略，直到选到可用服务节点为止。</p></li><li><p>可用过滤策略（AvailabilityFilteringRule）</p><p>策略描述：过滤掉连接失败的服务节点，并且过滤掉高并发的服务节点，然后从健康的服务节点中，使用轮询策略选出一个节点返回。</p></li><li><p>响应时间权重策略（WeightedResponseTimeRule）</p><p>策略描述：根据响应时间，分配一个权重weight，响应时间越长，weight越小，被选中的可能性越低。</p></li><li><p>轮询失败重试策略（RetryRule）</p><p>轮询失败重试策略（RetryRule）是这样工作的，首先使用轮询策略进行负载均衡，如果轮询失败，则再使用轮询策略进行一次重试，相当于重试下一个节点，看下一个节点是否可用，如果再失败，则直接返回失败。</p></li><li><p>并发量最小可用策略（BestAvailableRule）</p><p>选择一个并发量最小的server返回。如何判断并发量最小呢？ServerStats有个属性activeRequestCount，这个属性记录的就是server的并发量。轮询所有的server，选择其中activeRequestCount最小的那个server，就是并发量最小的服务节点。</p></li><li><p>ZoneAvoidanceRule</p><p>复合判断server所在区域的性能和server的可用性，来选择server返回。</p></li></ul><p>综述负载均衡策略如下：</p><ol><li>轮询策略</li><li>随机策略</li><li>可用过滤策略</li><li>响应时间权重策略</li><li>轮询失败重试策略</li><li>并发量最小可用策略</li></ol><p>Ribbon中还包括以下功能：</p><ul><li>易于与服务发现组件（比如Netflix的Eureka）集成</li><li>使用Archaius完成运行时配置</li><li>使用JMX暴露运维指标，使用Servo发布</li><li>多种可插拔的序列化选择</li><li>异步和批处理操作（即将推出）</li><li>自动SLA框架（即将推出）</li><li>系统管理&#x2F;指标控制台（即将推出）</li></ul><p><strong>ribbon架构示例</strong></p><img src="/posts/b27a891c/159.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><ul><li>一个服务注册中心，eureka server,端口为8761</li><li>service-hi工程跑了两个实例，端口分别为8762,8763，分别向服务注册中心注册</li><li>sercvice-ribbon端口为8764,向服务注册中心注册</li><li>当sercvice-ribbon通过restTemplate调用service-hi的hi接口时，因为用ribbon进行了负载均衡，会轮流的调用service-hi：8762和8763 两个端口的hi接口；</li></ul><h2 id="Config-Server"><a href="#Config-Server" class="headerlink" title="Config Server"></a>Config Server</h2><p>涉及注解：@EnableConfigServer</p><p>俗称的配置中心，配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，<strong>目前支持本地存储、Git以及Subversion</strong>。</p><img src="/posts/b27a891c/160.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><blockquote><p>将配置信息中央化保存, 配置Spring Cloud Bus可以实现动态修改配置文件。这个还是静态的，得配合Spring Cloud Bus实现动态的配置更新。</p></blockquote><img src="/posts/b27a891c/161.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><p>Spring Cloud Config就是我们通常意义上的配置中心。Spring Cloud Config-把应用原本放在本地文件的配置抽取出来放在<strong>中心服务器</strong>，本质是配置信息从本地迁移到云端。从而能够提供更好的管理、发布能力。 Spring Cloud Config分服务端和客户端，服务端负责将git（svn）中存储的配置文件发布成REST接口，客户端可以从服务端REST接口获取配置。但客户端并不能主动感知到配置的变化，从而主动去获取新的配置，这需要每个客户端通过POST方法触发各自的&#x2F;refresh。</p><h2 id="Hystrix-熔断器"><a href="#Hystrix-熔断器" class="headerlink" title="Hystrix 熔断器"></a>Hystrix 熔断器</h2><p>涉及注解：@HystrixCommad(fallback&#x3D;”方法名”)、结合@FeignClient(fallbackFactory&#x3D;xxx.class)</p><p>熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力。</p><img src="/posts/b27a891c/162.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><p>断路器(Cricuit Breaker)是一种能够在远程服务不可用时自动熔断(打开开关)，并在远程服务恢复时自动恢复(闭合开关)的设施，Spring Cloud通过Netflix的<strong>Hystrix组件</strong>提供断路器、资源隔离与自我修复功能。</p><p>断路器可以防止一个应用程序多次试图执行一个操作，即很可能失败，允许它继续而不等待故障恢复或者浪费 CPU 周期，而它确定该故障是持久的。断路器模式也使应用程序能够检测故障是否已经解决。如果问题似乎已经得到纠正，应用程序可以尝试调用操作。</p><img src="/posts/b27a891c/163.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>断路器增加了稳定性和灵活性，以一个系统，提供稳定性，而系统从故障中恢复，并尽量减少此故障的对性能的影响。它可以帮助快速地拒绝对一个操作，即很可能失败，而不是等待操作超时（或者不返回）的请求，以保持系统的响应时间。如果断路器提高每次改变状态的时间的事件，该信息可以被用来监测由断路器保护系统的部件的健康状况，或以提醒管理员当断路器跳闸，以在打开状态。</p><img src="/posts/b27a891c/164.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"> <img src="/posts/b27a891c/165.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p><img src="/posts/b27a891c/166.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p><img src="/posts/b27a891c/167.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p><strong>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值</strong>。</p><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。服务雪崩效应是一种因“服务提供者”的不可用导致“服务消费者”的不可用,并将不可用逐渐放大的过程。</p><p>如下图所示：A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B的不可用，并将不可用像滚雪球一样放大到C和D时，雪崩效应就形成了。</p><img src="/posts/b27a891c/168.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>在这种情况下就需要整个服务机构具有故障隔离的功能，避免某一个服务挂掉影响全局。<strong>在Spring Cloud 中Hystrix组件就扮演这个角色</strong>。 Hystrix会在某个服务连续调用N次不响应的情况下，立即通知调用端调用失败，避免调用端持续等待而影响了整体服务。Hystrix间隔时间会再次检查此服务，如果服务恢复将继续提供服务。</p><p><strong>Hystrix Dashboard和Turbine</strong> 当熔断发生的时候需要迅速的响应来解决问题，避免故障进一步扩散，那么对熔断的监控就变得非常重要。熔断的监控现在有两款工具：<strong>Hystrix-dashboard</strong>和<strong>Turbine</strong></p><p>Hystrix-dashboard是一款针对Hystrix进行实时监控的工具，通过Hystrix Dashboard我们可以直观地看到各Hystrix Command的请求响应时间, 请求成功率等数据。但是只使用Hystrix Dashboard的话, 你只能看到单个应用内的服务信息, 这明显不够. 我们需要一个工具能让我们汇总系统内多个服务的数据并显示到Hystrix Dashboard上, 这个工具就是<strong>Turbine</strong>. 监控的效果图如下：</p><img src="/posts/b27a891c/169.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><h2 id="Zuul-服务网关，智能路由"><a href="#Zuul-服务网关，智能路由" class="headerlink" title="Zuul 服务网关，智能路由"></a>Zuul 服务网关，智能路由</h2><p>涉及注解：@EnableZuulProxy</p><p>在微服务架构模式下，后端服务的实例数一般是动态的，对于客户端而言很难发现动态改变的服务实例的访问地址信息。因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。</p><img src="/posts/b27a891c/170.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>Spring Cloud体系中支持API Gateway落地的技术就是<strong>Zuul</strong>。Spring Cloud Zuul路由是微服务架构中不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p><p>它的具体作用<strong>就是服务转发，接收并转发所有内外部的客户端调用。使用Zuul可以作为资源的统一访问入口，同时也可以在网关做一些权限校验等类似的功能</strong>。</p><p>Zuul 是在云平台上提供动态路由,监控,弹性,安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门。</p><img src="/posts/b27a891c/171.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"> <img src="/posts/b27a891c/172.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>类似Nginx，反向代理的功能，不过netflix自己增加了一些配合其他组件的特性。</p><h2 id="Netflix-Archaius"><a href="#Netflix-Archaius" class="headerlink" title="Netflix Archaius"></a>Netflix Archaius</h2><img src="/posts/b27a891c/173.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>配置管理API，包含一系列配置管理API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。可以实现动态获取配置，原理是<strong>每隔60s（默认，可配置）从配置源读取一次内容</strong>，这样修改了配置文件后不需要重启服务就可以使修改后的内容生效，前提使用archaius的API来读取。</p><h2 id="Bus"><a href="#Bus" class="headerlink" title="Bus"></a>Bus</h2><img src="/posts/b27a891c/174.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，<strong>可与Spring Cloud Config联合实现热部署</strong>。相当于水浒传中日行八百里的神行太保戴宗，确保各个小弟之间消息保持畅通。</p><p>分布式消息队列，是对Kafka, MQ的封装；事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现<strong>热部署</strong>。 Spring cloud bus通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其他的消息指令。<strong>Spring bus的一个核心思想是通过分布式的启动器对spring boot应用进行扩展，也可以用来建立一个多个应用之间的通信频道。</strong>目前唯一实现的方式是用AMQP消息代理作为通道，同样特性的设置（有些取决于通道的设置）在更多通道的文档中。 Spring cloud bus被国内很多都翻译为消息总线，也挺形象的。大家可以将它理解为管理和传播所有分布式项目中的消息既可，其实本质是利用了MQ的广播机制在分布式的系统中传播消息，目前常用的有Kafka和RabbitMQ。利用bus的机制可以做很多的事情，其中配置中心客户端刷新就是典型的应用场景之一，我们用一张图来描述bus在配置中心使用的机制。</p><img src="/posts/b27a891c/176.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>根据此图我们可以看出利用Spring Cloud Bus做配置更新的步骤:</p><ol><li>提交代码触发post给客户端A发送bus&#x2F;refresh</li><li>客户端A接收到请求从Server端更新配置并且发送给Spring Cloud Bus</li><li>Spring Cloud bus接到消息并通知给其它客户端</li><li>其它客户端接收到通知，请求Server端获取最新配置</li><li>全部客户端均获取到最新的配置</li></ol><h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><img src="/posts/b27a891c/175.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>对Spring Security的封装，并能配合Netflix使用，安全工具包，为你的应用程序添加安全控制，<strong>主要是指OAuth2</strong>。 基于spring security的安全工具包，为你的应用程序添加安全控制</p><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><img src="/posts/b27a891c/177.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>对Zookeeper的封装，使之能配置其它Spring Cloud的子项目使用；操作Zookeeper的工具包，<strong>用于使用zookeeper方式的服务注册和发现</strong>。 ZooKeeper是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。它是一个为分布式应用提供一致性服务的软件，提供的功能包括：配置维护、域名服务、分布式同步、组服务等。ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。 操作Zookeeper的工具包，用于使用zookeeper方式的服务发现和配置管理，抱了Zookeeper的大腿。</p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><img src="/posts/b27a891c/178.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>数据流；数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息。 Spring Cloud Stream是创建消息驱动微服务应用的框架。Spring Cloud Stream是基于spring boot创建，用来建立单独的／工业级spring应用，使用spring integration提供与消息代理之间的连接。数据流操作开发包，封装了与Redis、Rabbit、Kafka等发送接收消息。 一个业务会牵扯到多个任务，任务之间是通过事件触发的。</p><h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><img src="/posts/b27a891c/179.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>随着服务的越来越多，对调用链的分析会越来越复杂，如服务之间的调用关系、某个请求对应的调用链、调用之间消费的时间等，对这些信息进行监控就成为一个问题。在实际的使用中我们需要监控服务和服务之间通讯的各项指标，这些数据将是我们改进系统架构的主要依据。因此分布式的链路跟踪就变的非常重要，<strong>Spring Cloud也给出了具体的解决方案：Spring Cloud Sleuth和Zipkin</strong>。</p><p>服务跟踪；日志收集工具包，封装了Dapper,Zipkin和HTrace操作。 日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案。</p><p><strong>简介</strong></p><p>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。</p><p><strong>服务追踪分析</strong></p><p>微服务架构上通过业务来划分服务的，通过<strong>REST调用</strong>，对外暴露的一个接口，<strong>可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败</strong>。随着业务的不断扩张，服务之间互相调用会越来越复杂。</p><img src="/posts/b27a891c/180.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下：</p><img src="/posts/b27a891c/181.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p><strong>术语</strong></p><ul><li>Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址) span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。</li><li>Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。</li><li>Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束 cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始 sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟 ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间 cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间 将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</li></ul><img src="/posts/b27a891c/182.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><h2 id="Feign-使用HTTP请求远程服务"><a href="#Feign-使用HTTP请求远程服务" class="headerlink" title="Feign 使用HTTP请求远程服务"></a>Feign 使用HTTP请求远程服务</h2><p>涉及注解：@FeignClient(“微服务名称”)　　注：此注解用于接口</p><img src="/posts/b27a891c/183.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>在Spring Cloud Netflix栈中，各个微服务都是以HTTP接口的形式暴露自身服务的，因此在调用远程服务时就必须使用HTTP客户端。我们可以使用JDK原生的URLConnection、Apache的Http Client、Netty的异步HTTP Client, Spring的RestTemplate。但是，用起来最方便、最优雅的还是要属Feign了。 <strong>Feign是一种声明式、模板化的HTTP客户端</strong>。在Spring Cloud中使用Feign, 我们可以做到使用HTTP请求远程服务时能与调用本地方法一样的编码体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。 通过Feign， 我们能把HTTP远程调用对开发者完全透明，得到与调用本地方法一致的编码体验。这一点与阿里Dubbo中暴露远程服务的方式类似，<strong>区别在于Dubbo是基于私有二进制协议，而Feign本质上还是个HTTP客户端</strong>。如果是在用Spring Cloud Netflix搭建微服务，那么Feign无疑是最佳选择。</p><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p><p>简而言之：</p><ul><li>Feign 采用的是基于接口的注解</li><li>Feign 整合了ribbon</li></ul><h2 id="Cloud-Foundry"><a href="#Cloud-Foundry" class="headerlink" title="Cloud Foundry"></a>Cloud Foundry</h2><img src="/posts/b27a891c/184.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>Cloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题 其实就是与CloudFoundry进行集成的一套解决方案，抱了<strong>Cloud Foundry</strong>的大腿。</p><h2 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h2><img src="/posts/b27a891c/185.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>Spring Cloud Cluster将取代Spring Integration。提供在分布式系统中的集群所需要的基础功能支持，如：<strong>选举、集群的状态一致性、全局锁、tokens等</strong>常见状态模式的抽象和实现。 如果把不同的帮派组织成统一的整体，Spring Cloud Cluster已经帮你提供了很多方便组织成统一的工具。</p><h2 id="Spring-Cloud-Consul"><a href="#Spring-Cloud-Consul" class="headerlink" title="Spring Cloud Consul"></a>Spring Cloud Consul</h2><img src="/posts/b27a891c/186.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,<strong>由 HashiCorp 公司用 Go 语言开发</strong>, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对. Spring Cloud Consul 封装了Consul操作，consul是一个服务发现与配置工具，与Docker容器可以无缝集成。</p><h2 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h2><img src="/posts/b27a891c/187.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>Data flow 是一个用于开发和执行大范围数据处理其模式包括ETL，批量运算和持续运算的统一编程模型和托管服务。 对于在现代运行环境中可组合的微服务程序来说，Spring Cloud data flow是一个原生云可编配的服务。使用Spring Cloud data flow，开发者可以为像数据抽取，实时分析，和数据导入&#x2F;导出这种常见用例创建和编配数据通道 （data pipelines）。 Spring Cloud data flow 是基于原生云对 spring XD的重新设计，该项目目标是简化大数据应用的开发。Spring XD 的流处理和批处理模块的重构分别是基于 spring boot的stream 和 task&#x2F;batch 的微服务程序。这些程序现在都是自动部署单元而且他们原生的支持像 Cloud Foundry、Apache YARN、Apache Mesos和Kubernetes 等现代运行环境。 Spring Cloud data flow 为基于微服务的分布式流处理和批处理数据通道提供了一系列模型和最佳实践。</p><h2 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h2><img src="/posts/b27a891c/188.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>Spring Cloud Task 主要解决短命微服务的任务管理，任务调度的工作，比如说某些定时任务晚上就跑一次，或者某项数据分析临时就跑几次。</p><h2 id="Spring-Cloud-Connectors"><a href="#Spring-Cloud-Connectors" class="headerlink" title="Spring Cloud Connectors"></a>Spring Cloud Connectors</h2><img src="/posts/b27a891c/189.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>Spring Cloud Connectors 简化了连接到服务的过程和从云平台获取操作的过程，有很强的扩展性，可以利用Spring Cloud Connectors来构建你自己的云平台。 便于云端应用程序在各种PaaS平台连接到后端，如：数据库和消息代理服务。</p><h2 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h2><img src="/posts/b27a891c/192.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>Spring Boot式的启动项目，为Spring Cloud提供开箱即用的依赖管理。</p><p><strong>3.20、Spring Cloud CLI</strong></p><img src="/posts/b27a891c/190.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。</p><h2 id="Netflix-Turbine"><a href="#Netflix-Turbine" class="headerlink" title="Netflix Turbine"></a>Netflix Turbine</h2><img src="/posts/b27a891c/191.jpg" srcset="/img/loading.gif" lazyload alt="img" style="zoom:80%"><p>Turbine是聚合服务器发送事件流数据的一个工具，用来监控集群下hystrix的metrics情况。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Java/" class="category-chain-item">Java</a> <span>></span> <a href="/categories/Java/Spring/" class="category-chain-item">Spring</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/springcloud/">#springcloud</a></div></div><div class="license-box my-3"><div class="license-title"><div>SpringCloud 组件概念</div><div>https://blog.yahyav2rayssr.top/posts/b27a891c/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Yahya</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年4月16日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/4e9ceea/" title="Spring 基础"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Spring 基础</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/2547f24d/" title="Spring 启动流程"><span class="hidden-mobile">Spring 启动流程</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>