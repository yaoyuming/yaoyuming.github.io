<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yahya"><meta name="keywords" content=""><meta name="description" content="SpringMVC执行流程: 用户发送请求至前端控制器DispatcherServlet  DispatcherServlet收到请求调用处理器映射器HandlerMapping。  处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。  DispatcherServle"><meta property="og:type" content="article"><meta property="og:title" content="查缺补漏"><meta property="og:url" content="https://blog.yahyav2rayssr.top/posts/d7158ead/index.html"><meta property="og:site_name" content="yahya的博客"><meta property="og:description" content="SpringMVC执行流程: 用户发送请求至前端控制器DispatcherServlet  DispatcherServlet收到请求调用处理器映射器HandlerMapping。  处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。  DispatcherServle"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/d7158ead/203.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/d7158ead/%E5%B9%82%E7%AD%89%E6%80%A7.png"><meta property="article:published_time" content="2023-04-16T03:08:31.618Z"><meta property="article:modified_time" content="2023-04-16T03:08:31.620Z"><meta property="article:author" content="Yahya"><meta property="article:tag" content="查缺补漏"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog.yahyav2rayssr.top/posts/d7158ead/203.jpg"><title>查缺补漏 - yahya的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"blog.yahyav2rayssr.top",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!1,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!1,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:6},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="yahya的博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yahya的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="查缺补漏"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-16 11:08" pubdate>2023年4月16日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 6.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 54 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">查缺补漏</h1><p class="note note-info">本文最后更新于：2023年4月16日 上午</p><div class="markdown-body"><h2 id="SpringMVC执行流程"><a href="#SpringMVC执行流程" class="headerlink" title="SpringMVC执行流程:"></a><strong>SpringMVC执行流程:</strong></h2><ol><li><p>用户发送请求至前端控制器DispatcherServlet</p></li><li><p>DispatcherServlet收到请求调用处理器映射器HandlerMapping。</p></li><li><p>处理器映射器根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)一并返回给DispatcherServlet。</p></li><li><p>DispatcherServlet根据处理器Handler获取处理器适配器HandlerAdapter执行HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</p></li><li><p>执行处理器Handler(Controller，也叫页面控制器)。</p></li><li><p>Handler执行完成返回ModelAndView</p></li><li><p>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet</p></li><li><p>DispatcherServlet将ModelAndView传给ViewResolver视图解析器</p></li><li><p>ViewResolver解析后返回具体View</p></li><li><p>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）。</p></li><li><p>DispatcherServlet响应用户。</p></li></ol><h2 id="spring的反射有什么问题"><a href="#spring的反射有什么问题" class="headerlink" title="spring的反射有什么问题"></a>spring的反射有什么问题</h2><p>java的反射破坏了封装，性能也是一个问题；反射不能用jit加速。</p><h2 id="springboot启动过程"><a href="#springboot启动过程" class="headerlink" title="springboot启动过程"></a>springboot启动过程</h2><p>@SpringBootConfiguration 通过与 @Bean 结合完成Bean的 JavaConfig配置；</p><p>@ComponentScan 通过范围扫描的方式，扫描特定注解注释的类，将其注册到Spring容器；</p><p>@EnableAutoConfiguration 通过 spring.factories 的配置，并结合 @Condition 条件，完成bean的注册；</p><p>@Import 通过导入的方式，将指定的class注册解析到Spring容器；</p><img src="/posts/d7158ead/203.jpg" srcset="/img/loading.gif" lazyload><p>我们将各步骤总结精炼如下：</p><ol><li>通过 <code>SpringFactoriesLoader</code> 加载 <code>META-INF/spring.factories</code> 文件，获取并创建 <code>SpringApplicationRunListener</code> 对象</li><li>然后由 <code>SpringApplicationRunListener</code> 来发出 starting 消息</li><li>创建参数，并配置当前 SpringBoot 应用将要使用的 Environment</li><li>完成之后，依然由 <code>SpringApplicationRunListener</code> 来发出 environmentPrepared 消息</li><li>创建 <code>ApplicationContext</code></li><li>初始化 <code>ApplicationContext</code>，并设置 Environment，载相关配置等</li><li>由 <code>SpringApplicationRunListener</code> 来发出 <code>contextPrepared</code> 消息，告知SpringBoot 应用使用的 <code>ApplicationContext</code> 已准备OK</li><li>将各种 beans 装载入 <code>ApplicationContext</code>，继续由 <code>SpringApplicationRunListener</code> 来发出 contextLoaded 消息，告知 SpringBoot 应用使用的 <code>ApplicationContext</code> 已装填OK</li><li>refresh ApplicationContext，完成IoC容器可用的最后一步</li><li>由 <code>SpringApplicationRunListener</code> 来发出 started 消息</li><li>完成最终的程序的启动</li><li>由 <code>SpringApplicationRunListener</code> 来发出 running 消息，告知程序已运行起来了</li></ol><h2 id="问：Spring-Boot-Starter-的工作原理是什么？"><a href="#问：Spring-Boot-Starter-的工作原理是什么？" class="headerlink" title="问：Spring Boot Starter 的工作原理是什么？"></a>问：Spring Boot Starter 的工作原理是什么？</h2><p>答：Spring Boot 在启动的时候会干这几件事情：</p><ul><li>① Spring Boot 在启动时会去依赖的 Starter 包中寻找 resources&#x2F;META-INF&#x2F;spring.factories 文件，然后根据文件中配置的 Jar 包去扫描项目所依赖的 Jar 包。</li><li>② 根据 spring.factories 配置加载 AutoConfigure 类</li><li>③ 根据 @Conditional 注解的条件，进行自动配置并将 Bean 注入 Spring Context</li></ul><h2 id="1、Spring-Boot-的自动配置是如何实现的？"><a href="#1、Spring-Boot-的自动配置是如何实现的？" class="headerlink" title="1、Spring Boot 的自动配置是如何实现的？"></a>1、Spring Boot 的自动配置是如何实现的？</h2><p>Spring Boot 项目的启动注解是：@SpringBootApplication，其实它就是由下面三个注解组成的：</p><ul><li>@Configuration</li><li>@ComponentScan</li><li>@EnableAutoConfiguration</li></ul><p>其中 @EnableAutoConfiguration 是实现自动配置的入口，该注解又通过 @Import 注解导入了AutoConfigurationImportSelector，在该类中加载 META-INF&#x2F;spring.factories 的配置信息。然后筛选出以 EnableAutoConfiguration 为 key 的数据，加载到 IOC 容器中，实现自动配置功能！</p><h2 id="21、描述一下JVM加载class文件的原理机制？"><a href="#21、描述一下JVM加载class文件的原理机制？" class="headerlink" title="21、描述一下JVM加载class文件的原理机制？"></a>21、描述一下JVM加载class文件的原理机制？</h2><p>答：JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。</p><p>由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。</p><p>类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p><p>​ Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；</p><p>​ Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；</p><p>​ System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</p><h2 id="Comparable和Comparator接口是干什么的，其区别"><a href="#Comparable和Comparator接口是干什么的，其区别" class="headerlink" title="Comparable和Comparator接口是干什么的，其区别"></a>Comparable和Comparator接口是干什么的，其区别</h2><p>Comparable &amp; Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。</p><p>Comparator位于包java.util下，而Comparable位于包 java.lang下 Comparable 是一个对象本身就已经支持自比较所需要实现的接口（如 String、Integer 自己就可以完成比较大小操作，已经实现了Comparable接口） 自定义的类要在加入list容器中后能够排序，可以实现Comparable接口，在用Collections类的sort方法排序时，如果不指定Comparator，那么就以自然顺序排序， 这里的自然顺序就是实现Comparable接口设定的排序方式。</p><p>而 Comparator 是一个专用的比较器，当这个对象不支持自比较或者自比较函数不能满足你的要求时，你可以写一个比较器来完成两个对象之间大小的比较。 可以说一个是自已完成比较，一个是外部程序实现比较的差别而已。</p><p>用 Comparator 是策略模式（strategy design pattern），就是不改变对象自身，而用一个策略对象（strategy object）来改变它的行为。 比如：你想对整数采用绝对值大小来排序，Integer 是不符合要求的，你不需要去修改 Integer 类（实际上你也不能这么做）去改变它的排序行为，只要使用一个实现了 Comparator 接口的对象来实现控制它的排序就行了。</p><h2 id="分布式Session的几种实现方式"><a href="#分布式Session的几种实现方式" class="headerlink" title="分布式Session的几种实现方式"></a>分布式Session的几种实现方式</h2><ol><li><p>session复制：在支持session复制的服务器上进行，同步session，保持session一致</p><p>方案：<code>tomcat-redis-session-manager</code></p></li><li><p>session粘滞：强行分发session到各个服务器</p><p>方案：负载均衡</p></li><li><p>cookie存储session：把sessionid存储到cookie中(不安全，cookie容易被盗取，可以存储不重要的数据)</p></li><li><p>session集中管理：把用户的session存储在单台或者集群服务器的缓存中，所有web服务器从中拿取session，实现session共享</p><p>方案：Redis存储用户生成的sessionId或者存储保存sessionId的cookie</p></li></ol><h2 id="Mybatis的mapper文件中resultType和resultMap的区别。"><a href="#Mybatis的mapper文件中resultType和resultMap的区别。" class="headerlink" title="Mybatis的mapper文件中resultType和resultMap的区别。"></a>Mybatis的mapper文件中resultType和resultMap的区别。</h2><p>1、查询结果为Map时，使用resultType;</p><p>2、简单查询且结果为Pojo类，也可以使用resultType,另外，查询字段名与Pojo属性名不一致，可以通过使用别名的方式；</p><p>3、复杂的映射或级联，可以使用resultMap;</p><h2 id="Spring中七种事务传播行为"><a href="#Spring中七种事务传播行为" class="headerlink" title="Spring中七种事务传播行为"></a>Spring中七种事务传播行为</h2><table><thead><tr><th>事务传播行为类型</th><th>说明</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><h2 id="REQUIRED-REQUIRES-NEW-NESTED异同"><a href="#REQUIRED-REQUIRES-NEW-NESTED异同" class="headerlink" title="REQUIRED,REQUIRES_NEW,NESTED异同"></a>REQUIRED,REQUIRES_NEW,NESTED异同</h2><p>NESTED和REQUIRED修饰的内部方法都属于外围方法事务，如果外围方法抛出异常，这两种方法的事务都会被回滚。但是REQUIRED是加入外围方法事务，所以和外围事务同属于一个事务，一旦REQUIRED事务抛出异常被回滚，外围方法事务也将被回滚。而NESTED是外围方法的子事务，有单独的保存点，所以NESTED方法抛出异常被回滚，不会影响到外围方法的事务。</p><p>NESTED和REQUIRES_NEW都可以做到内部方法事务回滚而不影响外围方法事务。但是因为NESTED是嵌套事务，所以外围方法回滚之后，作为外围方法事务的子事务也会被回滚。而REQUIRES_NEW是通过开启新的事务实现的，内部事务和外围事务是两个事务，外围事务回滚不会影响内部事务。</p><h2 id="nginx负载均衡的5种策略"><a href="#nginx负载均衡的5种策略" class="headerlink" title="nginx负载均衡的5种策略"></a>nginx负载均衡的5种策略</h2><h3 id="轮询（默认）"><a href="#轮询（默认）" class="headerlink" title="轮询（默认）"></a>轮询（默认）</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backserver &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.14</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.15</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="weight"><a href="#weight" class="headerlink" title="weight"></a>weight</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backserver &#123;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.14</span> weight=<span class="hljs-number">3</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.15</span> weight=<span class="hljs-number">7</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ip-hash"><a href="#ip-hash" class="headerlink" title="ip_hash"></a>ip_hash</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backserver &#123;<br>    ip_hash;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.14:88</span>;<br>    <span class="hljs-attribute">server</span> <span class="hljs-number">192.168.0.15:80</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fair"><a href="#fair" class="headerlink" title="fair"></a>fair</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backserver &#123;<br>    <span class="hljs-attribute">server</span> server1;<br>    <span class="hljs-attribute">server</span> server2;<br>    fair;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="url-hash"><a href="#url-hash" class="headerlink" title="url_hash"></a>url_hash</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> backserver &#123;<br>    <span class="hljs-attribute">server</span> squid1:<span class="hljs-number">3128</span>;<br>    <span class="hljs-attribute">server</span> squid2:<span class="hljs-number">3128</span>;<br>    <span class="hljs-attribute">hash</span> <span class="hljs-variable">$request_uri</span>;<br>    <span class="hljs-attribute">hash_method</span> crc32;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="spring是如何解决循环依赖的？"><a href="#spring是如何解决循环依赖的？" class="headerlink" title="spring是如何解决循环依赖的？"></a>spring是如何解决循环依赖的？</h2><p>构造器的循环依赖：这种依赖spring是处理不了的，直接抛出BeanCurrentlylnCreationException异常。</p><p>单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。</p><ul><li>singletonObjects &#x2F;&#x2F; 一级缓存</li><li>earlySingletonObjects &#x2F;&#x2F; 二级缓存</li><li>singletonFactories &#x2F;&#x2F; 三级缓存</li></ul><p>非单例循环依赖：无法处理。</p><h2 id="幂等性实现方案"><a href="#幂等性实现方案" class="headerlink" title="幂等性实现方案"></a>幂等性实现方案</h2><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>如果只是更新已有的数据，没有必要对业务进行加锁，设计表结构时使用乐观锁，一般通过version来做乐观锁，这样既能保证执行效率，又能保证幂等。</p><h3 id="防重表"><a href="#防重表" class="headerlink" title="防重表"></a>防重表</h3><p>使用订单号 orderNo 做为去重表的唯一索引，每次请求都根据订单号向去重表中插入一条数据。第一次请求查询订单支付状态，订单没有支付，进行支付操作，无论成功与否，执行完后更新订单状态为成功或失败，删除去重表中的数据。后续的订单因为表中唯一索引而插入失败，则返回操作失败，直到第一次的请求完成（成功或失败）。</p><img src="/posts/d7158ead/%E5%B9%82%E7%AD%89%E6%80%A7.png" srcset="/img/loading.gif" lazyload alt="img"><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>对于防重表可以用分布式锁代替，比如 Redis 和 Zookeeper</p><p><strong>Redis</strong></p><ol><li>订单发起支付请求，支付系统会去 Redis 缓存中查询是否存在该订单号的 Key，如果不存在，则向 Redis 增加 Key 为订单号</li><li>查询订单支付状态，如果未支付，则进行支付流程，支付完成后删除该订单号的 key</li></ol><p><strong>Zookeeper</strong></p><ol><li>订单发起支付请求，支付系统会去 Zookeeper 中创建一个 node，如果创建失败，则表示订单已经被支付</li><li>如果创建成功，则进行支付流程，支付完成后删除 node</li></ol><h3 id="Token-机制"><a href="#Token-机制" class="headerlink" title="Token 机制"></a>Token 机制</h3><p>这种方式分成两个阶段：申请 Token 阶段和支付阶段。 第一阶段，在进入到提交订单页面之前，需要订单系统根据用户信息向支付系统发起一次申请 Token 的请求，支付系统将 Token 保存到 Redis 缓存中，为第二阶段支付使用。 第二阶段，订单系统拿着申请到的 Token 发起支付请求，支付系统会检查 Redis 中是否存在该 Token ，如果存在，表示第一次发起支付请求，删除缓存中 Token 后开始支付逻辑处理；如果缓存中不存在，表示非法请求。</p><h3 id="消息队列缓冲"><a href="#消息队列缓冲" class="headerlink" title="消息队列缓冲"></a>消息队列缓冲</h3><p>将订单的支付请求全部发送到消息队列中，然后使用异步任务处理队列中的数据，过滤掉重复的待支付订单，再进行支付流程。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/">#查缺补漏</a></div></div><div class="license-box my-3"><div class="license-title"><div>查缺补漏</div><div>https://blog.yahyav2rayssr.top/posts/d7158ead/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Yahya</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年4月16日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/4a137bcb/" title="v2rayN 配置教程"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">v2rayN 配置教程</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/4a49b547/" title="黑苹果常用配置"><span class="hidden-mobile">黑苹果常用配置</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>