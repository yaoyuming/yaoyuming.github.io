<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yahya"><meta name="keywords" content=""><meta name="description" content="多线程基础类与对象的区别类是对某一类事物的描述，是抽象的，而对象是一个实实在在的个体，是类的一个实例。 本线程与当前线程“本线程”表示this（以及this对应的线程的意思）。 “当前线程”则是指调用对象方法的线程。 举个例子： public final void join() throws InterruptedException 让当前线程（调用join方法的线程）等待本线程（this）终止。"><meta property="og:type" content="article"><meta property="og:title" content="Java 多线程基础"><meta property="og:url" content="https://blog.yahyav2rayssr.top/posts/71aa5641/index.html"><meta property="og:site_name" content="yahya的博客"><meta property="og:description" content="多线程基础类与对象的区别类是对某一类事物的描述，是抽象的，而对象是一个实实在在的个体，是类的一个实例。 本线程与当前线程“本线程”表示this（以及this对应的线程的意思）。 “当前线程”则是指调用对象方法的线程。 举个例子： public final void join() throws InterruptedException 让当前线程（调用join方法的线程）等待本线程（this）终止。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/71aa5641/9.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/71aa5641/image-20200912223705497.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/71aa5641/10.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/71aa5641/84.png"><meta property="article:published_time" content="2023-04-18T15:31:29.155Z"><meta property="article:modified_time" content="2023-04-18T15:31:29.156Z"><meta property="article:author" content="Yahya"><meta property="article:tag" content="多线程"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog.yahyav2rayssr.top/posts/71aa5641/9.jpg"><title>Java 多线程基础 - yahya的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"blog.yahyav2rayssr.top",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!1,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!1,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:6},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="yahya的博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yahya的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Java 多线程基础</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-18 23:31" pubdate>2023年4月18日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 17k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 141 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Java" id="heading-d52387880e1ea22817a72d3759213819" role="tab" data-toggle="collapse" href="#collapse-d52387880e1ea22817a72d3759213819" aria-expanded="true">Java <span class="list-group-count">(55)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-d52387880e1ea22817a72d3759213819" role="tabpanel" aria-labelledby="heading-d52387880e1ea22817a72d3759213819"><div class="category-post-list"><a href="/posts/a3b6ed09/" title="Java 常用命令" class="list-group-item list-group-item-action"><span class="category-post">Java 常用命令</span></a></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="JVM" id="heading-18b5a217c4dad25662d3a05edb0e39d7" role="tab" data-toggle="collapse" href="#collapse-18b5a217c4dad25662d3a05edb0e39d7" aria-expanded="false">JVM <span class="list-group-count">(6)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-18b5a217c4dad25662d3a05edb0e39d7" role="tabpanel" aria-labelledby="heading-18b5a217c4dad25662d3a05edb0e39d7"><div class="category-post-list"><a href="/posts/9e0bfe2e/" title="JVM 垃圾收集器" class="list-group-item list-group-item-action"><span class="category-post">JVM 垃圾收集器</span> </a><a href="/posts/5b44aded/" title="JVM 垃圾收集器与内存分配策略" class="list-group-item list-group-item-action"><span class="category-post">JVM 垃圾收集器与内存分配策略</span> </a><a href="/posts/62787a65/" title="JVM 基本概念" class="list-group-item list-group-item-action"><span class="category-post">JVM 基本概念</span> </a><a href="/posts/7c42c21b/" title="JVM 指令大全" class="list-group-item list-group-item-action"><span class="category-post">JVM 指令大全</span> </a><a href="/posts/1b362162/" title="JVM 杂项" class="list-group-item list-group-item-action"><span class="category-post">JVM 杂项</span> </a><a href="/posts/703fe08b/" title="JVM 运行时数据区域" class="list-group-item list-group-item-action"><span class="category-post">JVM 运行时数据区域</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Java 基础" id="heading-3c457761d24c20abb3e9682a48e47df6" role="tab" data-toggle="collapse" href="#collapse-3c457761d24c20abb3e9682a48e47df6" aria-expanded="false">Java 基础 <span class="list-group-count">(6)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-3c457761d24c20abb3e9682a48e47df6" role="tabpanel" aria-labelledby="heading-3c457761d24c20abb3e9682a48e47df6"><div class="category-post-list"><a href="/posts/80d2509b/" title="Java IO 流详解" class="list-group-item list-group-item-action"><span class="category-post">Java IO 流详解</span> </a><a href="/posts/fa358471/" title="Java 反射" class="list-group-item list-group-item-action"><span class="category-post">Java 反射</span> </a><a href="/posts/a019e08c/" title="Java 基础" class="list-group-item list-group-item-action"><span class="category-post">Java 基础</span> </a><a href="/posts/74a86a53/" title="Java 数学运算" class="list-group-item list-group-item-action"><span class="category-post">Java 数学运算</span> </a><a href="/posts/23a29293/" title="Java 时间运算" class="list-group-item list-group-item-action"><span class="category-post">Java 时间运算</span> </a><a href="/posts/3aa3d5b8/" title="lambda 表达式用法" class="list-group-item list-group-item-action"><span class="category-post">lambda 表达式用法</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Spring" id="heading-38008dd81c2f4d7985ecf6e0ce8af1d1" role="tab" data-toggle="collapse" href="#collapse-38008dd81c2f4d7985ecf6e0ce8af1d1" aria-expanded="false">Spring <span class="list-group-count">(10)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-38008dd81c2f4d7985ecf6e0ce8af1d1" role="tabpanel" aria-labelledby="heading-38008dd81c2f4d7985ecf6e0ce8af1d1"><div class="category-post-list"><a href="/posts/2ed6c644/" title="Spring AOP 详解" class="list-group-item list-group-item-action"><span class="category-post">Spring AOP 详解</span> </a><a href="/posts/698a4e8e/" title="Spring Validation 校验" class="list-group-item list-group-item-action"><span class="category-post">Spring Validation 校验</span> </a><a href="/posts/940ce4f5/" title="Spring 全局属性转换配置" class="list-group-item list-group-item-action"><span class="category-post">Spring 全局属性转换配置</span> </a><a href="/posts/fac11a47/" title="Spring 单元测试" class="list-group-item list-group-item-action"><span class="category-post">Spring 单元测试</span> </a><a href="/posts/4e9ceea/" title="Spring 基础" class="list-group-item list-group-item-action"><span class="category-post">Spring 基础</span> </a><a href="/posts/70a6ebcd/" title="Spring 常用注解" class="list-group-item list-group-item-action"><span class="category-post">Spring 常用注解</span> </a><a href="/posts/7be9f3eb/" title="Spring 常见错误" class="list-group-item list-group-item-action"><span class="category-post">Spring 常见错误</span> </a><a href="/posts/b27a891c/" title="SpringCloud 组件概念" class="list-group-item list-group-item-action"><span class="category-post">SpringCloud 组件概念</span> </a><a href="/posts/2547f24d/" title="Springboot 启动流程" class="list-group-item list-group-item-action"><span class="category-post">Springboot 启动流程</span> </a><a href="/posts/fd57e58c/" title="Springboot 常用配置" class="list-group-item list-group-item-action"><span class="category-post">Springboot 常用配置</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="gradle" id="heading-8ed1a771bc236c287ad93c699bfdd2d7" role="tab" data-toggle="collapse" href="#collapse-8ed1a771bc236c287ad93c699bfdd2d7" aria-expanded="false">gradle <span class="list-group-count">(3)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-8ed1a771bc236c287ad93c699bfdd2d7" role="tabpanel" aria-labelledby="heading-8ed1a771bc236c287ad93c699bfdd2d7"><div class="category-post-list"><a href="/posts/884ca42/" title="Gradle 基础概念" class="list-group-item list-group-item-action"><span class="category-post">Gradle 基础概念</span> </a><a href="/posts/398308f9/" title="Gradle 安装配置" class="list-group-item list-group-item-action"><span class="category-post">Gradle 安装配置</span> </a><a href="/posts/62a229e/" title="Gradle 常用配置" class="list-group-item list-group-item-action"><span class="category-post">Gradle 常用配置</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="maven" id="heading-402c5d9af6b43711ea070bee5170f74d" role="tab" data-toggle="collapse" href="#collapse-402c5d9af6b43711ea070bee5170f74d" aria-expanded="false">maven <span class="list-group-count">(6)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-402c5d9af6b43711ea070bee5170f74d" role="tabpanel" aria-labelledby="heading-402c5d9af6b43711ea070bee5170f74d"><div class="category-post-list"><a href="/posts/25549297/" title="Maven mvnw 详解" class="list-group-item list-group-item-action"><span class="category-post">Maven mvnw 详解</span> </a><a href="/posts/5c907e7a/" title="Maven 基本安装（windows）" class="list-group-item list-group-item-action"><span class="category-post">Maven 基本安装（windows）</span> </a><a href="/posts/6ff6dc3c/" title="Maven 基础概念" class="list-group-item list-group-item-action"><span class="category-post">Maven 基础概念</span> </a><a href="/posts/c718cdb9/" title="Maven 常用命令" class="list-group-item list-group-item-action"><span class="category-post">Maven 常用命令</span> </a><a href="/posts/615834e0/" title="Maven 常用配置" class="list-group-item list-group-item-action"><span class="category-post">Maven 常用配置</span> </a><a href="/posts/4f5fa1df/" title="Maven 常见问题" class="list-group-item list-group-item-action"><span class="category-post">Maven 常见问题</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="mybatis" id="heading-f0d71b77ac2ea991f39f9dfdd5e985b5" role="tab" data-toggle="collapse" href="#collapse-f0d71b77ac2ea991f39f9dfdd5e985b5" aria-expanded="false">mybatis <span class="list-group-count">(3)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-f0d71b77ac2ea991f39f9dfdd5e985b5" role="tabpanel" aria-labelledby="heading-f0d71b77ac2ea991f39f9dfdd5e985b5"><div class="category-post-list"><a href="/posts/2f2b0963/" title="Mybatis-plus XML 标签用法" class="list-group-item list-group-item-action"><span class="category-post">Mybatis-plus XML 标签用法</span> </a><a href="/posts/f384c0b1/" title="Mybatis-plus 代码用法" class="list-group-item list-group-item-action"><span class="category-post">Mybatis-plus 代码用法</span> </a><a href="/posts/3080fe57/" title="Mybatis-plus 基本配置" class="list-group-item list-group-item-action"><span class="category-post">Mybatis-plus 基本配置</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="多线程" id="heading-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7" role="tab" data-toggle="collapse" href="#collapse-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7" aria-expanded="true">多线程 <span class="list-group-count">(11)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7" role="tabpanel" aria-labelledby="heading-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7"><div class="category-post-list"><a href="/posts/9784837e/" title="AQS 原理" class="list-group-item list-group-item-action"><span class="category-post">AQS 原理</span> </a><a href="/posts/18ad812a/" title="CountDownLatch 应用" class="list-group-item list-group-item-action"><span class="category-post">CountDownLatch 应用</span> </a><a href="/posts/27d2027c/" title="CyclicBarrier 应用" class="list-group-item list-group-item-action"><span class="category-post">CyclicBarrier 应用</span> </a><a href="/posts/e5b78a2e/" title="Java 多线程入门" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程入门</span> </a><a href="/posts/71aa5641/" title="Java 多线程基础" class="list-group-item list-group-item-action active"><span class="category-post">Java 多线程基础</span> </a><a href="/posts/ff94c717/" title="Java 多线程基础集合体系概述" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程基础集合体系概述</span> </a><a href="/posts/7c5551ea/" title="Java 多线程常用 API" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程常用 API</span> </a><a href="/posts/4b405cfc/" title="Java 多线程设计模式" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程设计模式</span> </a><a href="/posts/cf2a801/" title="Java 线程池详解" class="list-group-item list-group-item-action"><span class="category-post">Java 线程池详解</span> </a><a href="/posts/bcd2abf0/" title="Semaphore 应用" class="list-group-item list-group-item-action"><span class="category-post">Semaphore 应用</span> </a><a href="/posts/61ccd33e/" title="StampedLock 应用" class="list-group-item list-group-item-action"><span class="category-post">StampedLock 应用</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="工具库" id="heading-de33723f9f63fa412b6071def21565ce" role="tab" data-toggle="collapse" href="#collapse-de33723f9f63fa412b6071def21565ce" aria-expanded="false">工具库 <span class="list-group-count">(5)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-de33723f9f63fa412b6071def21565ce" role="tabpanel" aria-labelledby="heading-de33723f9f63fa412b6071def21565ce"><div class="category-post-list"><a href="/posts/86e940c9/" title="fastjson 常用 API" class="list-group-item list-group-item-action"><span class="category-post">fastjson 常用 API</span> </a><a href="/posts/4e9562ed/" title="fastjson 常见问题" class="list-group-item list-group-item-action"><span class="category-post">fastjson 常见问题</span> </a><a href="/posts/df564e8b/" title="lombok 基础" class="list-group-item list-group-item-action"><span class="category-post">lombok 基础</span> </a><a href="/posts/34954977/" title="swagger 常用注解" class="list-group-item list-group-item-action"><span class="category-post">swagger 常用注解</span> </a><a href="/posts/f5eac37d/" title="工具库杂项" class="list-group-item list-group-item-action"><span class="category-post">工具库杂项</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="数据结构" id="heading-0fea7c47d93da5689f31820ee525b367" role="tab" data-toggle="collapse" href="#collapse-0fea7c47d93da5689f31820ee525b367" aria-expanded="false">数据结构 <span class="list-group-count">(3)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-0fea7c47d93da5689f31820ee525b367" role="tabpanel" aria-labelledby="heading-0fea7c47d93da5689f31820ee525b367"><div class="category-post-list"><a href="/posts/39a12d12/" title="ConcurrentHashMap 详解" class="list-group-item list-group-item-action"><span class="category-post">ConcurrentHashMap 详解</span> </a><a href="/posts/e344884c/" title="HashMap 详解" class="list-group-item list-group-item-action"><span class="category-post">HashMap 详解</span> </a><a href="/posts/c9844e82/" title="Java 数据结构基础" class="list-group-item list-group-item-action"><span class="category-post">Java 数据结构基础</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="设计模式" id="heading-301a19970448f8e4f27ddae7a7d415fe" role="tab" data-toggle="collapse" href="#collapse-301a19970448f8e4f27ddae7a7d415fe" aria-expanded="false">设计模式 <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-301a19970448f8e4f27ddae7a7d415fe" role="tabpanel" aria-labelledby="heading-301a19970448f8e4f27ddae7a7d415fe"><div class="category-post-list"><a href="/posts/fa3d1251/" title="Java 设计模式" class="list-group-item list-group-item-action"><span class="category-post">Java 设计模式</span></a></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Java 多线程基础</h1><p class="note note-info">本文最后更新于：2023年4月18日 晚上</p><div class="markdown-body"><h1 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h1><h2 id="类与对象的区别"><a href="#类与对象的区别" class="headerlink" title="类与对象的区别"></a>类与对象的区别</h2><p>类是对某一类事物的描述，是抽象的，而对象是一个实实在在的个体，是类的一个实例。</p><h2 id="本线程与当前线程"><a href="#本线程与当前线程" class="headerlink" title="本线程与当前线程"></a>本线程与当前线程</h2><p>“本线程”表示this（以及this对应的线程的意思）。</p><p>“当前线程”则是指调用对象方法的线程。</p><p>举个例子：</p><p><code>public final void join() throws InterruptedException</code></p><p>让当前线程（调用join方法的线程）等待本线程（this）终止。</p><h2 id="start和run的区别"><a href="#start和run的区别" class="headerlink" title="start和run的区别"></a>start和run的区别</h2><h3 id="start"><a href="#start" class="headerlink" title="start() :"></a>start() :</h3><p>它的作用是启动一个新线程。<br>通过start()方法来启动的新线程，处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行相应线程的run()方法，这里方法run()称为线程体，它包含了要执行的这个线程的内容，run方法运行结束，此线程随即终止。start()不能被重复调用。用start方法来启动线程，真正实现了多线程运行，即无需等待某个线程的run方法体代码执行完毕就直接继续执行下面的代码。这里无需等待run方法执行完毕，即可继续执行下面的代码，即进行了线程切换。</p><h3 id="run"><a href="#run" class="headerlink" title="run()   :"></a>run() :</h3><p>run()就和普通的成员方法一样，可以被重复调用。<br>如果直接调用run方法，并不会启动新线程！程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码，这样就没有达到多线程的目的。<br>总结：调用start方法方可启动线程，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</p><p>总结一下：</p><ol><li>start() 可以启动一个新线程，run()不能</li><li>start()不能被重复调用，run()可以</li><li>start()中的run代码可以不执行完就继续执行下面的代码，即进行了线程切换。直接调用run方法必须等待其代码全部执行完才能继续执行下面的代码。</li><li>start() 实现了多线程，run()没有实现多线程。</li></ol><h2 id="Thread-currentThread-与this的区别"><a href="#Thread-currentThread-与this的区别" class="headerlink" title="Thread.currentThread()与this的区别"></a>Thread.currentThread()与this的区别</h2><p>Thread.currentThread()可以获取当前线程的引用，一般都是在没有线程对象又需要获得线程信息时通过Thread.currentThread()获取当前代码段所在线程的引用</p><p>this.XXX()调用的是当前对象的方法</p><h2 id="interrupt、interrupted-、isInterrupted-区别"><a href="#interrupt、interrupted-、isInterrupted-区别" class="headerlink" title="interrupt、interrupted 、isInterrupted 区别"></a>interrupt、interrupted 、isInterrupted 区别</h2><p>interrupt()：将调用该方法的对象所表示的线程标记一个停止标记，并不是真的停止该线程。</p><p>interrupted()：获取当前线程的中断状态，并且会清除线程的状态标记。 是一个是静态方法。</p><p>isInterrupted()：获取调用该方法的对象所表示的线程，不会清除线程的状态标记。</p><table><thead><tr><th>方法名</th><th>静态</th></tr></thead><tbody><tr><td>interrupted</td><td>√</td></tr><tr><td>isInterrupted</td><td>×</td></tr></tbody></table><h2 id="停止线程的方式"><a href="#停止线程的方式" class="headerlink" title="停止线程的方式"></a>停止线程的方式</h2><blockquote><p>前提都是要调用判断中断状态的interrupted()或者isInterrupted()方法</p></blockquote><ol><li>阻塞状态（sleep,wait等）</li><li>interrupt() + return</li><li>抛异常法</li></ol><h2 id="suspend-、resume"><a href="#suspend-、resume" class="headerlink" title="suspend()、resume()"></a>suspend()、resume()</h2><blockquote><p>暂停&#x2F;恢复线程</p></blockquote><h2 id="isAlive"><a href="#isAlive" class="headerlink" title="isAlive()"></a>isAlive()</h2><blockquote><p>判断线程是否在运行</p></blockquote><h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><blockquote><p>放弃当前的CPU资源</p></blockquote><h2 id="优先级（priority）"><a href="#优先级（priority）" class="headerlink" title="优先级（priority）"></a>优先级（priority）</h2><ul><li>继承性（可继承main或者父级的优先级）</li><li>规则性（优先级高执行的机会多）</li><li>随机性（优先级高不一定先执行）</li></ul><p><strong>表示优先级的静态字段</strong></p><ul><li>Thread.MIN_PRIORITY：表示最低优先级的值</li><li>Thread.NORM_PRIORITY：表示默认优先级的值</li><li>Thread.MAX_PRIORITY：表示最高优先级的值</li></ul><h2 id="Daemon守护进程"><a href="#Daemon守护进程" class="headerlink" title="Daemon守护进程"></a>Daemon守护进程</h2><p><code>public final void setDaemon(boolean on)</code></p><p>当on为true时，本线程（this）会变成守护进程。</p><p>如果本线程已经启动了，异常java.lang.IllegalThreadStateException会被抛出。</p><p>如果当前线程无法改变本线程（this），异常java.lang.SecurityException会被抛出。</p><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><blockquote><p>发生脏读的情况是在读取实例变量时，此值已经被其他线程更改过了。</p></blockquote><h2 id="锁重入"><a href="#锁重入" class="headerlink" title="锁重入"></a>锁重入</h2><blockquote><p>关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁是可以再次得到对象的锁的。这也证明在一个synchronized方法&#x2F;块的内部调用本类的其他synchronized方法&#x2F;块时，是永远可以得到锁的。</p></blockquote><ul><li>出现异常，锁自动释放</li><li>同步锁不能被子类继承</li></ul><h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><p>Semaphore、CountDownLatch、CyclicBarrier、Exchanger&lt;V&gt;都是用于线程同步的类。</p><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>Semaphore</td><td>计数信号量</td></tr><tr><td>CountDownLatch</td><td>让线程等待某个操作执行完指定次数的同步机制</td></tr><tr><td>CyclicBarrier</td><td>让多个线程在特定位置（屏障）等待的同步机制</td></tr><tr><td>Exchanger&lt;V&gt;</td><td>让两个线程交换对象的同步机制</td></tr></tbody></table><h2 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h2><p>synchronized方法和synchronized(this)等效，都是对当前对象进行加锁；而synchronized(非this对象X)则是对某个对象进行加锁，即<strong>对象监视器锁</strong>。</p><p>synchronized可以使多个线程访问同一个资源具有同步性，而且它还具有将线程工作内存中的私有变量与公共内存中的变量同步的功能，即<strong>具有volatile同步的功能</strong>。</p><p>synchronized包含两大特性：</p><ul><li>互斥性</li><li>可见性</li></ul><p>synchronized(非this对象X)格式的写法是将X对象本身作为<strong>对象监视器</strong>，这样就可以得出以下三个结论：</p><ol><li>当多个线程同时执行synchronized(X){} 同步代码块呈同步效果。</li><li>当其他线程执行X对象中synchronized同步方法时呈同步效果。</li><li>当其他线程执行X对象方法里面的synchronized(this)代码块时也呈现同步效果。</li></ol><blockquote><p>synchronized关键字加到static静态方法上是给Class类上锁，而synchronized关键字加到非static静态方法上是给对象上锁。</p><p>Class锁可以对类的所有对象实例起作用，即锁定所有对象锁。</p><p>同步synchronized(XX.class)代码块的作用和synchronized static方法的作用一样。</p></blockquote><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><blockquote><p>volatile关键字的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。</p></blockquote><p>synchronized和volatile区别：</p><ol><li>关键字volatile是线程同步的轻量级实现，所以volatile<strong>性能</strong>肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized关键字的比率还是比较大的。</li><li>多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。</li><li><strong>volatile可以保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，即保证多个线程之间访问资源的同步性</strong>，因为它会将私有内存和公共内存中的数据做同步。</li></ol><h2 id="等待-x2F-通知机制"><a href="#等待-x2F-通知机制" class="headerlink" title="等待&#x2F;通知机制"></a>等待&#x2F;通知机制</h2><ul><li>wait()方法可以使调用该方法的线程释放共享资源的锁，然后从运行状态退出，进入等待队列，直到被再次唤醒。</li><li>notify()方法可以随机唤醒等待队列中等待同一共享资源的一个线程，并使该线程退出等待队列，进入可运行状态，也就是notify()方法仅通知一个线程。</li><li>notifyAll()方法可以使所有正在等待队列中等待同一共享资源的全部线程从等待状态退出，进入可运行状态。此时，优先级最高的那个线程最先执行，但也有可能是随机执行，这要取决于JVM虚拟机的实现。</li></ul><p>用一句话来总结一下wait和notify：wait使线程停止运行，而notify使停止的线程继续运行，notify()方法执行后并不立即释放锁，而是等同步代码块&#x2F;同步方法中的逻辑执行完才释放。</p><blockquote><p>如果调用wait()没有适当的锁，则抛出IllegalMonitorStateException，它是RuntimeException的一个子类，因此，不需要try-catch语句进行捕捉异常。</p></blockquote><blockquote><p>当interrupt方法遇到wait方法后会抛出异常，锁也会释放，即在执行同步代码块的过程中，<strong>遇到异常而导致线程终止，锁也会被释放</strong>。</p></blockquote><p><strong>每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列</strong>。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。</p><h2 id="线程的6种状态及切换"><a href="#线程的6种状态及切换" class="headerlink" title="线程的6种状态及切换"></a>线程的6种状态及切换</h2><img src="/posts/71aa5641/9.jpg" srcset="/img/loading.gif" lazyload><h3 id="初始状态NEW"><a href="#初始状态NEW" class="headerlink" title="初始状态NEW"></a>初始状态<code>NEW</code></h3><p>实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。</p><h3 id="就绪状态RUNNABLE"><a href="#就绪状态RUNNABLE" class="headerlink" title="就绪状态RUNNABLE"></a>就绪状态<code>RUNNABLE</code></h3><img src="/posts/71aa5641/image-20200912223705497.png" srcset="/img/loading.gif" lazyload alt="image-20200912223705497" style="zoom:33%"><p>就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。</p><p>调用线程的start()方法，此线程进入就绪状态。</p><p>当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。</p><p>当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。</p><p>锁池里的线程拿到对象锁后，进入就绪状态。</p><p>线程进入Runnable状态大体分为如下5种情况：</p><ul><li><p>调用sleep()方法后经过的时间超过了指定的休眠时间。</p></li><li><p>线程调用的阻塞IO已经返回，阻塞方法执行完毕。</p></li><li><p>线程成功地获得了试图同步的监视器。</p></li><li><p>线程正在等待某个通知，其他线程发出了通知。</p></li><li><p>处于挂起状态的线程调用resume恢复方法。</p></li></ul><h3 id="运行中状态RUNNING"><a href="#运行中状态RUNNING" class="headerlink" title="运行中状态RUNNING"></a>运行中状态<code>RUNNING</code></h3><blockquote><p><code>getState()</code>并没有<code>RUNNING</code>状态，<code>RUNNING</code>和<code>RUNNABLE</code>是合并在一块的。</p></blockquote><p>线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。</p><h3 id="阻塞状态BLOCKED"><a href="#阻塞状态BLOCKED" class="headerlink" title="阻塞状态BLOCKED"></a>阻塞状态<code>BLOCKED</code></h3><p>阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态，Blocked状态结束后，进入Runnable状态，等待系统重新分配资源。</p><p>出现阻塞的情况大致分为如下5种：</p><ul><li><p>线程调用sleep方法，主动放弃占用的处理器资源。</p></li><li><p>线程调用了阻塞式IO方法，在该方法返回前，该线程被阻塞。</p></li><li><p>线程识图获得一个同步监视器，但该同步监视器正被其他线程所持有。</p></li><li><p>线程等待某个通知。</p></li><li><p>程序调用了suspend方法将该线程挂起。此方法容易导致死活，尽量避免使用该方法。</p></li></ul><h3 id="等待WAITING"><a href="#等待WAITING" class="headerlink" title="等待WAITING"></a>等待<code>WAITING</code></h3><blockquote><p>有可能被这些方法调用</p><ul><li><strong>Object.wait</strong></li><li>Thread.join</li><li>LockSupport.park</li></ul></blockquote><p>处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。</p><h3 id="超时等待TIMED-WAITING"><a href="#超时等待TIMED-WAITING" class="headerlink" title="超时等待TIMED_WAITING"></a>超时等待<code>TIMED_WAITING</code></h3><blockquote><p>有可能被这些方法调用</p><ul><li>Object.wait</li><li>Thread.join</li><li><strong>Thread.sleep</strong></li><li>LockSupport.parkNanos</li><li>LockSupport.parkUntil</li></ul></blockquote><p>处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。</p><h3 id="终止状态TERMINATED"><a href="#终止状态TERMINATED" class="headerlink" title="终止状态TERMINATED"></a>终止状态<code>TERMINATED</code></h3><p>当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。<br>在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。</p><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>join的作用是使所属的线程对象X正常执行run()方法中的任务，而使当前线程Z进行无限制的阻塞，等待线程X销毁后再继续执行线程Z后面的代码。</p><h2 id="join和synchronized的区别"><a href="#join和synchronized的区别" class="headerlink" title="join和synchronized的区别"></a>join和synchronized的区别</h2><p>join具有使线程排队运行的作用，有些类似同步的运行效果。join于synchronized的区别是：join在内部使用wait()方法进行等待，而synchronized关键字使用的是“对象监视器”原理作为同步。</p><h2 id="join-long-与sleep-long-的区别"><a href="#join-long-与sleep-long-的区别" class="headerlink" title="join(long)与sleep(long)的区别"></a>join(long)与sleep(long)的区别</h2><p>join(long)的功能在内部是使用wait(long)方法来实现的，所以join(long)方法具有释放锁的特点，而Thread.sleep(long)方法却不释放锁。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p>ThreadLocal设置初始化值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalExt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadLocal</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;设置初始化值&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>InheritableThreadLocal类可以让子线程从父线程中取得值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalExt</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">InheritableThreadLocal</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;设置初始化值&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">childValue</span><span class="hljs-params">(Object parentValue)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;子类值&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock功能上比synchronized关键字更加的强大，比如具有<strong>嗅探锁定、多路分支通知</strong>等功能，而且在使用上也比synchronized更加的灵活。</p><p>关键字synchronized于wait()和notify()&#x2F;notifyAll()方法相结合可以实现等待&#x2F;通知模式，类ReentrantLock也可以实现同样的功能，但需要借助于Condition对象，从而实现有选择性的线程通知。</p><p><strong>Condition等待&#x2F;通知方法和synchronized等待&#x2F;通知方法的区别</strong>：</p><ul><li>Object类中的wait()方法相当于Condition类中的await()方法。</li><li>Object类中的wait(long timeout)方法相当于Condition类中的await(long time, TimeUnit unit)方法。</li><li>Object类中的notify()方法相当于Condition类中的signal()方法。</li><li>Object类中的notifyAll()方法相当于Condition类中的signalAll()方法。</li></ul><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">conditionA</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">conditionB</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            conditionA.await();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll_A</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            lock.lock();<br>            conditionA.signalAll();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="公平锁于非公平锁"><a href="#公平锁于非公平锁" class="headerlink" title="公平锁于非公平锁"></a>公平锁于非公平锁</h3><p>公平与非公平锁：锁Lock分为“公平锁”和“非公平锁”，<strong>公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的</strong>，即先来先得的FIFO先进先出顺序。而<strong>非公平锁就是一种获取锁的抢占机制，是随机获得锁的</strong>，和公平锁不一样的就是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，结果也就是不公平的了。</p><p><strong>在默认的情况下，ReentrantLock类使用的是非公平锁。</strong></p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span> &#123;<br>    <span class="hljs-keyword">private</span> ReentrantLock lock;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Service</span><span class="hljs-params">(<span class="hljs-type">boolean</span> isFair)</span> &#123;<br>        <span class="hljs-built_in">super</span>();<br>        lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(isFair);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ReentrantLock对象方法"><a href="#ReentrantLock对象方法" class="headerlink" title="ReentrantLock对象方法"></a>ReentrantLock对象方法</h3><h4 id="getHoldCount"><a href="#getHoldCount" class="headerlink" title="getHoldCount"></a>getHoldCount</h4><blockquote><p><strong>int getHoldCount()的作用是查询当前线程保持此锁定的个数</strong>，也就是调用lock()方法的次数。</p></blockquote><h4 id="getQueueLength"><a href="#getQueueLength" class="headerlink" title="getQueueLength"></a>getQueueLength</h4><blockquote><p><strong>int getQueueLength()的作用是返回正等待获取此锁定的线程估计数</strong>，比如有5个线程，1个线程首先执行await()方法，那么在调用getQueue()方法后返回值是4，说明有4个线程同时在等待lock的释放。</p></blockquote><h4 id="getWaitQueueLength"><a href="#getWaitQueueLength" class="headerlink" title="getWaitQueueLength"></a>getWaitQueueLength</h4><blockquote><p><strong>int getWaitQueueLength(Condition condition)的作用是返回等待与此锁定相关的给定条件Conditin的线程估计数</strong>，比如有5个线程，每个线程都执行了同一个condition的await方法，则调用getWaitQueueLength(Condition condition)方法时返回的int值是5。</p></blockquote><h4 id="hasQueuedThread"><a href="#hasQueuedThread" class="headerlink" title="hasQueuedThread"></a>hasQueuedThread</h4><blockquote><p>boolean hasQueueThread(Thread thread)的作用是查询指定的线程是否正在等待获取此锁定。</p></blockquote><h4 id="hasQueuedThreads"><a href="#hasQueuedThreads" class="headerlink" title="hasQueuedThreads"></a>hasQueuedThreads</h4><blockquote><p>boolean hasQueueThreads()的作用是获取指定的锁是否有线程正在等待调用。</p></blockquote><h4 id="hasWaiters"><a href="#hasWaiters" class="headerlink" title="hasWaiters"></a>hasWaiters</h4><blockquote><p>boolean hasWaiters(Condition condition)的作用是查询是否有线程正在等待与此锁定有关的condition条件；getWaitQueueLength(Condition condition)可以获取到等待的线程的数量。</p></blockquote><h4 id="isFair"><a href="#isFair" class="headerlink" title="isFair"></a>isFair</h4><blockquote><p>boolean isFair()的作用是判断是不是公平锁。</p></blockquote><h4 id="isHeldByCurrentThread"><a href="#isHeldByCurrentThread" class="headerlink" title="isHeldByCurrentThread"></a>isHeldByCurrentThread</h4><blockquote><p>boolean isHeldByCurrentThread()的作用是查询当前线程是否保持此锁定。</p></blockquote><h4 id="isLocked"><a href="#isLocked" class="headerlink" title="isLocked"></a>isLocked</h4><blockquote><p>boolean isLocked()的作用是查询此锁定是否由任意线程保持。</p></blockquote><h4 id="lockInterruptibly"><a href="#lockInterruptibly" class="headerlink" title="lockInterruptibly"></a>lockInterruptibly</h4><blockquote><p>void lockInterruptibly()的作用是：如果当前线程未被中断，则获取锁定，如果已经被中断<strong>interrupt</strong>则出现异常。(对比lock()方法)</p></blockquote><h4 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock"></a>tryLock</h4><blockquote><p>boolean tryLock()的作用是，仅在调用时锁定未被另一个线程保持的情况下，才获取改锁定。</p><p>boolean tryLock(long timeout, TimeUnit unit)的作用是，如果锁定在给定等待时间内没有被另一个线程保持，且当前线程未被中断，则获取该锁定。</p></blockquote><h3 id="Condition对象方法"><a href="#Condition对象方法" class="headerlink" title="Condition对象方法"></a>Condition对象方法</h3><blockquote><p>使用好Condition对象可以对线程执行的业务进行排序规划（<strong>即利用主内存唯一变量做判断控制，如果不满足条件当当前线程停留在await状态</strong>）。</p></blockquote><h4 id="awaitUninterruptibly"><a href="#awaitUninterruptibly" class="headerlink" title="awaitUninterruptibly"></a>awaitUninterruptibly</h4><blockquote><p>void awaitUninterruptibly()的作用是等待时忽略中断，不至于类似于await()那样被中断后会抛出异常。</p></blockquote><h4 id="awaitUntil"><a href="#awaitUntil" class="headerlink" title="awaitUntil"></a>awaitUntil</h4><blockquote><p>boolean awaitUntil(Date deadline)的作用是：等待到特定日期，而且<strong>线程在等待时间到达之前，可以被其他线程唤醒</strong>。</p></blockquote><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>类ReentrantLock具有完全互斥排他的效果，即同一时间只有一个线程在执行ReentrantLock()方法后面的任务。这样做虽然保证了实例变量的线程安全性，但效率是非常低下的。所以在JDK中提供了一种读写锁ReentrantReadWriteLock类，使用他可以加快运行效率，在某些不需要操作实例的变量中，完全可以使用读写锁ReentrantReadWriteLock来提升该方法的代码运行速度。</p><p>读写锁表示也有两个锁，一个是读操作相关的锁，也成为共享锁；另一个是写操作相关的锁，也叫排它锁。也就是多个读锁之间不互斥，读锁和写锁互斥、写锁和写锁互斥。在没有线程Thread进行写入操作时，进行读取操作的多个Thread都可以获取读锁，而进行写入操作的Thread只有在获取写锁之后才能进行写入操作。<strong>即多个Thread可以同时进行读取操作，但是同一时刻只允许一个Thread进行写入操作</strong>；体现在读读共享，写写互斥，读写互斥，写读互斥。</p><h2 id="定时器Timer"><a href="#定时器Timer" class="headerlink" title="定时器Timer"></a>定时器Timer</h2><p>在JDK库中，Timer类主要负责计划任务的功能，也就是在指定的时间开始执行某一个任务；抽象类为TimerTask。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Timer</span> <span class="hljs-variable">timer1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(); <span class="hljs-comment">//非守护线程</span><br><span class="hljs-type">Timer</span> <span class="hljs-variable">timer2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 守护线程</span><br></code></pre></td></tr></table></figure><p>Timmer执行定时任务如果计划时间早于当前时间，则会提前执行task任务。</p><blockquote><p>TimmerTask是以队列的方式一个一个被顺序的执行，所以执行的时间有可能和预期的时间不一致，因为前面的任务有可能消耗的时间较长，则后面的任务运行的时间也被延后。</p></blockquote><h3 id="cancel"><a href="#cancel" class="headerlink" title="cancel"></a>cancel</h3><blockquote><p>Timer类的<strong>cancel()方法有时不一定会停止计划任务，而是正常执行</strong>，原因是Timer类中的cancel()方法有时并没有争抢到queue锁，而让TimerTask类中的任务正常执行。</p></blockquote><ul><li><p><strong>TimerTask类的cancel()方法</strong></p><p>TimerTask类的cancel()方法的作用是讲自身从任务队列中进行清除。</p></li><li><p><strong>Timer类的cancel()方法</strong></p><p>和TimerTask类中的cancel方法()清除自身不同，Timer类中的cancel()方法是将自身队列中全部的任务进行清空。</p></li></ul><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><ul><li><p><strong>schedule(TimerTask task, Date firstTime, long period)</strong></p><p>该方法的作用是在指定的日期之后按指定的间隔周期，无限循环地执行某一任务。</p></li><li><p><strong>schedule(TimerTask task, long delay, long period)</strong></p><p>该方法的作用是以执行schedule(TimerTask task, long delay, long period)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数，再以某一间隔时间无限次数地执行某一任务。</p></li></ul><h3 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h3><ul><li><p><strong>scheduleAtFixedRate(TimerTask task, Date firstTime, long period)</strong></p><p>该方法的作用是在指定的日期之后按指定的间隔周期，无限循环地执行某一任务，同schedule的区别在于有没有<strong>追赶性</strong>。</p></li><li><p><strong>scheduleAtFixedRate(TimerTask task, long delay, long period)</strong></p><p>该方法的作用是以执行scheduleAtFixedRate(TimerTask task, long delay, long period)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数，再以某一间隔时间无限次数地执行某一任务。</p></li></ul><h3 id="追赶性"><a href="#追赶性" class="headerlink" title="追赶性"></a>追赶性</h3><p>如果定时任务计划的时间早于当前时间，schedule方法在提前时间段区间之间的所对应的Task任务就被取消掉，不被执行了，这就是Task任务不追赶；而scheduleAtFixedRate方法在提前时间段区间之间的所对应的Task任务就被“补充性”地执行，直到提前时间区间段的时间区间补充执行完毕，这就是Task任务追赶特性。</p><h2 id="单例模式与多线程"><a href="#单例模式与多线程" class="headerlink" title="单例模式与多线程"></a>单例模式与多线程</h2><h3 id="俄汉模式、懒汉模式"><a href="#俄汉模式、懒汉模式" class="headerlink" title="俄汉模式、懒汉模式"></a>俄汉模式、懒汉模式</h3><h4 id="立即加载-x2F-饿汉模式"><a href="#立即加载-x2F-饿汉模式" class="headerlink" title="立即加载&#x2F;饿汉模式"></a>立即加载&#x2F;饿汉模式</h4><p>什么是立即加载？立即加载就是使用类的时候已经将对象创建完毕，常见的实现方法就是直接new实例化。而立即加载从中文的语境来看，有“着急”、“急迫”的含义，所以也称为“饿汉模式”。</p><h4 id="延迟加载-x2F-懒汉模式"><a href="#延迟加载-x2F-懒汉模式" class="headerlink" title="延迟加载&#x2F;懒汉模式"></a>延迟加载&#x2F;懒汉模式</h4><p>什么是延迟加载？延迟加载就是在调用get()方法时实例才被创建，常见的实现办法就是在get()方法中进行实例化。而延迟加载从中文的语境来看，是“缓慢”、“不急迫”的含义，所以也称为“懒汉模式”。</p><p>饿汉模式应用于多线程会产生很大的性能问题，推荐多线程一般都用的懒汉模式，大概分为以下几种：</p><h3 id="DCL双检查-机制"><a href="#DCL双检查-机制" class="headerlink" title="DCL双检查 机制"></a>DCL双检查 机制</h3><p>DCL双检查机制就是在同步代码块调用之前检查一遍，再在同步代码块内部再检查一遍，即使用volatile保证主内存变量一致，同时对逻辑代码块进行加锁，作为一种双重保险的保障。</p><p>实例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> MyObject myObject;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObject</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 使用双检查机制来解决问题，既保证了不需要同步代码的异步执行型</span><br>    <span class="hljs-comment">// 又保证了单例的效果</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyObject <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (myObject != <span class="hljs-literal">null</span>) &#123;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 模拟在创建对象之前做一些准备性的工作</span><br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>                <span class="hljs-keyword">synchronized</span> (MyObject.class) &#123;<br>                    <span class="hljs-keyword">if</span> (myObject == <span class="hljs-literal">null</span>) &#123;<br>                        myObject = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> myObject;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用静态内置类"><a href="#使用静态内置类" class="headerlink" title="使用静态内置类"></a>使用静态内置类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;<br>    <span class="hljs-comment">// 内部类方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObjectHandler</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MyObject</span> <span class="hljs-variable">myOjbect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObject</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyObject <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MyObjectHandler.myOjbect;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="序列化与反序列化的单例模式"><a href="#序列化与反序列化的单例模式" class="headerlink" title="序列化与反序列化的单例模式"></a>序列化与反序列化的单例模式</h3><blockquote><p>readResolve()的实现是关键所在，可以从ObjectInputStream中的readObject进行延伸，代码如下所示：</p></blockquote><img src="/posts/71aa5641/10.png" srcset="/img/loading.gif" lazyload alt="image-20200624193252720" style="zoom:50%"><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">4037244617173811007L</span>;<br><br>    <span class="hljs-comment">// 内部类方式</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObjectHandler</span> &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">MyObject</span> <span class="hljs-variable">myOjbect</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObject</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyObject <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MyObjectHandler.myOjbect;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">readResolve</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了readResolve方法！ &quot;</span>);<br>        <span class="hljs-keyword">return</span> MyObjectHandler.myOjbect;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SaveAndRead</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> MyObject.getInstance();<br>            <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fosRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;myObjectFile.txt&quot;</span>));<br>            <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oosRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fosRef);<br>            oosRef.writeObject(myObject);<br>            oosRef.close();<br>            fosRef.close();<br>            System.out.println(myObject.hashCode());<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fisRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;myObjectFile.txt&quot;</span>));<br>            <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">iosRef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fisRef);<br>            <span class="hljs-type">MyObject</span> <span class="hljs-variable">myObject</span> <span class="hljs-operator">=</span> (MyObject)iosRef.readObject();<br>            iosRef.close();<br>            fisRef.close();<br>            System.out.println(myObject.hashCode());<br>        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用static代码块实现单例模式"><a href="#使用static代码块实现单例模式" class="headerlink" title="使用static代码块实现单例模式"></a>使用static代码块实现单例模式</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyObject</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> MyObject instance;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyObject</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyObject</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyObject <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用enum枚举数据类型实现单例模式"><a href="#使用enum枚举数据类型实现单例模式" class="headerlink" title="使用enum枚举数据类型实现单例模式"></a>使用enum枚举数据类型实现单例模式</h3><p>枚举enum和静态代码块的特性相似，在使用枚举类时，构造方法会被自动调用。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">MyObject</span> &#123;<br>    connectionFactory;<br>    <span class="hljs-keyword">private</span> Connection connection;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyEnumSingleTon</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;调用了MyObject的构造 &quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:sqlserver://localhost:1079;databaseName=ghydb&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sa&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">driverName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;</span>;<br>            Class.forName(driverName);<br>            connection = DriverManager.getConnection(url, username, password);<br>        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> MyEnumSingleTon.connectionFactory.getConnection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程组"><a href="#线程组" class="headerlink" title="线程组"></a>线程组</h2><p>可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程。</p><p>线程组的作用是：可以批量的管理线程或线程组对象，有效地对线程或线程组对象进行组织。</p><blockquote><p><strong>线程组拥有自动归属特性，即自动归到当前线程组中。</strong></p><p>优先：通过将线程归属到线程组中，当调用线程组<code>ThreadGroup的interrupt()</code>方法时，可以将该组中的所有正在运行的线程批量停止。</p></blockquote><h3 id="一级关联"><a href="#一级关联" class="headerlink" title="一级关联"></a>一级关联</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(<span class="hljs-string">&quot;姚煜明的线程组&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="多级关联"><a href="#多级关联" class="headerlink" title="多级关联"></a>多级关联</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">mainGroup</span> <span class="hljs-operator">=</span> Thread.currentThread().getThreadGroup();<br><span class="hljs-type">ThreadGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>(mainGroup, <span class="hljs-string">&quot;A&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="递归与非递归取得组内对象"><a href="#递归与非递归取得组内对象" class="headerlink" title="递归与非递归取得组内对象"></a>递归与非递归取得组内对象</h3><blockquote><p>默认是递归获取。</p></blockquote><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ThreadGroup[] listGroup1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>[Thread.currentThread().activeCount()];<br>Thread.currentThread().getThreadGroup().enumerate(listGroup1, <span class="hljs-literal">true</span>);<br><br>ThreadGroup[] listGroup2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadGroup</span>[Thread.currentThread().activeCount()];<br>Thread.currentThread().getThreadGroup().enumerate(listGroup2, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><h2 id="线程出现异常的处理"><a href="#线程出现异常的处理" class="headerlink" title="线程出现异常的处理"></a>线程出现异常的处理</h2><h3 id="setUncaughtExceptionHandler方法"><a href="#setUncaughtExceptionHandler方法" class="headerlink" title="setUncaughtExceptionHandler方法"></a>setUncaughtExceptionHandler方法</h3><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadA</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadA</span>();<br>t1.setName(<span class="hljs-string">&quot;线程T1&quot;</span>);<br>t1.setUncaughtExceptionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>.UncaughtExceptionHandler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;线程：&quot;</span> + t.getName() + <span class="hljs-string">&quot; 出现了异常： &quot;</span>);<br>        e.printStackTrace();<br>    &#125;<br>&#125;);<br>t1.start();<br></code></pre></td></tr></table></figure><blockquote><p>在默认的情况下，线程组的一个线程出现异常不会影响其他线程的运行。</p><p>如果想出现异常停止所有的线程，<strong>前提必须调用父类的<code>uncaughtException(t, e)</code>方法，</strong>可以如下操作：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadGroup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadGroup</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyThreadGroup</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">super</span>(name);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">uncaughtException</span><span class="hljs-params">(Thread t, Throwable e)</span> &#123;<br>        <span class="hljs-built_in">super</span>.uncaughtException(t, e);<br>        <span class="hljs-built_in">this</span>.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Executor和ExexcutorService"><a href="#Executor和ExexcutorService" class="headerlink" title="Executor和ExexcutorService"></a>Executor和ExexcutorService</h2><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>Executor</td><td>提供了用于执行Runnable对象的execute方法的接口</td></tr><tr><td>ExecutorService</td><td>提供了用于关闭自己的shutdown方法的Executor接口</td></tr><tr><td>ScheduledExecutorService</td><td>在一定时间后或周期性地执行提交上来的命令的ExecutorService的接口</td></tr><tr><td>AbstractExecutorService</td><td>ExecutorService的默认实现类</td></tr><tr><td>ThreadPoolExecutor</td><td>使用了线程池的ExecutorService的实现类</td></tr><tr><td>ScheduledThreadPoolExecutor</td><td>ScheduledExecutorService的典型的实现类</td></tr></tbody></table><h2 id="Future-和-FutureTask"><a href="#Future-和-FutureTask" class="headerlink" title="Future 和 FutureTask"></a>Future 和 FutureTask</h2><p><code>java.util.concurrent.Future</code>是表示异步处理的执行结果的接口。该接口的主要实现是FutureTask类。</p><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>Future&lt;V&gt;</td><td>表示异步处理的结果的接口，该接口是ExecutorService的返回值</td></tr><tr><td>ScheduledFuture</td><td>ScheduledExecutorService的处理结果</td></tr><tr><td>FutureTask&lt;V&gt;</td><td>可以调用Runnable对象的run方法或是Callable对象的call方法的任务。该类是Future接口的典型的实现类</td></tr><tr><td>CompletionService&lt;V&gt;</td><td>将异步任务的创建与使用任务处理结果分离的任务</td></tr><tr><td>ExecutorCompletionService&lt;V&gt;</td><td>面向Executor的CompletionService</td></tr></tbody></table><img src="/posts/71aa5641/84.png" srcset="/img/loading.gif" lazyload alt="111111" style="zoom:67%"><h2 id="java-util-concurrent-locks-包"><a href="#java-util-concurrent-locks-包" class="headerlink" title="java.util.concurrent.locks 包"></a>java.util.concurrent.locks 包</h2><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>Lock</td><td>可以创建出与synchronized的锁具有不同结构的锁的接口</td></tr><tr><td>ReadWriteLock</td><td>用于创建Read-Write Lock的接口</td></tr><tr><td>ReentrantLock</td><td>可以被多次获取的互斥锁</td></tr><tr><td>ReentrantReadWriteLock</td><td>具有与ReentrantLock类似功能的ReadWriteLock的实现类</td></tr><tr><td>ReentrantReadWriteLock.ReadLock</td><td>通过ReentrantReadWriteLock.readLock方法获取的Lock对象</td></tr><tr><td>ReentrantReadWriteLock</td><td>通过ReentrantReadWriteLock.writeLock方法获取的Lock对象</td></tr><tr><td>Condition</td><td>用于与Lock组合使用，创建线程的等待队列的接口</td></tr><tr><td>AbstractQueueSynchronizer</td><td>用于创建一个以FIFO方式让线程等待的队列的框架</td></tr><tr><td>LockSupport</td><td>制作锁和同步机制的基本原语</td></tr></tbody></table><h2 id="java-util-concurrent-atomic-包"><a href="#java-util-concurrent-atomic-包" class="headerlink" title="java.util.concurrent.atomic 包"></a>java.util.concurrent.atomic 包</h2><table><thead><tr><th>名字</th><th>内容</th></tr></thead><tbody><tr><td>AtomicBoolean</td><td>以原子方式操作的boolean类型的变量</td></tr><tr><td>AtomicInteger</td><td>以原子方式操作的int类型的变量</td></tr><tr><td>AtomicLong</td><td>以原子方式操作的long类型的变量</td></tr><tr><td>AtomicReference&lt;V&gt;</td><td>以原子方式操作的对象引用类型的变量</td></tr><tr><td>AtomicIntegerFieldUpdater&lt;T&gt;</td><td>以原子方式操作的int类型的字段</td></tr><tr><td>AtomicLongFieldUpdater&lt;T&gt;</td><td>以原子方式操作的long类型的字段</td></tr><tr><td>AtomicReferenceFieldUpdater&lt;T&gt;</td><td>以原子方式操作的引用类型的字段</td></tr><tr><td>AtomicIntegerArray</td><td>以原子方式操作的int类型的数组</td></tr><tr><td>AtomicLongArray</td><td>以原子方式操作的long类型的数组</td></tr><tr><td>AtomicReferenceArray&lt;E&gt;</td><td>以原子方式操作的对象引用类型的数组</td></tr><tr><td>AtomicMarkableReference&lt;E&gt;</td><td>以原子方式操作的带有标记的对象引用</td></tr><tr><td>AtomicStampedReference&lt;V&gt;</td><td>以原子方式操作的带有时间戳的对象引用</td></tr></tbody></table><h2 id="setDaemon-true"><a href="#setDaemon-true" class="headerlink" title="setDaemon(true)"></a>setDaemon(true)</h2><p>垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是JVM上仅剩的线程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统中的可回收资源。</p><p>生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依赖于系统，与系统“同生共死”。那Java的守护线程是什么样子的呢。当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则JVM不会退出。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Java/" class="category-chain-item">Java</a> <span>></span> <a href="/categories/Java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="category-chain-item">多线程</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">#多线程</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/e1434ae1/" title="HTTP 状态码"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">HTTP 状态码</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/7c42c21b/" title="JVM 指令大全"><span class="hidden-mobile">JVM 指令大全</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>