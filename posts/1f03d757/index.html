<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yahya"><meta name="keywords" content=""><meta name="description" content="基础1、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。 2、抽象类必须要有抽象方法吗？不需要，抽象类不一定非要有抽象方法，以下为示"><meta property="og:type" content="article"><meta property="og:title" content="面试单题"><meta property="og:url" content="https://blog.yahyav2rayssr.top/posts/1f03d757/index.html"><meta property="og:site_name" content="yahya的博客"><meta property="og:description" content="基础1、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。 2、抽象类必须要有抽象方法吗？不需要，抽象类不一定非要有抽象方法，以下为示"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/40.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/41.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/42.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/108.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/101.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/102.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/107.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/103.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/105.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/106.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/110.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/111.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/194.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/112.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/113.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/114.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/115.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/116.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/117.jpg"><meta property="article:published_time" content="2023-04-16T03:08:32.835Z"><meta property="article:modified_time" content="2023-04-16T03:08:32.836Z"><meta property="article:author" content="Yahya"><meta property="article:tag" content="面试"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog.yahyav2rayssr.top/posts/1f03d757/40.png"><title>面试单题 - yahya的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"blog.yahyav2rayssr.top",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!1,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!1,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:6},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="yahya的博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yahya的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="面试单题"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-16 11:08" pubdate>2023年4月16日 上午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 55k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 456 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">面试单题</h1><p class="note note-info">本文最后更新于：2023年4月16日 上午</p><div class="markdown-body"><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1、String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗"><a href="#1、String-str-x3D-”i”与-String-str-x3D-new-String-“i”-一样吗" class="headerlink" title="1、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗"></a>1、String str&#x3D;”i”与 String str&#x3D;new String(“i”)一样吗</h2><p>不一样，因为内存的分配方式不一样。String str&#x3D;”i”的方式，java 虚拟机会将其分配到常量池中；而 String str&#x3D;new String(“i”) 则会被分到堆内存中。</p><h2 id="2、抽象类必须要有抽象方法吗？"><a href="#2、抽象类必须要有抽象方法吗？" class="headerlink" title="2、抽象类必须要有抽象方法吗？"></a><strong>2、抽象类必须要有抽象方法吗？</strong></h2><p>不需要，抽象类不一定非要有抽象方法，以下为示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;hi~&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3、抽象类能使用-final-修饰吗"><a href="#3、抽象类能使用-final-修饰吗" class="headerlink" title="3、抽象类能使用 final 修饰吗"></a><strong>3、抽象类能使用 final 修饰吗</strong></h2><p>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类。</p><h2 id="4、接口和抽象类的区别"><a href="#4、接口和抽象类的区别" class="headerlink" title="4、接口和抽象类的区别"></a><strong>4、接口和抽象类的区别</strong></h2><table><thead><tr><th align="left"></th><th>接口</th><th>抽象类</th></tr></thead><tbody><tr><td align="left">实现</td><td>接口必须使用 implements 来实现接口</td><td>抽象类的子类使用 extends 来继承</td></tr><tr><td align="left">构造函数</td><td>无</td><td>可以有</td></tr><tr><td align="left">main 方法</td><td>无</td><td>可以有</td></tr><tr><td align="left">实现数量</td><td>多个</td><td>单个</td></tr><tr><td align="left">访问修饰符</td><td>方法默认public修饰</td><td>方法可以是任意访问修饰符（除了private）</td></tr></tbody></table><h2 id="5、java-中-IO-流分为几种"><a href="#5、java-中-IO-流分为几种" class="headerlink" title="5、java 中 IO 流分为几种"></a><strong>5、java 中 IO 流分为几种</strong></h2><p>按功能来分：输入流（input）、输出流（output）。</p><p>按类型来分：字节流和字符流。</p><p>字节流和字符流的区别是：字节流按 8 位传输以字节为单位输入输出数据，字符流按 16 位传输以字符为单位输入输出数据。</p><h2 id="6、BIO、NIO、AIO-有什么区别"><a href="#6、BIO、NIO、AIO-有什么区别" class="headerlink" title="6、BIO、NIO、AIO 有什么区别"></a><strong>6、BIO、NIO、AIO 有什么区别</strong></h2><ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：New IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul><h2 id="7、Files的常用方法都有哪些？"><a href="#7、Files的常用方法都有哪些？" class="headerlink" title="7、Files的常用方法都有哪些？"></a>7、Files的常用方法都有哪些？</h2><ul><li>Files.exists()：检测文件路径是否存在。</li><li>Files.createFile()：创建文件。</li><li>Files.createDirectory()：创建文件夹。</li><li>Files.delete()：删除一个文件或目录。</li><li>Files.copy()：复制文件。</li><li>Files.move()：移动文件。</li><li>Files.size()：查看文件个数。</li><li>Files.read()：读取文件。</li><li>Files.write()：写入文件。</li></ul><h1 id="容器"><a href="#容器" class="headerlink" title="容器"></a><strong>容器</strong></h1><h2 id="1、java容器都有哪些"><a href="#1、java容器都有哪些" class="headerlink" title="1、java容器都有哪些"></a><strong>1、java容器都有哪些</strong></h2><img src="/posts/1f03d757/40.png" srcset="/img/loading.gif" lazyload><h2 id="2、Collection-和-Collections-有什么区别"><a href="#2、Collection-和-Collections-有什么区别" class="headerlink" title="2、Collection 和 Collections 有什么区别"></a><strong>2、Collection 和 Collections 有什么区别</strong></h2><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类&#x2F;帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h2 id="3、List、Set、Map-之间的区别是什么"><a href="#3、List、Set、Map-之间的区别是什么" class="headerlink" title="3、List、Set、Map 之间的区别是什么"></a><strong>3、List、Set、Map 之间的区别是什么</strong></h2><img src="/posts/1f03d757/41.png" srcset="/img/loading.gif" lazyload><h2 id="4、HashMap-和-Hashtable-有什么区别"><a href="#4、HashMap-和-Hashtable-有什么区别" class="headerlink" title="4、HashMap 和 Hashtable 有什么区别"></a><strong>4、HashMap 和 Hashtable 有什么区别</strong></h2><ul><li>hashMap去掉了HashTable 的contains方法，但是保留了containsValue()和containsKey()方法。</li><li>hashTable同步的，而HashMap是非同步的，效率上比hashTable要高。</li><li>hashMap允许空键值，而hashTable不允许。</li></ul><h2 id="5、HashMap-LinkedHashMap-TreeMap的区别"><a href="#5、HashMap-LinkedHashMap-TreeMap的区别" class="headerlink" title="5、HashMap,LinkedHashMap,TreeMap的区别"></a>5、HashMap,LinkedHashMap,TreeMap的区别</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul><li>Map主要用于存储健值对，根据键得到值，因此不允许键重复,但允许值重复。</li><li>Hashmap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。</li><li>HashMap最多只允许一条记录的键为Null，允许多条记录的值为 Null。</li><li>HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。</li></ul><h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>LinkedHashMap是HashMap子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。</p><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator 遍历TreeMap时，得到的记录是排过序的。</p><h2 id="6、HashMap底层实现原理"><a href="#6、HashMap底层实现原理" class="headerlink" title="6、HashMap底层实现原理"></a>6、HashMap底层实现原理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><h3 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h3><p>HashMap实际是一种“数组+链表”数据结构。在put操作中，通过内部定义算法寻止找到数组下标，将数据直接放入此数组元素中，若通过算法得到的该数组元素已经有了元素（俗称hash冲突，链表结构出现的实际意义也就是为了解决hash冲突的问题）。将会把这个数组元素上的链表进行遍历，将新的数据放到链表末尾。</p><img src="/posts/1f03d757/42.jpg" srcset="/img/loading.gif" lazyload><p>当我们往Hashmap中put元素时，首先根据key的hashcode重新计算hash值，根绝hash值得到这个元素在数组中的位置(下标)，如果该数组在该位置上已经存放了其他元素，那么在这个位置上的元素将以链表的形式存放，新加入的放在链头，最先加入的放入链尾。如果数组中该位置没有元素，就直接将该元素放到数组的该位置上。</p><blockquote><p>需要注意Jdk 1.8中对HashMap的实现做了优化,当链表中的节点数据超过八个之后,该链表会转为红黑树来提高查询效率,从原来的O(n)到O(logn)</p></blockquote><h2 id="7、HashSet-的实现原理"><a href="#7、HashSet-的实现原理" class="headerlink" title="7、HashSet 的实现原理"></a><strong>7、HashSet 的实现原理</strong></h2><ul><li>HashSet底层由HashMap实现</li><li>HashSet的值存放于HashMap的key上</li><li>HashMap的value统一为PRESENT</li></ul><h2 id="8、Array-和-ArrayList-有何区别？"><a href="#8、Array-和-ArrayList-有何区别？" class="headerlink" title="8、Array 和 ArrayList 有何区别？"></a>8、Array 和 ArrayList 有何区别？</h2><ul><li>Array可以容纳基本类型和对象，而ArrayList只能容纳对象。</li><li>Array是指定大小的，而ArrayList大小是固定的。</li><li>Array没有提供ArrayList那么多功能，比如addAll、removeAll和iterator等。</li></ul><h2 id="9、在-Queue-中-poll-和-remove-有什么区别？"><a href="#9、在-Queue-中-poll-和-remove-有什么区别？" class="headerlink" title="9、在 Queue 中 poll()和 remove()有什么区别？"></a><strong>9、在 Queue 中 poll()和 remove()有什么区别？</strong></h2><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p><h2 id="10、Iterator-和-ListIterator-有什么区别？"><a href="#10、Iterator-和-ListIterator-有什么区别？" class="headerlink" title="10、Iterator 和 ListIterator 有什么区别？"></a>10、Iterator 和 ListIterator 有什么区别？</h2><ul><li>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。</li><li>Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。</li><li>ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</li></ul><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><h2 id="1、线程池中-submit-和-execute-方法有什么区别？"><a href="#1、线程池中-submit-和-execute-方法有什么区别？" class="headerlink" title="1、线程池中 submit()和 execute()方法有什么区别？"></a><strong>1、线程池中 submit()和 execute()方法有什么区别？</strong></h2><ul><li>接收的参数不一样</li><li>submit有返回值，而execute没有</li><li>submit方便Exception处理</li></ul><h2 id="2、在-java-程序中怎么保证多线程的运行安全？"><a href="#2、在-java-程序中怎么保证多线程的运行安全？" class="headerlink" title="2、在 java 程序中怎么保证多线程的运行安全？"></a>2、在 java 程序中怎么保证多线程的运行安全？</h2><p>线程安全在三个方面体现：</p><ul><li>原子性：提供互斥访问，同一时刻只能有一个线程对数据进行操作，（atomic,synchronized）</li><li>可见性：一个线程对主内存的修改可以及时地被其他线程看到，（synchronized,volatile）</li><li>有序性：一个线程观察其他线程中的指令执行顺序，由于指令重排序，该观察结果一般杂乱无序，（happens-before原则）</li></ul><h2 id="3、什么是死锁？"><a href="#3、什么是死锁？" class="headerlink" title="3、什么是死锁？"></a>3、什么是死锁？</h2><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。是操作系统层面的一个错误，是进程死锁的简称，最早在 1965 年由 Dijkstra 在研究银行家算法时提出的，它是计算机操作系统乃至整个并发程序设计领域最难处理的问题之一。</p><h3 id="怎么防止死锁？"><a href="#怎么防止死锁？" class="headerlink" title="怎么防止死锁？"></a><strong>怎么防止死锁？</strong></h3><p>死锁的四个必要条件：</p><ul><li>互斥条件：进程对所分配到的资源不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至占有该资源的进程使用完成后释放该资源</li><li>请求和保持条件：进程获得一定的资源之后，又对其他资源发出请求，但是该资源可能被其他进程占有，此事请求阻塞，但又对自己获得的资源保持不放</li><li>不可剥夺条件：是指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</li><li>环路等待条件：是指进程发生死锁后，若干进程之间形成一种头尾相接的循环等待资源关系</li></ul><p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之 一不满足，就不会发生死锁。</p><p>理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和 解除死锁。</p><p>所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确 定资源的合理分配算法，避免进程永久占据系统资源。</p><p>此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p><h2 id="4、synchronized-和-volatile-的区别是什么？"><a href="#4、synchronized-和-volatile-的区别是什么？" class="headerlink" title="4、synchronized 和 volatile 的区别是什么？"></a>4、synchronized 和 volatile 的区别是什么？</h2><ul><li>volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li><li>volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的。</li><li>volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性。</li><li>volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。</li><li>volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化。</li></ul><h2 id="5、synchronized-和-Lock-有什么区别？"><a href="#5、synchronized-和-Lock-有什么区别？" class="headerlink" title="5、synchronized 和 Lock 有什么区别？"></a>5、synchronized 和 Lock 有什么区别？</h2><ul><li>首先synchronized是java内置关键字，在jvm层面，Lock是个java类；</li><li>synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；</li><li>synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；</li><li>用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；</li><li>synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）；</li><li>Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。</li></ul><h2 id="6、synchronized-和-ReentrantLock-区别是什么？"><a href="#6、synchronized-和-ReentrantLock-区别是什么？" class="headerlink" title="6、synchronized 和 ReentrantLock 区别是什么？"></a>6、synchronized 和 ReentrantLock 区别是什么？</h2><p>synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上：</p><ul><li>ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁</li><li>ReentrantLock可以获取各种锁的信息</li><li>ReentrantLock可以灵活地实现多路通知</li></ul><p>另外，二者的锁机制其实也是不一样的：<strong>ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word</strong>。</p><h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="1、什么是反射？"><a href="#1、什么是反射？" class="headerlink" title="1、什么是反射？"></a>1、什么是反射？</h2><p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力</p><p>Java反射：</p><p>在Java运行时环境中，对于任意一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法</p><p>Java反射机制主要提供了以下功能：</p><ul><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时调用任意一个对象的方法。</li></ul><h2 id="2、什么是-java-序列化？什么情况下需要序列化？"><a href="#2、什么是-java-序列化？什么情况下需要序列化？" class="headerlink" title="2、什么是 java 序列化？什么情况下需要序列化？"></a>2、什么是 java 序列化？什么情况下需要序列化？</h2><p>简单说就是为了保存在内存中的各种对象的状态（也就是实例变量，不是方法），并且可以把保存的对象状态再读出来。虽然你可以用你自己的各种各样的方法来保存object states，但是Java给你提供一种应该比你自己好的保存对象状态的机制，那就是序列化。</p><p>什么情况下需要序列化：</p><ol><li>当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；</li><li>当你想用套接字在网络上传送对象的时候；</li><li>当你想通过RMI传输对象的时候；</li></ol><h2 id="3、动态代理是什么？有哪些应用？"><a href="#3、动态代理是什么？有哪些应用？" class="headerlink" title="3、动态代理是什么？有哪些应用？"></a>3、动态代理是什么？有哪些应用？</h2><p>动态代理：</p><p>当想要给实现了某个接口的类中的方法，加一些额外的处理。比如说加日志，加事务等。可以给这个类创建一个代理，故名思议就是创建一个新的类，这个类不仅包含原来类方法的功能，而且还在原来的基础上添加了额外处理的新类。这个代理类并不是定义好的，是动态生成的。具有解耦意义，灵活，扩展性强。</p><p>动态代理的应用：</p><ul><li>Spring的AOP</li><li>加事务</li><li>加权限</li><li>加日志</li></ul><h2 id="4、JDK和CGLIB动态代理原理"><a href="#4、JDK和CGLIB动态代理原理" class="headerlink" title="4、JDK和CGLIB动态代理原理"></a>4、JDK和CGLIB动态代理原理</h2><img src="/posts/1f03d757/108.png" srcset="/img/loading.gif" lazyload><h3 id="1、JDK动态代理"><a href="#1、JDK动态代理" class="headerlink" title="1、JDK动态代理"></a>1、JDK动态代理</h3><p>利用拦截器(拦截器必须实现InvocationHanlder)加上反射机制生成一个实现代理接口的匿名类，</p><p>在调用具体方法前调用InvokeHandler来处理。</p><h3 id="2、CGLIB动态代理"><a href="#2、CGLIB动态代理" class="headerlink" title="2、CGLIB动态代理"></a>2、CGLIB动态代理</h3><p>利用ASM开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</p><h3 id="3、何时使用JDK还是CGLIB？"><a href="#3、何时使用JDK还是CGLIB？" class="headerlink" title="3、何时使用JDK还是CGLIB？"></a>3、何时使用JDK还是CGLIB？</h3><ol><li>如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP。</li><li>如果目标对象实现了接口，可以强制使用CGLIB实现AOP。</li><li>如果目标对象没有实现了接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换。</li></ol><h3 id="4、如何强制使用CGLIB实现AOP？"><a href="#4、如何强制使用CGLIB实现AOP？" class="headerlink" title="4、如何强制使用CGLIB实现AOP？"></a>4、如何强制使用CGLIB实现AOP？</h3><ol><li>添加CGLIB库(aspectjrt-xxx.jar、aspectjweaver-xxx.jar、cglib-nodep-xxx.jar)</li><li>在Spring配置文件中加入&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;”true”&#x2F;&gt;</li></ol><h3 id="5、JDK动态代理和CGLIB字节码生成的区别？"><a href="#5、JDK动态代理和CGLIB字节码生成的区别？" class="headerlink" title="5、JDK动态代理和CGLIB字节码生成的区别？"></a>5、JDK动态代理和CGLIB字节码生成的区别？</h3><ol><li>JDK动态代理只能对实现了接口的类生成代理，而不能针对类。</li><li>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成final，对于final类或方法，是无法继承的。</li></ol><h3 id="6、CGlib比JDK快？"><a href="#6、CGlib比JDK快？" class="headerlink" title="6、CGlib比JDK快？"></a>6、CGlib比JDK快？</h3><ol><li>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理，因为CGLib原理是动态生成被代理类的子类。</li><li>在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率，只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。</li></ol><h3 id="7、Spring如何选择用JDK还是CGLIB？"><a href="#7、Spring如何选择用JDK还是CGLIB？" class="headerlink" title="7、Spring如何选择用JDK还是CGLIB？"></a>7、Spring如何选择用JDK还是CGLIB？</h3><ol><li>当Bean实现接口时，Spring就会用JDK的动态代理。</li><li>当Bean没有实现接口时，Spring使用CGlib是实现。</li><li>可以强制使用CGlib（在spring配置中加入&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;”true”&#x2F;&gt;）。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>JDK代理是不需要第三方库支持，只需要JDK环境就可以进行代理，使用条件:</p><ol><li><p>实现InvocationHandler</p></li><li><p>使用Proxy.newProxyInstance产生代理对象</p></li><li><p>被代理的对象必须要实现接口</p></li></ol><p>CGLib必须依赖于CGLib的类库，但是它需要类来实现任何接口代理的是指定的类生成一个子类，覆盖其中的方法，是一种继承但是针对接口编程的环境下推荐使用JDK的代理；</p><h2 id="5、深拷贝和浅拷贝区别是什么？"><a href="#5、深拷贝和浅拷贝区别是什么？" class="headerlink" title="5、深拷贝和浅拷贝区别是什么？"></a><strong>5、深拷贝和浅拷贝区别是什么？</strong></h2><ul><li>浅拷贝只是复制了对象的引用地址，两个对象指向同一个内存地址，所以修改其中任意的值，另一个值都会随之变化，这就是浅拷贝（例：assign()）</li><li>深拷贝是将对象及值复制过来，两个对象修改其中任意的值另一个值不会改变，这就是深拷贝（例：JSON.parse()和JSON.stringify()，但是此方法无法复制函数类型）</li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a><strong>异常</strong></h1><h2 id="1、throw-和-throws-的区别？"><a href="#1、throw-和-throws-的区别？" class="headerlink" title="1、throw 和 throws 的区别？"></a><strong>1、throw 和 throws 的区别？</strong></h2><p>throws是用来声明一个方法可能抛出的所有异常信息，throws是将异常声明但是不处理，而是将异常往上传，谁调用我就交给谁处理。而throw则是指抛出的一个具体的异常类型。</p><h2 id="2、final、finally、finalize-有什么区别？"><a href="#2、final、finally、finalize-有什么区别？" class="headerlink" title="2、final、finally、finalize 有什么区别？"></a>2、final、finally、finalize 有什么区别？</h2><ul><li>final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。</li><li>finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</li><li>finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System的gc()方法的时候，由垃圾回收器调用finalize(),回收垃圾</li></ul><h2 id="3、try-catch-finally-中哪个部分可以省略？"><a href="#3、try-catch-finally-中哪个部分可以省略？" class="headerlink" title="3、try-catch-finally 中哪个部分可以省略？"></a>3、try-catch-finally 中哪个部分可以省略？</h2><p>答：catch 可以省略</p><p>原因：更为严格的说法其实是：try只适合处理运行时异常，try+catch适合处理运行时异常+普通异常。也就是说，如果你只用try去处理普通异常却不加以catch处理，编译是通不过的，因为编译器硬性规定，普通异常如果选择捕获，则必须用catch显示声明以便进一步处理。而运行时异常在编译时没有如此规定，所以catch可以省略，你加上catch编译器也觉得无可厚非。</p><p>理论上，编译器看任何代码都不顺眼，都觉得可能有潜在的问题，所以你即使对所有代码加上try，代码在运行期时也只不过是在正常运行的基础上加一层皮。但是你一旦对一段代码加上try，就等于显示地承诺编译器，对这段代码可能抛出的异常进行捕获而非向上抛出处理。如果是普通异常，编译器要求必须用catch捕获以便进一步处理；如果运行时异常，捕获然后丢弃并且+finally扫尾处理，或者加上catch捕获以便进一步处理。</p><p>至于加上finally，则是在不管有没捕获异常，都要进行的“扫尾”处理。</p><h2 id="4、try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？"><a href="#4、try-catch-finally-中，如果-catch-中-return-了，finally-还会执行吗？" class="headerlink" title="4、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？"></a><strong>4、try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong></h2><p>答：会执行，在 return 前执行。</p><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a><strong>网络</strong></h1><h2 id="1、http-响应码-301-和-302-代表的是什么？有什么区别？"><a href="#1、http-响应码-301-和-302-代表的是什么？有什么区别？" class="headerlink" title="1、http 响应码 301 和 302 代表的是什么？有什么区别？"></a>1、http 响应码 301 和 302 代表的是什么？有什么区别？</h2><p>答：301，302 都是HTTP状态的编码，都代表着某个URL发生了转移。</p><p>区别：</p><ul><li>301 redirect: 301 代表永久性转移(Permanently Moved)。</li><li>302 redirect: 302 代表暂时性转移(Temporarily Moved )。</li></ul><h2 id="2、简述-tcp-和-udp的区别？"><a href="#2、简述-tcp-和-udp的区别？" class="headerlink" title="2、简述 tcp 和 udp的区别？"></a>2、简述 tcp 和 udp的区别？</h2><ul><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。</li><li>TCP通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。</li><li>UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>TCP对系统资源要求较多，UDP对系统资源要求较少。</li></ul><h2 id="3、tcp-为什么要三次握手，两次不行吗？为什么？"><a href="#3、tcp-为什么要三次握手，两次不行吗？为什么？" class="headerlink" title="3、tcp 为什么要三次握手，两次不行吗？为什么？"></a>3、tcp 为什么要三次握手，两次不行吗？为什么？</h2><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。</p><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。</p><h2 id="4、说一下-tcp-粘包是怎么产生的？"><a href="#4、说一下-tcp-粘包是怎么产生的？" class="headerlink" title="4、说一下 tcp 粘包是怎么产生的？"></a><strong>4、说一下 tcp 粘包是怎么产生的？</strong></h2><p>①. 发送方产生粘包</p><p>采用TCP协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据；但当发送的数据包过于的小时，那么TCP协议默认的会启用Nagle算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p><img src="/posts/1f03d757/101.png" srcset="/img/loading.gif" lazyload><p>②. 接收方产生粘包</p><p>接收方采用TCP协议接收数据时的过程是这样的：数据到底接收方，从网络模型的下方传递至传输层，传输层的TCP协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C语言用recv、read等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p><img src="/posts/1f03d757/102.png" srcset="/img/loading.gif" lazyload><h2 id="5、OSI-的七层模型都有哪些？"><a href="#5、OSI-的七层模型都有哪些？" class="headerlink" title="5、OSI 的七层模型都有哪些？"></a>5、OSI 的七层模型都有哪些？</h2><ul><li>应用层：网络服务与最终用户的一个接口。</li><li>表示层：数据的表示、安全、压缩。</li><li>会话层：建立、管理、终止会话。</li><li>传输层：定义传输数据的协议端口号，以及流控和差错校验。</li><li>网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。</li><li>数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。</li><li>物理层：建立、维护、断开物理连接。</li></ul><h2 id="6、get-和-post-请求有哪些区别？"><a href="#6、get-和-post-请求有哪些区别？" class="headerlink" title="6、get 和 post 请求有哪些区别？"></a>6、get 和 post 请求有哪些区别？</h2><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。</li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li></ul><h2 id="7、说一下-JSONP-实现原理？"><a href="#7、说一下-JSONP-实现原理？" class="headerlink" title="7、说一下 JSONP 实现原理？"></a><strong>7、说一下 JSONP 实现原理？</strong></h2><p>jsonp 即 json+padding，动态创建script标签，利用script标签的src属性可以获取任何域下的js脚本，通过这个特性(也可以说漏洞)，服务器端不在返货json格式，而是返回一段调用某个函数的js代码，在src中进行了调用，这样实现了跨域。</p><h2 id="8、如何实现跨域？"><a href="#8、如何实现跨域？" class="headerlink" title="8、如何实现跨域？"></a><strong>8、如何实现跨域？</strong></h2><ul><li><p><strong>方式一：图片ping或script标签跨域</strong></p><p><strong>图片ping</strong>常用于跟踪用户点击页面或动态广告曝光次数。<br><strong>script标签</strong>可以得到从其他来源数据，这也是JSONP依赖的根据。</p></li><li><p><strong>方式二：JSONP跨域</strong></p><p>JSONP（JSON with Padding）是数据格式JSON的一种“使用模式”，可以让网页从别的网域要数据。根据 XmlHttpRequest 对象受到同源策略的影响，而利用 <code>&lt;script&gt;</code>元素的这个开放策略，网页可以得到从其他来源动态产生的JSON数据，而这种使用模式就是所谓的 JSONP。用JSONP抓到的数据并不是JSON，而是任意的JavaScript，用 JavaScript解释器运行而不是用JSON解析器解析。所有，通过Chrome查看所有JSONP发送的Get请求都是js类型，而非XHR。</p></li><li><p><strong>方式三：CORS</strong></p><p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。服务器一般需要增加如下响应头的一种或几种：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>: <span class="hljs-literal">true</span><br><span class="hljs-comment">// Ajax设置</span><br><span class="hljs-string">&quot;withCredentials&quot;</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li><li><p><strong>方式四：window.name+iframe</strong></p><p>window.name通过在iframe（一般动态创建i）中加载跨域HTML文件来起作用。然后，HTML文件将传递给请求者的字符串内容赋值给window.name。然后，请求者可以检索window.name值作为响应。</p><ul><li>iframe标签的跨域能力；</li><li>window.name属性值在文档刷新后依旧存在的能力（且最大允许2M左右）。</li></ul><p>每个iframe都有包裹它的window，而这个window是top window的子窗口。contentWindow属性返回<iframe>元素的Window对象。你可以使用这个Window对象来访问iframe的文档及其内部DOM。</iframe></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- <br> 下述用端口 <br> <span class="hljs-number">10000</span>表示：domainA<br> <span class="hljs-number">10001</span>表示：domainB<br>--&gt;<br> <br>&lt;!-- <span class="hljs-attr">localhost</span>:<span class="hljs-number">10000</span> --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">  iframe.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>; <span class="hljs-comment">// 隐藏</span></span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">var</span> state = <span class="hljs-number">0</span>; <span class="hljs-comment">// 防止页面无限刷新</span></span></span><br><span class="language-javascript"><span class="language-xml">  iframe.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span>(state === <span class="hljs-number">1</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">name</span>));</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">// 清除创建的iframe</span></span></span><br><span class="language-javascript"><span class="language-xml">          iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">document</span>.<span class="hljs-title function_">write</span>(<span class="hljs-string">&#x27;&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">          iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">close</span>();</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">removeChild</span>(iframe);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(state === <span class="hljs-number">0</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          state = <span class="hljs-number">1</span>;</span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">// 加载完成，指向当前域，防止错误(proxy.html为空白页面)</span></span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-comment">// Blocked a frame with origin &quot;http://localhost:10000&quot; from accessing a cross-origin frame.</span></span></span><br><span class="language-javascript"><span class="language-xml">          iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">location</span> = <span class="hljs-string">&#x27;http://localhost:10000/proxy.html&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml">  iframe.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://localhost:10001&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br> <br>&lt;!-- <span class="hljs-attr">localhost</span>:<span class="hljs-number">10001</span> --&gt;<br>&lt;!<span class="hljs-variable constant_">DOCTYPE</span> html&gt;<br>...<br>&lt;script&gt;<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;);<br>&lt;/script&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></li></ul><p><strong>方式五：window.postMessage()</strong></p><p>HTML5新特性，可以用来向其他所有的 window 对象发送消息。需要注意的是我们必须要保证所有的脚本执行完才发送 MessageEvent，如果在函数执行的过程中调用了它，就会让后面的函数超时无法执行。</p><p><strong>方式六：修改document.domain跨子域</strong></p><p>前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域，所以只能跨子域</p><p>在根域范围内，允许把domain属性的值设置为它的上一级域。例如，在”aaa.xxx.com”域内，可以把domain设置为 “xxx.com” 但不能设置为 “xxx.org” 或者”com”。</p><p><strong>方式七：WebSocket</strong></p><p>WebSocket protocol 是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很棒的实现。</p><p>需要注意：WebSocket对象不支持DOM 2级事件侦听器，必须使用DOM 0级语法分别定义各个事件。</p><p><strong>方式八：代理</strong></p><p>同源策略是针对浏览器端进行的限制，可以通过服务器端来解决该问题</p><p>DomainA客户端（浏览器） &#x3D;&#x3D;&gt; DomainA服务器 &#x3D;&#x3D;&gt; DomainB服务器 &#x3D;&#x3D;&gt; DomainA客户端（浏览器）</p><h1 id="Spring-x2F-Spring-MVC"><a href="#Spring-x2F-Spring-MVC" class="headerlink" title="Spring &#x2F; Spring MVC"></a><strong>Spring &#x2F; Spring MVC</strong></h1><h2 id="1、解释一下什么是-ioc？"><a href="#1、解释一下什么是-ioc？" class="headerlink" title="1、解释一下什么是 ioc？"></a><strong>1、解释一下什么是 ioc？</strong></h2><p>IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring框架来管理。</strong> IoC 在其他语言中也有应用，并非 Spring 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p><p>将对象之间的相互依赖关系交给 IOC 容器来管理，并由 IOC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 <strong>IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件&#x2F;注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><p><strong>Spring IOC的初始化过程：</strong></p><img src="/posts/1f03d757/107.png" srcset="/img/loading.gif" lazyload alt="Spring IOC的初始化过程"><p>IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。如下图：</p><img src="/posts/1f03d757/103.png" srcset="/img/loading.gif" lazyload><p>大家看到了吧，由于引进了中间位置的“第三方”，也就是IOC容器，使得A、B、C、D这4个对象没有了耦合关系，齿轮之间的传动全部依靠“第三方”了，全部对象的控制权全部上缴给“第三方”IOC容器，所以，IOC容器成了整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有这个“粘合剂”，对象与对象之间会彼此失去联系，这就是有人把IOC容器比喻成“粘合剂”的由来。</p><h2 id="2、spring-有哪些主要模块？"><a href="#2、spring-有哪些主要模块？" class="headerlink" title="2、spring 有哪些主要模块？"></a><strong>2、spring 有哪些主要模块？</strong></h2><p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问&#x2F;集成、Web、AOP（面向切面编程）、工具、消息和测试模块。</p><img src="/posts/1f03d757/105.png" srcset="/img/loading.gif" lazyload style="zoom:80%"><h2 id="3、spring-常用的注入方式有哪些？"><a href="#3、spring-常用的注入方式有哪些？" class="headerlink" title="3、spring 常用的注入方式有哪些？"></a><strong>3、spring 常用的注入方式有哪些？</strong></h2><p>Spring通过DI（依赖注入）实现IOC（控制反转），常用的注入方式主要有三种：</p><ol><li>构造方法注入</li><li>setter注入</li><li>基于注解的注入</li></ol><h2 id="4、spring-支持几种-bean-的作用域？"><a href="#4、spring-支持几种-bean-的作用域？" class="headerlink" title="4、spring 支持几种 bean 的作用域？"></a>4、spring 支持几种 bean 的作用域？</h2><p>当通过spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持如下5种作用域：</p><ul><li>singleton：单例模式，在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例</li><li>prototype：原型模式，每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例</li><li>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新实例，即每次HTTP请求将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域才有效</li><li>session：对于每次HTTP Session，使用session定义的Bean都将产生一个新实例。同样只有在Web应用中使用Spring时，该作用域才有效</li><li>globalsession：每个全局的HTTP Session，使用session定义的Bean都将产生一个新实例。典型情况下，仅在使用portlet context的时候有效。同样只有在Web应用中使用Spring时，该作用域才有效</li></ul><p>其中比较常用的是singleton和prototype两种作用域。对于singleton作用域的Bean，每次请求该Bean都将获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为；如果一个Bean被设置成prototype作用域，程序每次请求该id的Bean，Spring都会新建一个Bean实例，然后返回给程序。在这种情况下，Spring容器仅仅使用new 关键字创建Bean实例，一旦创建成功，容器不在跟踪实例，也不会维护Bean实例的状态。</p><p>如果不指定Bean的作用域，Spring默认使用singleton作用域。Java在创建Java实例时，需要进行内存申请；销毁实例时，需要完成垃圾回收，这些工作都会导致系统开销的增加。因此，prototype作用域Bean的创建、销毁代价比较大。而singleton作用域的Bean实例一旦创建成功，可以重复使用。因此，除非必要，否则尽量避免将Bean被设置成prototype作用域。</p><h2 id="5、Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#5、Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="5、Spring 中的单例 bean 的线程安全问题了解吗？"></a>5、Spring 中的单例 bean 的线程安全问题了解吗？</h2><p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p><p>常见的有两种解决办法：</p><ol><li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li><li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li></ol><h2 id="6、说一下-spring-的事务隔离级别？"><a href="#6、说一下-spring-的事务隔离级别？" class="headerlink" title="6、说一下 spring 的事务隔离级别？"></a><strong>6、说一下 spring 的事务隔离级别？</strong></h2><p>事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p><ul><li>脏读：一个事务读到另一个事务未提交的更新数据。</li><li>幻读：例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样。</li><li>不可重复读：比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读。</li></ul><h2 id="7、Spring-事务中的隔离级别有哪几种"><a href="#7、Spring-事务中的隔离级别有哪几种" class="headerlink" title="7、Spring 事务中的隔离级别有哪几种?"></a>7、Spring 事务中的隔离级别有哪几种?</h2><p><strong>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</strong></p><ul><li><strong>TransactionDefinition.ISOLATION_DEFAULT:</strong><br>使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li><li><strong>TransactionDefinition.ISOLATION_READ_UNCOMMITTED:</strong><br>最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li><strong>TransactionDefinition.ISOLATION_READ_COMMITTED:</strong><br>允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li><strong>TransactionDefinition.ISOLATION_REPEATABLE_READ:</strong><br>对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li><strong>TransactionDefinition.ISOLATION_SERIALIZABLE:</strong><br>最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h2 id="8、Spring-事务中哪七种事务传播行为"><a href="#8、Spring-事务中哪七种事务传播行为" class="headerlink" title="8、Spring 事务中哪七种事务传播行为?"></a>8、Spring 事务中哪七种事务传播行为?</h2><p><strong>支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRED：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</li><li><strong>TransactionDefinition.PROPAGATION_SUPPORTS：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li><strong>TransactionDefinition.PROPAGATION_MANDATORY：</strong> 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li></ul><p><strong>不支持当前事务的情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_REQUIRES_NEW：</strong> 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NOT_SUPPORTED：</strong> 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li><strong>TransactionDefinition.PROPAGATION_NEVER：</strong> 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><p><strong>其他情况：</strong></p><ul><li><strong>TransactionDefinition.PROPAGATION_NESTED：</strong> 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li></ul><h2 id="9、说一下-spring-mvc-运行流程？"><a href="#9、说一下-spring-mvc-运行流程？" class="headerlink" title="9、说一下 spring mvc 运行流程？"></a><strong>9、说一下 spring mvc 运行流程？</strong></h2><p><strong>Spring MVC运行流程图：</strong></p><img src="/posts/1f03d757/106.png" srcset="/img/loading.gif" lazyload><p>Spring运行流程描述：</p><ol><li><p>用户向服务器发送请求，请求被Spring前端控制Servlet DispatcherServlet捕获；</p></li><li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</p></li><li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter；（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</p></li><li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p><ul><li><p>HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p></li><li><p>数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p></li><li><p>数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p></li><li><p>数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p></li></ul></li><li><p>Handler执行完成后，向DispatcherServlet返回一个ModelAndView对象；</p></li><li><p>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</p></li><li><p>ViewResolver结合Model和View，来渲染视图；</p></li><li><p>将渲染结果返回给客户端。</p></li></ol><h2 id="10、spring-mvc-有哪些组件？"><a href="#10、spring-mvc-有哪些组件？" class="headerlink" title="10、spring mvc 有哪些组件？"></a>10、spring mvc 有哪些组件？</h2><p>Spring MVC的核心组件：</p><ol><li>DispatcherServlet：中央控制器，把请求给转发到具体的控制类</li><li>Controller：具体处理请求的控制器</li><li>HandlerMapping：映射处理器，负责映射中央处理器转发给controller时的映射策略</li><li>ModelAndView：服务层返回的数据和视图层的封装类</li><li>ViewResolver：视图解析器，解析具体的视图</li><li>Interceptors ：拦截器，负责拦截我们定义的请求然后做处理工作</li></ol><h2 id="11、Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#11、Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="11、Spring AOP 和 AspectJ AOP 有什么区别？"></a>11、Spring AOP 和 AspectJ AOP 有什么区别？</h2><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ，它比Spring AOP 快很多。</p><h2 id="12、Spring-中的-bean-生命周期"><a href="#12、Spring-中的-bean-生命周期" class="headerlink" title="12、Spring 中的 bean 生命周期?"></a>12、Spring 中的 bean 生命周期?</h2><p><strong>中文版本图</strong></p><img src="/posts/1f03d757/110.jpg" srcset="/img/loading.gif" lazyload><p><strong>英文版本图</strong></p><img src="/posts/1f03d757/111.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><ul><li><p>Bean 容器找到配置文件中 Spring Bean 的定义。</p><p>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</p></li><li><p>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</p></li><li><p>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</p><p>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</p><p>如果Bean实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code> 对象的实例。</p><p>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</p></li><li><p>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</p></li><li><p>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</p></li><li><p>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</p></li><li><p>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</p></li><li><p>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</p><p>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p></li></ul><h2 id="13、-Component-和-Bean-的区别是什么？"><a href="#13、-Component-和-Bean-的区别是什么？" class="headerlink" title="13、@Component 和 @Bean 的区别是什么？"></a>13、@Component 和 @Bean 的区别是什么？</h2><ol><li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ol><h2 id="14、将一个类声明为Spring的-bean-的注解有哪些"><a href="#14、将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="14、将一个类声明为Spring的 bean 的注解有哪些?"></a>14、将一个类声明为Spring的 bean 的注解有哪些?</h2><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于拿个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h2 id="15、区分-BeanFactory-和-ApplicationContext"><a href="#15、区分-BeanFactory-和-ApplicationContext" class="headerlink" title="15、区分 BeanFactory 和 ApplicationContext"></a>15、区分 BeanFactory 和 ApplicationContext</h2><h2 id="16、-Required-注解有什么用？"><a href="#16、-Required-注解有什么用？" class="headerlink" title="16、@Required 注解有什么用？"></a>16、@Required 注解有什么用？</h2><p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-meta">@Required</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span>&#123;<br>		<span class="hljs-built_in">this</span>.name=name;<br>	&#125;<br>	<span class="hljs-keyword">public</span> string <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="17、-Autowired-注解有什么用？"><a href="#17、-Autowired-注解有什么用？" class="headerlink" title="17、@Autowired 注解有什么用？"></a>17、@Autowired 注解有什么用？</h2><p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配bean。默认情况下，它是类型驱动的注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-meta">@Autowired</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>		<span class="hljs-built_in">this</span>.name=name;<br>	&#125;<br>	<span class="hljs-keyword">public</span> string <span class="hljs-title function_">getName</span><span class="hljs-params">()</span>&#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18、-Qualifier-注解有什么用？"><a href="#18、-Qualifier-注解有什么用？" class="headerlink" title="18、@Qualifier 注解有什么用？"></a>18、@Qualifier 注解有什么用？</h2><p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean来消除歧义。 例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</p><p>Employee.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>	<span class="hljs-keyword">private</span> String name;<br>	<span class="hljs-meta">@Autowired</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>		<span class="hljs-built_in">this</span>.name=name;<br>	&#125;<br>	<span class="hljs-keyword">public</span> string <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>		<span class="hljs-keyword">return</span> name;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>EmpAccount.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmpAccount</span> &#123;<br>	<span class="hljs-keyword">private</span> Employee emp;<br>    <br>	<span class="hljs-meta">@Autowired</span><br>	<span class="hljs-meta">@Qualifier(emp1)</span><br>	<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">showName</span><span class="hljs-params">()</span> &#123;<br>		System.out.println(“Employee name : ”+emp.getName);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="19、列举-Spring-DAO-抛出的异常。"><a href="#19、列举-Spring-DAO-抛出的异常。" class="headerlink" title="19、列举 Spring DAO 抛出的异常。"></a>19、列举 Spring DAO 抛出的异常。</h2><img src="/posts/1f03d757/194.jpg" srcset="/img/loading.gif" lazyload style="zoom:150%"><h2 id="20、spring-JDBC-API-中存在哪些类？"><a href="#20、spring-JDBC-API-中存在哪些类？" class="headerlink" title="20、spring JDBC API 中存在哪些类？"></a>20、spring JDBC API 中存在哪些类？</h2><ul><li><code>JdbcTemplate</code></li><li><code>SimpleJdbcTemplate</code></li><li><code>NamedParameterJdbcTemplate</code></li><li><code>SimpleJdbcInsert</code></li><li><code>SimpleJdbcCall</code></li></ul><h2 id="21、列举-spring-支持的事务管理类型"><a href="#21、列举-spring-支持的事务管理类型" class="headerlink" title="21、列举 spring 支持的事务管理类型"></a>21、列举 spring 支持的事务管理类型</h2><p>Spring 支持两种类型的事务管理：</p><ul><li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li><li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML的配置来管理事务。</li></ul><h2 id="22、spring-支持哪些-ORM-框架"><a href="#22、spring-支持哪些-ORM-框架" class="headerlink" title="22、spring 支持哪些 ORM 框架"></a>22、spring 支持哪些 ORM 框架</h2><ul><li>Hibernate</li><li>iBatis</li><li>JPA</li><li>JDO</li><li>OJB</li></ul><h2 id="23、指出在-spring-aop-中-concern-和-cross-cuttingconcern-的不同之处。"><a href="#23、指出在-spring-aop-中-concern-和-cross-cuttingconcern-的不同之处。" class="headerlink" title="23、指出在 spring aop 中 concern 和 cross-cuttingconcern 的不同之处。"></a>23、指出在 spring aop 中 concern 和 cross-cuttingconcern 的不同之处。</h2><p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</p><p>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p><h2 id="24、AOP-有哪些实现方式？"><a href="#24、AOP-有哪些实现方式？" class="headerlink" title="24、AOP 有哪些实现方式？"></a>24、AOP 有哪些实现方式？</h2><p>实现 AOP 的技术，主要分为两大类：</p><p>静态代理 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</p><ul><li>编译时编织（特殊编译器实现）</li><li>类加载时编织（特殊的类加载器实现）。</li></ul><p>动态代理 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</p><ul><li>JDK 动态代理</li><li>CGLIB</li></ul><h2 id="25、如何理解-Spring-中的代理？"><a href="#25、如何理解-Spring-中的代理？" class="headerlink" title="25、如何理解 Spring 中的代理？"></a>25、如何理解 Spring 中的代理？</h2><p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。 Advice + Target Object &#x3D; Proxy</p><h2 id="26、介绍一下-WebApplicationContext"><a href="#26、介绍一下-WebApplicationContext" class="headerlink" title="26、介绍一下 WebApplicationContext"></a>26、介绍一下 WebApplicationContext</h2><p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p><h2 id="27、Bean-工厂和-Application-contexts-有什么区别？"><a href="#27、Bean-工厂和-Application-contexts-有什么区别？" class="headerlink" title="27、Bean 工厂和 Application contexts 有什么区别？"></a>27、Bean 工厂和 Application contexts 有什么区别？</h2><p>Application contexts 提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的 bean 发布事件。另外，在容器或容器内的对象上执行的那些不得不由 bean 工厂以程序化方式处理的操作，可以在Application contexts 中以声明的方式处理。</p><p>Application contexts 实现了 MessageSource 接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。</p><h2 id="28、自动装配有哪些局限性"><a href="#28、自动装配有哪些局限性" class="headerlink" title="28、自动装配有哪些局限性 ?"></a>28、自动装配有哪些局限性 ?</h2><p>自动装配的局限性是：</p><ol><li>重写：你仍需用配置来定义依赖，意味着总要重写自动装配。</li><li>基本数据类型：你不能自动装配简单的属性，如基本数据类型，String字符串，和类。</li><li>模糊特性：自动装配不如显式装配精确，如果有可能，建议使用显式装配。</li></ol><h2 id="29、你可以在-Spring-中注入一个-null-和一个空字符串吗？"><a href="#29、你可以在-Spring-中注入一个-null-和一个空字符串吗？" class="headerlink" title="29、你可以在 Spring 中注入一个 null 和一个空字符串吗？"></a>29、你可以在 Spring 中注入一个 null 和一个空字符串吗？</h2><p>可以。</p><h2 id="30、有几种不同类型的自动代理？"><a href="#30、有几种不同类型的自动代理？" class="headerlink" title="30、有几种不同类型的自动代理？"></a>30、有几种不同类型的自动代理？</h2><ol><li><code>BeanNameAutoProxyCreator</code></li><li><code>DefaultAdvisorAutoProxyCreator</code></li><li><code>Metadata autoproxying</code></li></ol><h2 id="拦截器和过滤器的区别"><a href="#拦截器和过滤器的区别" class="headerlink" title="拦截器和过滤器的区别"></a>拦截器和过滤器的区别</h2><p><strong>过滤器（filter）：</strong></p><ul><li>过滤器处于客户端与Web资源（Servlet、JSP、HTML）之间，客户端与Web资源之间的请求和响应都要通过过滤器进行过滤。举例：在过滤器中定义了禁止访问192.10.10.1这个地址，那么当客户端发出访问192.10.10.1的请求时，经过过滤器后，客户端得到的响应是出现该IP禁止访问的提示。</li><li>在java web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的 action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者 struts的action前统一设置字符集，或者去除掉一些非法字符</li></ul><p>**拦截器（interceptor）:**，</p><ul><li>拦截器是一种面向方面&#x2F;切面编程（AOP Aspect-Oriented Programming）.</li><li>面向切面就是将多个模块的的通用服务进行分离，如权限管理、日志服务，他们在多个模块中都会用到，就可以将其各自封装为一个可重用模块。而这些通用服务的具体实现是通过拦截器来完成，比如用户客户端访问一些保密模块都应先通过权限审查的拦截器来进行权限审查，确定用户是否具有该项操作的权限后方能向下执行。</li><li>在面向切面编程的就是在你的service或者一个方法，前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。</li></ul><p><strong>两者的区别</strong></p><ul><li>拦截器是基于java反射机制的，而过滤器是基于函数回调。</li><li>拦截器不依赖于Servlet容器，而过滤器依赖于servlet容器。</li><li>拦截器只能对action请求起作用，而过滤器可以对几乎所以的请求起作用。</li><li>拦截器可以访问action上下文，值栈里的对象，而过滤器不能。</li><li>在Action的生命周期周，拦截器可以被多次调用，而过滤器只能在容器初始化的时候被调用一次。</li></ul><p><strong>执行顺序 ：</strong>过滤前 - 拦截前 - Action处理 - 拦截后 - 过滤后。个人认为过滤是一个横向的过程，首先把客户端提交的内容进行过滤(例如未登录用户不能访问内部页面的处理)；过滤通过后，拦截器将检查用户提交数据的验证，做一些前期的数据处理，接着把处理后的数据发给对应的Action；Action处理完成返回后，拦截器还可以做其他过程(还没想到要做啥)，再向上返回到过滤器的后续操作。</p><p>拦截器 ：是在面向切面编程的就是在你的service或者一个方法前调用一个方法，或者在方法后调用一个方法比如动态代理就是拦截器的简单实现，在你调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在你调用方法后打印出字符串，甚至在你抛出异常的时候做业务逻辑的操作。</p><p>过滤器：是在java web中，你传入的request,response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者struts的 action进行业务逻辑，比如过滤掉非法url（不是login.do的地址请求，如果用户没有登陆都过滤掉）,或者在传入servlet或者 struts的action前统一设置字符集，或者去除掉一些非法字符.</p><h2 id="Java-中，嵌套公共静态类与顶级类有什么不同？"><a href="#Java-中，嵌套公共静态类与顶级类有什么不同？" class="headerlink" title="Java 中，嵌套公共静态类与顶级类有什么不同？"></a>Java 中，嵌套公共静态类与顶级类有什么不同？</h2><p>类的内部可以有多个嵌套公共静态类，但是一个 Java 源文件只能有一个顶级公共类，并且顶级公共类的名称与源文件名称必须一致。</p><h2 id="Java-中，Serializable-与-Externalizable-的区别？"><a href="#Java-中，Serializable-与-Externalizable-的区别？" class="headerlink" title="Java 中，Serializable 与 Externalizable 的区别？"></a>Java 中，Serializable 与 Externalizable 的区别？</h2><p>Serializable 接口是一个序列化 Java 类的接口，以便于它们可以在网络上传输或者可以将它们的状态保存在磁盘上，是 JVM 内嵌的默认序列化方式，成本高、脆弱而且不安全。Externalizable 允许你控制整个序列化过程，指定特定的二进制格式，增加安全机制。</p><h2 id="Java-中，DOM-和-SAX-解析器有什么不同？"><a href="#Java-中，DOM-和-SAX-解析器有什么不同？" class="headerlink" title="Java 中，DOM 和 SAX 解析器有什么不同？"></a>Java 中，DOM 和 SAX 解析器有什么不同？</h2><p>DOM 解析器将整个 XML 文档加载到内存来创建一棵 DOM 模型树，这样可以更快的查找节点和修改 XML 结构，而 SAX 解析器是一个基于事件的解析器，不会将整个 XML 文档加载到内存。由于这个原因，DOM 比 SAX 更快，也要求更多的内存，不适合于解析大 XML 文件。</p><h2 id="说出-JDK-1-7-中的三个新特性？"><a href="#说出-JDK-1-7-中的三个新特性？" class="headerlink" title="说出 JDK 1.7 中的三个新特性？"></a>说出 JDK 1.7 中的三个新特性？</h2><p>虽然 JDK 1.7 不像 JDK 5 和 8 一样的大版本，但是，还是有很多新的特性，如</p><ol><li>try-with-resource 语句，这样你在使用流或者资源的时候，就不需要手动关闭，Java 会自动关闭。</li><li>Fork-Join 池某种程度上实现 Java 版的 Map-reduce。</li><li>允许 Switch 中有 String 变量和文本。</li><li>菱形操作符(&lt;&gt;)用于类型推断，不再需要在变量声明的右边申明泛型，因此可以写出可读写更强、更简洁的代码。</li><li>另一个值得一提的特性是改善异常处理，如允许在同一个 catch 块中捕获多个异常。</li></ol><h2 id="说出-5-个-JDK-1-8-引入的新特性？"><a href="#说出-5-个-JDK-1-8-引入的新特性？" class="headerlink" title="说出 5 个 JDK 1.8 引入的新特性？"></a>说出 5 个 JDK 1.8 引入的新特性？</h2><p>Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：</p><ol><li>Lambda 表达式,允许像对象一样传递匿名函数</li><li>Stream API,充分利用现代多核 CPU，可以写出很简洁的代码</li><li>Date 与 Time API,最终，有一个稳定、简单的日期和时间库可供你使用</li><li>扩展方法，现在，接口中可以有静态、默认方法。</li><li>重复注解，现在你可以将相同的注解在同一类型上使用多次。</li></ol><h2 id="8、-amp-和-amp-amp-的区别？"><a href="#8、-amp-和-amp-amp-的区别？" class="headerlink" title="8、&amp;和&amp;&amp;的区别？"></a>8、&amp;和&amp;&amp;的区别？</h2><p>&amp;和&amp;&amp;都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。</p><p>区别：</p><ul><li><p>&amp;&amp;还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式以及后面的表达式。(如果遇到true就一直向下判断条件直到遇到false的表达式返回)</p></li><li><p>&amp;不具有短路的功能,逻辑运算表达式条件都会执行。</p></li></ul><h2 id="9、解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。"><a href="#9、解释内存中的栈-stack-、堆-heap-和方法区-method-area-的用法。" class="headerlink" title="9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。"></a>9、解释内存中的栈(stack)、堆(heap)和方法区(method area)的用法。</h2><p>通常我们定义一个基本数据类型的变量，一个对象的引用，还有就是函数调用的现场保存都使用JVM中的栈空间；而通过new关键字和构造器创建的对象则放在堆空间，堆是垃圾收集器管理的主要区域，由于现在的垃圾收集器都采用分代收集算法，所以堆空间还可以细分为新生代和老生代，再具体一点可以分为Eden、Survivor（又可分为From Survivor和To Survivor）、Tenured；方法区和堆都是各个线程共享的内存区域，用于存储已经被JVM加载的类信息、常量、静态变量、JIT编译器编译后的代码等数据；程序中的字面量（literal）如直接书写的100、”hello”和常量都是放在常量池中，常量池是方法区的一部分。栈空间操作起来最快但是栈很小，通常大量的对象都是放在堆空间，栈和堆的大小都可以通过JVM的启动参数来进行调整，栈空间用光了会引发StackOverflowError，而堆和常量池空间不足则会引发OutOfMemoryError。</p><h2 id="11、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？"><a href="#11、switch-是否能作用在-byte-上，是否能作用在-long-上，是否能作用在-String-上？" class="headerlink" title="11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？"></a>11、switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上？</h2><p>switch可作用于char byte short int</p><p>switch可作用于char byte short int对应的包装类</p><p>switch不可作用于long double float boolean，包括他们的包装类</p><h2 id="13、数组有没有-length-方法？String-有没有-length-方法？"><a href="#13、数组有没有-length-方法？String-有没有-length-方法？" class="headerlink" title="13、数组有没有 length()方法？String 有没有 length()方法？"></a>13、数组有没有 length()方法？String 有没有 length()方法？</h2><p>数组没有length()这个方法，有length的属性。String有length()这个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> a[];<br>a.length; <span class="hljs-comment">//返回a的长度</span><br>String s;<br>s.length(); <span class="hljs-comment">//返回s的长度</span><br></code></pre></td></tr></table></figure><h2 id="14、在-Java-中，如何跳出当前的多重嵌套循环？"><a href="#14、在-Java-中，如何跳出当前的多重嵌套循环？" class="headerlink" title="14、在 Java 中，如何跳出当前的多重嵌套循环？"></a>14、在 Java 中，如何跳出当前的多重嵌套循环？</h2><p><strong>一、标号方式</strong><br>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号break语句，即可跳出外层循环。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">ok:<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i + <span class="hljs-string">&quot;,j=&quot;</span> + j);<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">5</span>) <span class="hljs-keyword">break</span> ok;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>二、break跳出当前循环，通过内部跳出条件控制跳出外部循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i + <span class="hljs-string">&quot;; j=&quot;</span> + j);<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">3</span>) &#123;<br>            i = <span class="hljs-number">4</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>三、抛出异常也可以跳出多重循环</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i + <span class="hljs-string">&quot;; j=&quot;</span> + j);<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">3</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;e&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> arr[][] = &#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;, &#123;<span class="hljs-number">9</span>&#125;&#125;;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr.length &amp;&amp; !found; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; arr[i].length; j++) &#123;<br>        System.out.println(<span class="hljs-string">&quot;i=&quot;</span> + i + <span class="hljs-string">&quot;,j=&quot;</span> + j);<br>        <span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-number">5</span>) &#123;<br>            found = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>18、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h2><p>是值传递。Java编程语言中只有由值传递参数的。当一个对象实例作为一个参数被传递到方法中时，参数的值就是该对象的引用。对象的内容可以在被调用的方法中改变，但对象的引用是永远不会改变的。</p><h2 id="19、String-和-StringBuilder、StringBuffer-的区别？"><a href="#19、String-和-StringBuilder、StringBuffer-的区别？" class="headerlink" title="19、String 和 StringBuilder、StringBuffer 的区别？"></a>19、String 和 StringBuilder、StringBuffer 的区别？</h2><p>都是final类，都不允许被继承；</p><p>String类长度是不可变的，StringBuffer和StringBuilder类长度是可以改变的；</p><p>StringBuffer类是线程安全的，StringBuilder不是线程安全的。</p><h2 id="20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>20、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h2><p>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</p><p>重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载；</p><p>重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。</p><p>重载对返回类型没有特殊的要求。</p><h2 id="21、描述一下-JVM-加载-class-文件的原理机制？"><a href="#21、描述一下-JVM-加载-class-文件的原理机制？" class="headerlink" title="21、描述一下 JVM 加载 class 文件的原理机制？"></a>21、描述一下 JVM 加载 class 文件的原理机制？</h2><p>Java中的所有类，都需要由类加载器装载到JVM中才能运行。类加载器本身也是一个类，而它的工作就是把class文件从硬盘读取到内存中。在写程序的时候，我们几乎不需要关心类的加载，因为这些都是隐式装载的，除非我们有特殊的用法，像是反射，就需要显式的加载所需要的类。</p><p>类装载方式，有两种：</p><ol><li>隐式装载， 程序在运行过程中当碰到通过new 等方式生成对象时，隐式调用类装载器加载对应的类到jvm中，</li><li>显式装载：通过调用ClassLoader加载class对象，比如<code>Class.forName(String name)</code>和<code>this.getClass().getClassLoader().loadClass()</code>加载类。</li></ol><p>Java类的加载是动态的，它并不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类(像是基类)完全加载到jvm中，至于其他类，则在需要的时候才加载。这当然就是为了节省内存开销。</p><p>Java的类加载器有三个，对应Java的三种类:</p><ul><li>Bootstrap Loader ：启动类加载器，是虚拟机自身的一部分。负责将存放在\lib目录中的类库加载到虚拟机中。其无法被Java程序直接引用。 负责加载系统类 (指的是内置类，像是String，对应于C#中的System类和C&#x2F;C++标准库中的类)</li><li>ExtClassLoader ： 负责加载扩展类(就是继承类和实现类)</li><li>AppClassLoader ：负责加载用户类路径（ClassPath）上所指定的类库(程序员自定义的类)</li></ul><p>三个加载器各自完成自己的工作，但它们是如何协调工作呢？哪一个类该由哪个类加载器完成呢？为了解决这个问题，Java采用了委托模型机制。</p><p>委托模型机制的工作原理很简单：当类加载器需要加载类的时候，先请示其Parent(即上一层加载器)在其搜索路径载入，如果找不到，才在自己的搜索路径搜索该类。这样的顺序其实就是加载器层次上自顶而下的搜索，因为加载器必须保证基础类的加载。之所以是这种机制，还有一个安全上的考虑：如果某人将一个恶意的基础类加载到jvm，委托模型机制会搜索其父类加载器，显然是不可能找到的，自然就不会将该类加载进来。</p><p>我们可以通过这样的代码来获取类加载器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">loader</span> <span class="hljs-operator">=</span> ClassName.class.getClassLoader();<br><span class="hljs-type">ClassLoader</span> <span class="hljs-variable">ParentLoader</span> <span class="hljs-operator">=</span> loader.getParent();<br></code></pre></td></tr></table></figure><p>注意一个很重要的问题，就是Java在逻辑上并不存在BootstrapKLoader的实体！因为它是用C++编写的，所以打印其内容将会得到null。</p><p>前面是对类加载器的简单介绍，它的原理机制非常简单，就是下面几个步骤:</p><ol><li>装载：查找和导入class文件;</li><li>连接：</li><li>检查：检查载入的class文件数据的正确性;</li><li>准备：为类的静态变量分配存储空间;</li><li>解析：将符号引用转换成直接引用(这一步是可选的)</li><li>初始化：初始化静态变量，静态代码块。<br>这样的过程在程序调用类的静态成员的时候开始执行，所以静态方法main()才会成为一般程序的入口方法。类的构造器也会引发该动作。</li></ol><h2 id="22、char-型变量中能不能存贮一个中文汉字，为什么？"><a href="#22、char-型变量中能不能存贮一个中文汉字，为什么？" class="headerlink" title="22、char 型变量中能不能存贮一个中文汉字，为什么？"></a>22、char 型变量中能不能存贮一个中文汉字，为什么？</h2><p>在Java中，char类型占2个字节，而且Java默认采用Unicode编码，一个Unicode码是16位，所以一个Unicode码占两个字节，Java中无论汉字还是英文字母都是用Unicode编码来表示的。所以，在Java中，char类型变量可以存储一个中文汉字。</p><h2 id="24、静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？"><a href="#24、静态嵌套类-Static-Nested-Class-和内部类（Inner-Class）的不同？" class="headerlink" title="24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？"></a>24、静态嵌套类(Static Nested Class)和内部类（Inner Class）的不同？</h2><p>Static Nested Class是被声明为静态（static）的内部类，它可以不依赖于外部类实例被实例化。</p><p>而通常的内部类(Inner Class)需要在外部类实例化后才能实例化。</p><h2 id="25、Java-中会存在内存泄漏吗，请简单描述。"><a href="#25、Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="25、Java 中会存在内存泄漏吗，请简单描述。"></a>25、Java 中会存在内存泄漏吗，请简单描述。</h2><p><strong>内存泄露就是指一个不再被程序使用的对象或变量一直被占据在内存中。</strong>Java使用有向图的方式进行垃圾回收管理，可以消除引用循环的问题，例如有两个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的</p><p>java中内存泄露的发生场景，通俗地说，就是程序员可能创建了一个对象，以后一直不再使用这个对象，这个对象却一直被引用，即这个对象无用但是却无法被垃圾回收器回收的，这就是java中的内存泄露，一定要让程序将各种分支情况都完整执行到程序结束，然后看某个对象是否被使用过，如果没有，则才能判定这个对象属于内存泄露。</p><p>举个例子：</p><ul><li><p>如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持久外部类的实例对象，这个外部类对象将<strong>不会</strong>被垃圾回收，这也会造成内存泄露。</p></li><li><p>当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露。</p></li></ul><h2 id="26、抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被-synchronized-修饰？"><a href="#26、抽象的（abstract）方法是否可同时是静态的（static）-是否可同时是本地方法（native），是否可同时被-synchronized-修饰？" class="headerlink" title="26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰？"></a>26、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized 修饰？</h2><p>都不能。</p><p>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。</p><p>本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。</p><p>synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</p><h2 id="27、阐述静态变量和实例变量的区别。"><a href="#27、阐述静态变量和实例变量的区别。" class="headerlink" title="27、阐述静态变量和实例变量的区别。"></a>27、阐述静态变量和实例变量的区别。</h2><p><strong>在语法定义上的区别：</strong></p><p>静态变量前要加static关键字，而实例变量前则不加。</p><p><strong>在程序运行时的区别：</strong></p><p>实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。</p><p>静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。</p><p>总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。</p><h2 id="28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"><a href="#28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？" class="headerlink" title="28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？"></a>28、是否可以从一个静态（static）方法内部发出对非静态（non-static）方法的调用？</h2><p>不可以。</p><p>静态方法只能访问静态成员，因为非静态方法的调用要先创建对象，在调用静态方法时可能对象并没有被初始化。</p><h2 id="29、如何实现对象克隆？"><a href="#29、如何实现对象克隆？" class="headerlink" title="29、如何实现对象克隆？"></a>29、如何实现对象克隆？</h2><p>两种不同的克隆方法，浅克隆(ShallowClone)和深克隆(DeepClone)。</p><p>在Java语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括int、double、byte、boolean、char等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于是否支持引用类型的成员变量的复制。</p><hr><p><strong>浅克隆</strong></p><p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。</p><img src="/posts/1f03d757/112.jpg" srcset="/img/loading.gif" lazyload><p>在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆。</p><p><strong>深克隆</strong></p><p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。</p><img src="/posts/1f03d757/113.jpg" srcset="/img/loading.gif" lazyload><p>在Java语言中，如果需要实现深克隆，可以通过覆盖Object类的clone()方法实现，也可以通过序列化(Serialization)等方式来实现。</p><hr><p><strong>克隆有两种方式：</strong></p><ol><li>实现Cloneable接口并重写Object类中的clone()方法；</li></ol><ul><li>clone()方法是定义在java.lang.Object类中，该方法是一个protected的方法，所以重载时要把clone()方法的属性设置为public，这样其它类才能调用这个clone类的clone()方法</li><li>实现Cloneable接口：Cloneable接口是不包含任何方法的！其实这个接口仅仅是一个标志，而且这个标志也仅仅是针对Object类中clone()方法的，如果clone类没有实现Cloneable接口，并调用了Object的clone()方法（也就是调用了super.Clone()方法），那么Object的clone()方法就会抛出 CloneNotSupportedException异常。</li></ul><ol><li>实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆；</li></ol><h2 id="30、GC-是什么？为什么要有-GC？"><a href="#30、GC-是什么？为什么要有-GC？" class="headerlink" title="30、GC 是什么？为什么要有 GC？"></a>30、GC 是什么？为什么要有 GC？</h2><p>GC是垃圾收集的意思（Gabage Collection），内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，<br>Java提供的GC功能可以自动监测对象是否超过作用域从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。</p><p>GC是垃圾收集器。Java 程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一：</p><ul><li>System.gc()</li><li>Runtime.getRuntime().gc()</li></ul><p>Java是由C++发展来的。</p><p>它摈弃了C++中一些繁琐容易出错的东西。其中有一条就是这个GC。</p><p>写C&#x2F;C++程序，程序员定义了一个变量，就是在内存中开辟了一段相应的空间来存值。内存再大也是有限的，所以当程序不再需要使用某个变量的时候，就需要释放这个内存空间资源，好让别的变量来用它。在C&#x2F;C++中，释放无用变量内存空间的事情要由程序员自己来解决。就是说当程序员认为变量没用了，就应当写一条代码，释放它占用的内存。这样才能最大程度地避免内存泄露和资源浪费。</p><p>但是这样显然是非常繁琐的。程序比较大，变量多的时候往往程序员就忘记释放内存或者在不该释放的时候释放内存了。而且释放内存这种事情，从开发角度说，不应当是程序员所应当关注的。程序员所要做的应该是实现所需要的程序功能，而不是耗费大量精力在内存的分配释放上。</p><p>Java有了GC，就不需要程序员去人工释放内存空间。当Java虚拟机发觉内存资源紧张的时候，就会自动地去清理无用变量所占用的内存空间。当然，如果需要，程序员可以在Java程序中显式地使用System.gc()来强制进行一次立即的内存清理。</p><p>因为显式声明是做堆内存全扫描，也就是 Full GC，是需要停止所有的活动的（Stop The World Collection），你的应用能承受这个吗？而其显示调用System.gc()只是给虚拟机一个建议，不一定会执行，因为System.gc()在一个优先级很低的线程中执行。</p><h2 id="33、一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"><a href="#33、一个”-java”源文件中是否可以包含多个类（不是内部类）？有什么限制？" class="headerlink" title="33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？"></a>33、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？</h2><p>可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。</p><h2 id="34、Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？"><a href="#34、Anonymous-Inner-Class-匿名内部类-是否可以继承其它类？是否可以实现接口？" class="headerlink" title="34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？"></a>34、Anonymous Inner Class(匿名内部类)是否可以继承其它类？是否可以实现接口？</h2><p>可以。</p><p><strong>抽象类的匿名内部类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() &#123;<br>            <span class="hljs-meta">@Override</span>  <span class="hljs-comment">//此处方法重载 说明是实现父类  即内部类可以继承其他类 而且是必须</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;eat something&quot;</span>);<br>            &#125;<br>        &#125;;<br>        p.eat();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口类的匿名内部类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>() &#123;<br>            <span class="hljs-meta">@Override</span>  <span class="hljs-comment">//此处方法重载 说明是实现父类  即内部类可以实现其他类 而且是必须</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;eat something&quot;</span>);<br>            &#125;<br>        &#125;;<br>        p.eat();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"><a href="#35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？" class="headerlink" title="35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？"></a>35、内部类可以引用它的包含类（外部类）的成员吗？有没有什么限制？</h2><p>完全可以。</p><ul><li><p><strong>静态内部类</strong>：它是用static修饰的，在访问限制上它只能访问外部类中的static所修饰的成员变量或者是方法：</p></li><li><p><strong>成员内部类</strong>：成员内部类是最普通的内部类，它可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p><p>当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p><ul><li><p>外部类.this.成员变量</p></li><li><p>外部类.this.成员方法</p></li></ul></li><li><p><strong>局部内部类</strong>：局部内部类是定义在外围类的方法中的，在访问的时候它可以直接访问外围类的所有成员！但是不能随便访问局部变量，除非这个局部变量被final修饰。</p></li><li><p><strong>匿名内部类</strong>：匿名内部类其实就是局部内部类的简写格式，只能使用一次。</p></li></ul><h2 id="39、如何实现字符串的反转及替换？"><a href="#39、如何实现字符串的反转及替换？" class="headerlink" title="39、如何实现字符串的反转及替换？"></a>39、如何实现字符串的反转及替换？</h2><p>使用递归实现字符串反转，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">reverse</span><span class="hljs-params">(String originStr)</span> &#123;<br>     <span class="hljs-keyword">if</span>(originStr == <span class="hljs-literal">null</span> || originStr.length() &lt;= <span class="hljs-number">1</span>)<br>         <span class="hljs-keyword">return</span> originStr;<br>     <span class="hljs-keyword">return</span> reverse(originStr.substring(<span class="hljs-number">1</span>)) + originStr.charAt(<span class="hljs-number">0</span>);<br> &#125;<br></code></pre></td></tr></table></figure><p>每次取第一个字符拼到字符串最后，依次递归，如图所示：</p><img src="/posts/1f03d757/114.jpg" srcset="/img/loading.gif" lazyload style="zoom:80%"><h2 id="40、怎样将-GB2312-编码的字符串转换为-ISO-8859-1-编码的字符串？"><a href="#40、怎样将-GB2312-编码的字符串转换为-ISO-8859-1-编码的字符串？" class="headerlink" title="40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？"></a>40、怎样将 GB2312 编码的字符串转换为 ISO-8859-1 编码的字符串？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;你好&quot;</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(s1.getBytes(<span class="hljs-string">&quot;GB2312&quot;</span>), <span class="hljs-string">&quot;ISO-8859-1&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="42、打印昨天的当前时刻。"><a href="#42、打印昨天的当前时刻。" class="headerlink" title="42、打印昨天的当前时刻。"></a>42、打印昨天的当前时刻。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Calendar</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>        cal.add(Calendar.DATE, -<span class="hljs-number">1</span>);<br>        System.out.println(cal.getTime());<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="43、比较一下-Java-和-JavaSciprt。"><a href="#43、比较一下-Java-和-JavaSciprt。" class="headerlink" title="43、比较一下 Java 和 JavaSciprt。"></a>43、比较一下 Java 和 JavaSciprt。</h2><p>Java与JavaScript是两个公司开发的不同的两个产品。Java是原Sun Microsystems公司推出的面向对象的程序设计语言，特别适合于互联网应用程序开发；而JavaScript是Netscape公司的产品，为了扩展Netscape浏览器的功能而开发的一种可以嵌入Web页面中运行的基于对象和事件驱动的解释性语言。JavaScript的前身是LiveScript；而Java的前身是Oak语言。</p><p>下面对两种语言间的异同作如下比较：</p><ul><li>基于对象和面向对象：Java是一种真正的面向对象的语言，即使是开发简单的程序，必须设计对象；JavaScript是种脚本语言，它可以用来制作与网络无关的，与用户交互的复杂软件。它是一种基于对象（Object-Based）和事件驱动（Event-Driven）的编程语言，因而它本身提供了非常丰富的内部对象供设计人员使用。</li><li>解释和编译：Java的源代码在执行之前，必须经过编译。JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行（目前的浏览器几乎都使用了JIT（即时编译）技术来提升JavaScript的运行效率）。</li><li>强类型变量和弱类型变量：Java采用强类型变量检查，即所有变量在编译之前必须作声明；JavaScript中变量是弱类型的，甚至在使用变量前可以不作声明，JavaScript的解释器在运行时检查推断其数据类型。</li><li>代码格式不一样。</li></ul><h2 id="44、什么时候用断言（assert）？"><a href="#44、什么时候用断言（assert）？" class="headerlink" title="44、什么时候用断言（assert）？"></a>44、什么时候用断言（assert）？</h2><p>断言在软件开发中是一种常用的调试方式，很多开发语言中都支持这种机制。一般来说，断言用于保证程序最基本、最关键的正确性。断言检查通常在开发和测试时开启。为了保证程序的执行效率，在软件发布后断言检查通常是关闭的。断言是一个包含布尔表达式的语句，在执行这个语句时假定该表达式为true；如果表达式的值为false，那么系统会报告一个AssertionError。</p><p>注意：断言不应该以任何方式改变程序的状态。简单的说，<strong>如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。</strong></p><p>断言可以有两种形式：</p><ul><li><p>assert Expression1;</p></li><li><p>assert Expression1 : Expression2;</p><p>Expression1表示一个boolean表达式；</p><p>Expression2表示一个基本类型、表达式或者是一个Object，用于在失败时输出错误信息，它是一个传到AssertionError构造函数的值，如果断言失败，该值被转化为它对应的字符串</p></li></ul><p>要在运行时启用断言，可以在启动JVM时使用-enableassertions或者-ea标记。要在运行时选择禁用断言，可以在启动JVM时使用-da或者-disableassertions标记。要在系统类中启用或禁用断言，可使用-esa或-dsa标记。还可以在包的基础上启用或者禁用断言。</p><h2 id="45、Error-和-Exception-有什么区别？"><a href="#45、Error-和-Exception-有什么区别？" class="headerlink" title="45、Error 和 Exception 有什么区别？"></a>45、Error 和 Exception 有什么区别？</h2><img src="/posts/1f03d757/115.jpg" srcset="/img/loading.gif" lazyload><p>异常发生的原因有很多，通常包含以下几大类：</p><ul><li>用户输入了非法数据。</li><li>要打开的文件不存在。</li><li>网络通信时连接中断，或者JVM内存溢出。</li></ul><p>异常主要分三种类型：</p><ol><li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li><li>运行时异常：运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li><li>错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li></ol><p>Java异常又可以分为不受检查异常（Unchecked Exception）和检查异常（Checked Exception）。</p><p>下面将详细讲述这些异常之间的区别与联系：</p><ul><li>Error：Error类对象由 Java<br>虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关。例如，Java虚拟机运行错误（Virtual<br>MachineError），当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止；还有发生在虚拟机试图执行应用时，如类定义错误（NoClassDefFoundError）、链接错误（LinkageError）。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在Java中，错误通常是使用Error的子类描述。</li><li>Exception：在Exception分支中有一个重要的子类RuntimeException（运行时异常），该类型的异常自动为你所编写的程序定义ArrayIndexOutOfBoundsException（数组下标越界）、NullPointerException（空指针异常）、ArithmeticException（算术异常）、MissingResourceException（丢失资源）、ClassNotFoundException（找不到类）等异常，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生；而RuntimeException之外的异常我们统称为非运行时异常，类型上属于Exception类及其子类，从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。</li></ul><img src="/posts/1f03d757/116.jpg" srcset="/img/loading.gif" lazyload><h2 id="47、Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally-分别如何使用？"><a href="#47、Java-语言如何进行异常处理，关键字：throws、throw、try、catch、finally-分别如何使用？" class="headerlink" title="47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？"></a>47、Java 语言如何进行异常处理，关键字：throws、throw、try、catch、finally 分别如何使用？</h2><p>Java通过面向对象的方法进行异常处理，把各种不同的异常进行分类，并提供了良好的接口。在Java中，每个异常都是一个对象，它是Throwable类或其子类的实例。当一个方法出现异常后便抛出一个异常对象，该对象中包含有异常信息，调用这个对象的方法可以捕获到这个异常并可以对其进行处理。Java的异常处理是通过5个关键词来实现的：try、catch、throw、throws和finally。</p><p>一般情况下是用try来执行一段程序，如果系统会抛出（throw）一个异常对象，可以通过它的类型来捕获（catch）它，或通过总是执行代码块（finally）来处理；</p><p>try用来指定一块预防所有异常的程序；catch子句紧跟在try块后面，用来指定你想要捕获的异常的类型；</p><p>throw语句用来明确地抛出一个异常；</p><p>throws用来声明一个方法可能抛出的各种异常（当然声明异常时允许无病呻吟）；</p><p>finally为确保一段代码不管发生什么异常状况都要被执行；</p><p>try语句可以嵌套，每当遇到一个try语句，异常的结构就会被放入异常栈中，直到所有的try语句都完成。如果下一级的try语句没有对某种异常进行处理，异常栈就会执行出栈操作，直到遇到有处理这种异常的try语句或者最终将异常抛给JVM。</p><h2 id="48、运行时异常与受检异常有何异同？"><a href="#48、运行时异常与受检异常有何异同？" class="headerlink" title="48、运行时异常与受检异常有何异同？"></a>48、运行时异常与受检异常有何异同？</h2><p>异常表示程序运行过程中可能出现的非正常状态。</p><p>运行时异常表示虚拟机的通常操作中可能遇到的异常，是一种常见运行错误，只要程序设计得没有问题通常就不会发生。</p><p>受检异常跟程序运行的上下文环境有关，即使程序设计无误，仍然可能因使用的问题而引发。</p><p><strong>Java编译器要求方法必须声明抛出可能发生的受检异常，但是并不要求必须声明抛出未被捕获的运行时异常。</strong>异常和继承一样，是面向对象程序设计中经常被滥用的东西，在Effective Java中对异常的使用给出了以下指导原则：</p><ul><li>不要将异常处理用于正常的控制流（设计良好的API不应该强迫它的调用者为了正常的控制流而使用异常）</li><li>对可以恢复的情况使用受检异常，对编程错误使用运行时异常</li><li>避免不必要的使用受检异常（可以通过一些状态检测手段来避免异常的发生）</li><li>优先使用标准的异常</li><li>每个方法抛出的异常都要有文档</li><li>保持异常的原子性</li><li>不要在catch中忽略掉捕获到的异常</li></ul><h2 id="49、列出一些你常见的运行时异常？"><a href="#49、列出一些你常见的运行时异常？" class="headerlink" title="49、列出一些你常见的运行时异常？"></a>49、列出一些你常见的运行时异常？</h2><ul><li>ArithmeticException（算术异常）</li><li>ClassCastException （类转换异常）</li><li>IllegalArgumentException （非法参数异常）</li><li>IndexOutOfBoundsException （下标越界异常）</li><li>NullPointerException （空指针异常）</li><li>SecurityException （安全异常）</li></ul><h2 id="50、阐述-final、finally、finalize-的区别。"><a href="#50、阐述-final、finally、finalize-的区别。" class="headerlink" title="50、阐述 final、finally、finalize 的区别。"></a>50、阐述 final、finally、finalize 的区别。</h2><ul><li>final：修饰符（关键字）有三种用法：如果一个类被声明为 final，意味 着它不能再派生出新的子类，即不能被继承，因此它和 abstract 是反义词。将 变量声明为 final，可以保证它们在使用中不被改变，被声明为 final 的变量必须 在声明时给定初值，而在以后的引用中只能读取不可修改。被声明为 final 的方 法也同样只能使用，不能在子类中被重写。</li><li>finally：通常放在 try…catch…的后面构造总是执行代码块，这就意味着 程序无论正常执行还是发生异常，这里的代码只要 JVM 不关闭都能执行，可以 将释放外部资源的代码写在 finally 块中。</li><li>finalize：Object 类中定义的方法，Java 中允许使用 finalize()方法在垃 圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在销毁对象时调用的，通过重写 finalize()方法可以整理系统资源或者执行其他清理工作。</li></ul><h2 id="52、List、Set、Map-是否继承自-Collection-接口？"><a href="#52、List、Set、Map-是否继承自-Collection-接口？" class="headerlink" title="52、List、Set、Map 是否继承自 Collection 接口？"></a>52、List、Set、Map 是否继承自 Collection 接口？</h2><p>List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别， 而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List 是线性结构的容器，适用于按数值索引访问元素的情形。</p><h2 id="53、阐述-ArrayList、Vector、LinkedList-的存储性能和特性。"><a href="#53、阐述-ArrayList、Vector、LinkedList-的存储性能和特性。" class="headerlink" title="53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。"></a>53、阐述 ArrayList、Vector、LinkedList 的存储性能和特性。</h2><p>ArrayList 和 Vector 都是使用数组方式存储数据，此数组元素数大于实际存储的 数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉 及数组元素移动等内存操作，所以索引数据快而插入数据慢，Vector 中的方法由 于添加了 synchronized 修饰，因此 Vector 是线程安全的容器，但性能上ArrayList 差，因此已经是 Java 中的遗留容器。LinkedList 使用双向链表实现存 储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索 引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更 高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录项的前后项即可，所以插入速度较快。Vector 属于遗留容器（Java 早期的版本中 提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties 都是遗留容器），已经不推荐使用，但是由于 ArrayList 和 LinkedListed 都是非 线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类 Collections 中的 synchronizedList 方法将其转换成线程安全的容器后再使用（这是对装潢模式的应用，将已有对象传入另一个类的构造器中创建新的对象来增强实现）。</p><h2 id="54、Collection-和-Collections-的区别？"><a href="#54、Collection-和-Collections-的区别？" class="headerlink" title="54、Collection 和 Collections 的区别？"></a>54、Collection 和 Collections 的区别？</h2><p>答： Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一个 工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、 排序、线程安全化等等。</p><h2 id="55、List、Map、Set-三个接口存取元素时，各有什么特点？"><a href="#55、List、Map、Set-三个接口存取元素时，各有什么特点？" class="headerlink" title="55、List、Map、Set 三个接口存取元素时，各有什么特点？"></a>55、List、Map、Set 三个接口存取元素时，各有什么特点？</h2><p>List 以特定索引来存取元素，可以有重复元素。</p><p>Set 不能存放重复元素（用对象的 equals()方法来区分元素是否重复）。</p><p>Map 保存键值对（key-value pair）映射， 映射关系可以是一对一或多对一。</p><p>Set 和 Map 容器都有基于哈希存储和排序树的 两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树 版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达 到排序和去重的效果。</p><h2 id="56、TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？"><a href="#56、TreeMap-和-TreeSet-在排序时如何比较元素？-Collections-工具类中的-sort-方法如何比较元素？" class="headerlink" title="56、TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？"></a>56、TreeMap 和 TreeSet 在排序时如何比较元素？ Collections 工具类中的 sort()方法如何比较元素？</h2><p>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。</p><p>TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进行排序。</p><p>Collections 工具类的 sort 方法有两种重载的形式，第一种要求传入 的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是 Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java中对函数式编程的支持）。</p><h2 id="57、Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#57、Thread-类的-sleep-方法和对象的-wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="57、Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?"></a>57、Thread 类的 sleep()方法和对象的 wait()方法都可以让线程暂停执行，它们有什么区别?</h2><p>sleep()方法（休眠）是线程类（Thread）的静态方法，调用此方法会让当前线程暂停执行指定的时间，将执行机会（CPU）让给其他线程，但是对象的锁依然保持，因此休眠时间结束后会自动恢复。</p><p>wait()是 Object 类的方法，调用对象的 wait()方法导致当前线程放弃对象的锁（线程暂停执行），进入对象的等待池（wait pool），只有调用对象的notify()方法（或 notifyAll()方法）时才能唤醒等待池中的线程进入等锁池（lock pool），如果线程重新获得对象的锁就可以进入就绪状态。</p><h2 id="58、线程的-sleep-方法和-yield-方法有什么区别？"><a href="#58、线程的-sleep-方法和-yield-方法有什么区别？" class="headerlink" title="58、线程的 sleep()方法和 yield()方法有什么区别？"></a>58、线程的 sleep()方法和 yield()方法有什么区别？</h2><ul><li>sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会；</li><li>线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪（ready）状态；</li><li>sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常；</li><li>sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性。</li></ul><h2 id="59、当一个线程进入一个对象的-synchronized-方法A之后，-其它线程是否可进入此对象的-synchronized-方法B？"><a href="#59、当一个线程进入一个对象的-synchronized-方法A之后，-其它线程是否可进入此对象的-synchronized-方法B？" class="headerlink" title="59、当一个线程进入一个对象的 synchronized 方法A之后， 其它线程是否可进入此对象的 synchronized 方法B？"></a>59、当一个线程进入一个对象的 synchronized 方法A之后， 其它线程是否可进入此对象的 synchronized 方法B？</h2><p>不能。其它线程只能访问该对象的非同步方法，同步方法则不能进入。因为非静态方法上的 synchronized 修饰符要求执行方法时要获得对象的锁，如果已经进入A方法说明对象锁已经被取走，那么试图进入B方法的线程就只能在等锁池（注意不是等待池）中等待对象的锁。</p><h2 id="68、Java-中如何实现序列化，有什么意义？"><a href="#68、Java-中如何实现序列化，有什么意义？" class="headerlink" title="68、Java 中如何实现序列化，有什么意义？"></a>68、Java 中如何实现序列化，有什么意义？</h2><p>序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。 序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现 Serializable 接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过 writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过 readObject 方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆。</p><h2 id="69、Java-中有几种类型的流？"><a href="#69、Java-中有几种类型的流？" class="headerlink" title="69、Java 中有几种类型的流？"></a>69、Java 中有几种类型的流？</h2><p>字节流和字符流。字节流继承于 InputStream、OutputStream，字符流继承Reader、Writer。在 <a target="_blank" rel="noopener" href="http://java.io/">java.io</a> 包中还有许多其他的流，主要是为了提高性能和使用方便。关于 Java 的 I&#x2F;O 需要注意的有两点：一是两种对称性（输入和输出的对 称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。</p><h2 id="73、XML-文档定义有几种形式？它们之间有何本质区别？解析-XML-文档有哪几种方式？"><a href="#73、XML-文档定义有几种形式？它们之间有何本质区别？解析-XML-文档有哪几种方式？" class="headerlink" title="73、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？"></a>73、XML 文档定义有几种形式？它们之间有何本质区别？解析 XML 文档有哪几种方式？</h2><ul><li><p>XML 文档定义分为 DTD 和 Schema 两种形式，二者都是对 XML 语法的约束。</p><p>其本质区别在于 Schema 本身也是一个 XML 文件，可以被 XML 解析器解析，而且 可以为 XML 承载的数据定义类型，约束能力较之 DTD 更强大。</p></li><li><p>对 XML 的解析主 要有 DOM（文档对象模型，Document Object Model）、SAX（Simple API foXML）和 StAX（Java 6 中引入的新的解析 XML 的方式，Streaming API for XML）。</p><ul><li><p>其中 DOM 处理大型文件时其性能下降的非常厉害，这个问题是由 DOM 树结构用的内存较多造成的，而且 DOM 解析方式必须在解析文件之前把整个文档装入内存，适合对 XML 的随机访问（典型的用空间换取时间的策略）。</p></li><li><p>SAX 是事件驱动型的 XML 解析方式，它顺序读取 XML 文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件， 用户通过事件回调代码来处理 XML 文件，适合对 XML 的顺序访问。</p></li><li><p>顾名思义， StAX 把重点放在流上，实际上 StAX 与其他解析方式的本质区别就在于应用程能够把 XML 作为一个事件流来处理。将 XML 作为一组事件来处理的想法并不新颖（SAX 就是这样做的），但不同之处在于 StAX 允许应用程序代码把这些事件逐个拉出来，而不用提供在解析器方便时从解析器中接收事件的处理程序。</p></li></ul></li></ul><h2 id="75、阐述-JDBC-操作数据库的步骤。"><a href="#75、阐述-JDBC-操作数据库的步骤。" class="headerlink" title="75、阐述 JDBC 操作数据库的步骤。"></a>75、阐述 JDBC 操作数据库的步骤。</h2><ol><li>加载驱动。</li><li>创建连接。</li><li>创建语句。</li><li>执行语句。</li><li>处理结果。</li><li>关闭资源。</li></ol><p>关闭外部资源的顺序应该和打开的顺序相反，也就是说先关闭 ResultSet、 再关闭 Statement、在关闭 Connection。上面的代码只关闭了 Connection，虽然通常情况下在关闭连接时，连接上创建的语句和打开的游标也会关闭，但不能保证总是如此，因此应该按照刚才说的顺序分别关闭。此外，第一步加载驱动在 JDBC 4.0 中是可以省略的（自动从类路径中加载驱动），但是我们建议保留。</p><h2 id="76、Statement-和-PreparedStatement-有什么区别？哪个性能更好？"><a href="#76、Statement-和-PreparedStatement-有什么区别？哪个性能更好？" class="headerlink" title="76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？"></a>76、Statement 和 PreparedStatement 有什么区别？哪个性能更好？</h2><ol><li>PreparedStatement 接口代表预编译的语句，它主要的优势在于可以减少 SQL 的编译错误并增加 SQL 的安全性（减少 SQL 注射攻击的可 能性）；</li><li>PreparedStatement 中的 SQL 语句是可以带参数的，避免了用字符串连接拼接 SQL 语句的麻烦和不安全；</li><li>当批量处理 SQL 或频繁执行相同的查询时， PreparedStatement 有明显的性能上的优势，由于数据库可以将编译优化后的 SQL 语句缓存起来，下次执行相同结构的语句时就会很快（不用再次编译和生成执行计划）。</li></ol><p>补充：为了提供对存储过程的调用，JDBC API 中还提供了 CallableStatement 接 口。存储过程（Stored Procedure）是数据库中一组为了完成特定功能的 SQL 语句的集合，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数 （如果该存储过程带有参数）来执行它。虽然调用存储过程会在网络开销、安全性、性能上获得很多好处，但是存在如果底层数据库发生迁移时就会有很多麻烦， 因为每种数据库的存储过程在书写上存在不少的差别。</p><h2 id="77、使用-JDBC-操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"><a href="#77、使用-JDBC-操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？" class="headerlink" title="77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？"></a>77、使用 JDBC 操作数据库时，如何提升读取数据的性能？如何提升更新数据的性能？</h2><p>要提升读取数据的性能，可以指定通过结果集（ResultSet）对象的 setFetchSize()方法指定每次抓取的记录数（典型的空间换时间策略）</p><p>要提升更新数据的性能 可以使用 PreparedStatement 语句构建批处理，将若干 SQL 语句置于一个批处理中执行。</p><h2 id="78、在进行数据库编程时，连接池有什么作用？"><a href="#78、在进行数据库编程时，连接池有什么作用？" class="headerlink" title="78、在进行数据库编程时，连接池有什么作用？"></a>78、在进行数据库编程时，连接池有什么作用？</h2><p>由于创建连接和释放连接都有很大的开销（尤其是数据库服务器不在本地时，每次建立连接都需要进行 TCP 的三次握手，释放连接需要进行 TCP 四次握手，造成的开销是不可忽视的），为了提升系统访问数据库的性能，可以事先创建若干连接置于连接池中，需要时直接从连接池获取，使用结束时归还连接池而不必关闭连接，从而避免频繁创建和释放连接所造成的开销，这是典型的用空间换取时间的策略（浪费了空间存储连接，但节省了创建和释放连接的时间）。池化技术在 Java 开发中是很常见的，在使用线程时创建线程池的道理与此相同。基于 Java 的 开源数据库连接池主要有：C3P0、Proxool、DBCP、BoneCP、Druid 等</p><p>补充：在计算机系统中时间和空间是不可调和的矛盾，理解这一点对设计满足性能要求的算法是至关重要的。大型网站性能优化的一个关键就是使用缓存，而缓存跟上面讲的连接池道理非常类似，也是使用空间换时间的策略。可以将热点数据置于缓存中，当用户查询这些数据时可以直接从缓存中得到，这无论如何也快过去数据库中查询。当然，缓存的置换策略等也会对系统性能产生重要影响，对于这个问题的讨论已经超出了这里要阐述的范围。</p><h2 id="79、什么是-DAO-模式？"><a href="#79、什么是-DAO-模式？" class="headerlink" title="79、什么是 DAO 模式？"></a>79、什么是 DAO 模式？</h2><p>DAO（Data Access Object）顾名思义是一个为数据库或其他持久化机制提供了抽象接口的对象，在不暴露底层持久化方案实现细节的前提下提供了各种数据访问操作。</p><p>在实际的开发中，应该将所有对数据源的访问操作进行抽象化后封装在一个公共 API 中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。</p><p>DAO 模式实际上包含了两个模式，一是 Data Accessor（数据访问器），二是 Data Object（数据对象），前者要解决如何访问数据的问题，而后者要解决的是如何用对象封装数据。</p><h2 id="81、JDBC-中如何进行事务处理？"><a href="#81、JDBC-中如何进行事务处理？" class="headerlink" title="81、JDBC 中如何进行事务处理？"></a>81、JDBC 中如何进行事务处理？</h2><p>Connection 提供了事务处理的方法，通过调用 setAutoCommit(false)可以设置手动提交事务；当事务完成后用 commit()显式提交事务；如果在事务处理过程中发生异常则通过 rollback()进行事务回滚。除此之外，从 JDBC 3.0 中还引入了 Savepoint（保存点）的概念，允许通过代码设置保存点并让事务回滚到指定的保存点。</p><img src="/posts/1f03d757/117.jpg" srcset="/img/loading.gif" lazyload><h2 id="82、JDBC-能否处理-Blob-和-Clob？"><a href="#82、JDBC-能否处理-Blob-和-Clob？" class="headerlink" title="82、JDBC 能否处理 Blob 和 Clob？"></a>82、JDBC 能否处理 Blob 和 Clob？</h2><p>答： Blob 是指二进制大对象（Binary Large Object），而 Clob 是指大字符对象（Character Large Object），因此其中 Blob 是为存储大的二进制数据而设计的，而 Clob 是为存储大的文本数据而设计的。JDBC 的 PreparedStatement 和 ResultSet 都提供了相应的方法来支持 Blob 和 Clob 操作。</p><h2 id="85、获得一个类的类对象有哪些方式？"><a href="#85、获得一个类的类对象有哪些方式？" class="headerlink" title="85、获得一个类的类对象有哪些方式？"></a>85、获得一个类的类对象有哪些方式？</h2><ul><li>方法 1：类型.class，例如：String.class</li><li>方法 2：对象<code>.getClass()</code>，例如：<code>”hello”.getClass()</code></li><li>方法 3：<code>Class.forName()</code>，例如：<code>Class.forName(“java.lang.String”)</code></li></ul><h2 id="86、如何通过反射创建对象？"><a href="#86、如何通过反射创建对象？" class="headerlink" title="86、如何通过反射创建对象？"></a>86、如何通过反射创建对象？</h2><ul><li>方法 1：通过类对象调用 newInstance()方法，例如： String.class.newInstance()</li><li>方法 2：通过类对象的 getConstructor()或 getDeclaredConstructor() 方法获得构造器（Constructor）对象并调用其 newInstance()方法创建对象， 例如：<code>String.class.getConstructor(String.class).newInstance(“Hello”);</code></li></ul><h2 id="87、Java-中能创建-volatile-数组吗？"><a href="#87、Java-中能创建-volatile-数组吗？" class="headerlink" title="87、Java 中能创建 volatile 数组吗？"></a>87、Java 中能创建 volatile 数组吗？</h2><p>能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。</p><h2 id="88、volatile-能使得一个非原子操作变成原子操作吗？"><a href="#88、volatile-能使得一个非原子操作变成原子操作吗？" class="headerlink" title="88、volatile 能使得一个非原子操作变成原子操作吗？"></a>88、volatile 能使得一个非原子操作变成原子操作吗？</h2><p>一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。</p><h2 id="89、volatile-修饰符的有过什么实践？"><a href="#89、volatile-修饰符的有过什么实践？" class="headerlink" title="89、volatile 修饰符的有过什么实践？"></a>89、volatile 修饰符的有过什么实践？</h2><p>一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是 64 位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。</p><p>简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（writebarrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。</p><h2 id="90、volatile-类型变量提供什么保证？"><a href="#90、volatile-类型变量提供什么保证？" class="headerlink" title="90、volatile 类型变量提供什么保证？"></a>90、volatile 类型变量提供什么保证？</h2><p>volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT 为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。</p><h2 id="91、10-个线程和-2-个线程的同步代码，哪个更容易写？"><a href="#91、10-个线程和-2-个线程的同步代码，哪个更容易写？" class="headerlink" title="91、10 个线程和 2 个线程的同步代码，哪个更容易写？"></a>91、10 个线程和 2 个线程的同步代码，哪个更容易写？</h2><p>从写代码的角度来说，两者的复杂度是相同的，因为同步代码与线程数量是相互独立的。但是同步策略的选择依赖于线程的数量，因为越多的线程意味着更大的竞争，所以你需要利用同步技术，如锁分离，这要求更复杂的代码和专业知识。</p><h2 id="92、你是如何调用-wait（）方法的？使用-if-块还是循环？为什么？"><a href="#92、你是如何调用-wait（）方法的？使用-if-块还是循环？为什么？" class="headerlink" title="92、你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？"></a>92、你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？</h2><p>wait() 方法应该在循环调用，因为当线程获取到 CPU 开始执行的时候，其他条件可能还没有满足，所以在处理前，循环检测条件是否满足会更好。下面是一段标准的使用 wait 和 notify 方法的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// The standard idiom for using the wait method</span><br><span class="hljs-keyword">synchronized</span> (obj) &#123;<br>	<span class="hljs-keyword">while</span> (condition does not hold)<br>	obj.wait();<br>	<span class="hljs-comment">// (Releases lock, and reacquires on wakeup)</span><br>	... <span class="hljs-comment">// Perform action appropriate to condition</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="93、什么是多线程环境下的伪共享（false-sharing）？"><a href="#93、什么是多线程环境下的伪共享（false-sharing）？" class="headerlink" title="93、什么是多线程环境下的伪共享（false sharing）？"></a>93、什么是多线程环境下的伪共享（false sharing）？</h2><p>伪共享是多线程系统（每个处理器有自己的局部缓存）中一个众所周知的性能问题。伪共享发生在不同处理器的上的线程对变量的修改依赖于相同的缓存行。</p><h2 id="94、什么是-Busy-spin？我们为什么要使用它？"><a href="#94、什么是-Busy-spin？我们为什么要使用它？" class="headerlink" title="94、什么是 Busy spin？我们为什么要使用它？"></a>94、什么是 Busy spin？我们为什么要使用它？</h2><p>Busy spin 是一种在不释放 CPU 的基础上等待事件的技术。它经常用于避免丢失 CPU 缓存中的数据（如果线程先暂停，之后在其他 CPU 上运行就会丢失）。所以，如果你的工作要求低延迟，并且你的线程目前没有任何顺序，这样你就可以通过循环检测队列中的新消息来代替调用 sleep() 或 wait() 方法。它唯一的好处就是你只需等待很短的时间，如几微秒或几纳秒。LMAX 分布式框架是一个高性能线程间通信的库，该库有一个 BusySpinWaitStrategy 类就是基于这个概念实现的，使用 busy spin 循环 EventProcessors 等待屏障。</p><h2 id="95、Java-中怎么获取一份线程-dump-文件？"><a href="#95、Java-中怎么获取一份线程-dump-文件？" class="headerlink" title="95、Java 中怎么获取一份线程 dump 文件？"></a>95、Java 中怎么获取一份线程 dump 文件？</h2><p>在 Linux 下，你可以通过命令 kill -3 PID （Java 进程的进程 ID）来获取 Java应用的 dump 文件。在 Windows 下，你可以按下 Ctrl + Break 来获取。这样 JVM 就会将线程的 dump 文件打印到标准输出或错误文件中，它可能打印在控制台或者日志文件中，具体位置依赖应用的配置。如果你使用 Tomcat。</p><h2 id="96、Swing-是线程安全的？"><a href="#96、Swing-是线程安全的？" class="headerlink" title="96、Swing 是线程安全的？"></a>96、Swing 是线程安全的？</h2><p>不是，Swing 不是线程安全的。你不能通过任何线程来更新 Swing 组件，如JTable、JList 或 JPanel，事实上，它们只能通过 GUI 或 AWT 线程来更新。这就是为什么 Swing供 invokeAndWait() 和 invokeLater() 方法来获取其他线程的 GUI 更新请求。这些方法将更新请求放入 AWT 的线程队列中，可以一直等待，也可以通过异步更新直接返回结果。</p><h2 id="97、什么是线程局部变量？"><a href="#97、什么是线程局部变量？" class="headerlink" title="97、什么是线程局部变量？"></a>97、什么是线程局部变量？</h2><p>线程局部变量是局限于线程内部的变量，属于线程自身所有，不在多个线程间共享。Java 提供 ThreadLocal 类来支持线程局部变量，是一种实现线程安全的方式。但是在管理环境下（如 web 服务器）使用线程局部变量的时候要特别小心，在这种情况下，工作线程的生命周期比任何应用变量的生命周期都要长。任何线程局部变量一旦在工作完成后没有释放，Java 应用就存在内存泄露的风险。</p><h2 id="98、用-wait-notify-写一段代码来解决生产者-消费者问题？"><a href="#98、用-wait-notify-写一段代码来解决生产者-消费者问题？" class="headerlink" title="98、用 wait-notify 写一段代码来解决生产者-消费者问题？"></a>98、用 wait-notify 写一段代码来解决生产者-消费者问题？</h2><p>只要记住在同步块中调用 wait() 和 notify() 方法 ，如果阻塞，通过循环来测试等待条件。</p><h2 id="99、用-Java-写一个线程安全的单例模式（Singleton）？"><a href="#99、用-Java-写一个线程安全的单例模式（Singleton）？" class="headerlink" title="99、用 Java 写一个线程安全的单例模式（Singleton）？"></a>99、用 Java 写一个线程安全的单例模式（Singleton）？</h2><p>一步一步创建一个线程安全的 Java 单例类。当我们说线程安全时，意思是即使初始化是在多线程环境中，仍然能保证单个实例。Java 中，使用枚举作为单例类是最简单的方式来创建线程安全单例模式的方式。</p><h2 id="100、Java-中-sleep-方法和-wait-方法的区别？"><a href="#100、Java-中-sleep-方法和-wait-方法的区别？" class="headerlink" title="100、Java 中 sleep 方法和 wait 方法的区别？"></a>100、Java 中 sleep 方法和 wait 方法的区别？</h2><p>虽然两者都是用来暂停当前运行的线程，但是 sleep() 实际上只是短暂停顿，因为它不会释放锁，而 wait() 意味着条件等待，这就是为什么该方法要释放锁，因为只有这样，其他等待的线程才能在满足条件时获取到该锁。</p><h2 id="101、什么是不可变对象（immutable-object）？Java-中怎么创建一个不可变对象？"><a href="#101、什么是不可变对象（immutable-object）？Java-中怎么创建一个不可变对象？" class="headerlink" title="101、什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？"></a>101、什么是不可变对象（immutable object）？Java 中怎么创建一个不可变对象？</h2><p>不可变对象指对象一旦被创建，状态就不能再改变。任何修改都会创建一个新的对象，如 String、Integer 及其它包装类。</p><h2 id="102、我们能创建一个包含可变对象的不可变对象吗？"><a href="#102、我们能创建一个包含可变对象的不可变对象吗？" class="headerlink" title="102、我们能创建一个包含可变对象的不可变对象吗？"></a>102、我们能创建一个包含可变对象的不可变对象吗？</h2><p>是的，我们是可以创建一个包含可变对象的不可变对象的，你只需要谨慎一点，不要共享可变对象的引用就可以了，如果需要变化时，就返回原对象的一个拷贝。最常见的例子就是对象中包含一个日期对象的引用。数据类型和 Java 基础面试问题</p><h2 id="103、Java-中应该使用什么数据类型来代表价格？"><a href="#103、Java-中应该使用什么数据类型来代表价格？" class="headerlink" title="103、Java 中应该使用什么数据类型来代表价格？"></a>103、Java 中应该使用什么数据类型来代表价格？</h2><p>如果不是特别关心内存和性能的话，使用 BigDecimal，否则使用预定义精度的double 类型。</p><h2 id="103、怎么将-byte-转换为-String？"><a href="#103、怎么将-byte-转换为-String？" class="headerlink" title="103、怎么将 byte 转换为 String？"></a>103、怎么将 byte 转换为 String？</h2><p>可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。</p><h2 id="104、Java-中怎样将-bytes-转换为-long-类型？"><a href="#104、Java-中怎样将-bytes-转换为-long-类型？" class="headerlink" title="104、Java 中怎样将 bytes 转换为 long 类型？"></a>104、Java 中怎样将 bytes 转换为 long 类型？</h2><p>bytes[] 到数字类型的转换是个经常用到的代码,解决方式也不止一种。</p><p><strong>java代码实现</strong></p><p>如果不想借助任何已经有的类，完全可以自己实现这段代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将字节数组转为long&lt;br&gt;</span><br><span class="hljs-comment"> * 如果input为null,或offset指定的剩余数组长度不足8字节则抛出异常</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> input</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> offset       起始偏移量</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> littleEndian 输入数组是否小端模式</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">longFrom8Bytes</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] input, <span class="hljs-type">int</span> offset, Boolean littleEndian)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 循环读取每个字节通过移位运算完成long的8个字节拼装</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; count &lt; <span class="hljs-number">8</span>; ++count) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">shift</span> <span class="hljs-operator">=</span> (littleEndian ? count : (<span class="hljs-number">7</span> - count)) &lt;&lt; <span class="hljs-number">3</span>;<br>        value |= ((<span class="hljs-type">long</span>) <span class="hljs-number">0xff</span> &lt;&lt; shift) &amp; ((<span class="hljs-type">long</span>) input[offset + count] &lt;&lt; shift);<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>借助java.nio.ByteBuffer实现</strong></p><p>java.nio.ByteBuffer 本身就有getLong、getInt，getFloat….方法，只要将byte[]转换为ByteBuffer就可以实现所有primitive类型的数据读取，参见javadoc。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 利用 &#123;<span class="hljs-doctag">@link</span> java.nio.ByteBuffer&#125;实现byte[]转long</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> input</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> offset </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> littleEndian 输入数组是否小端模式</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">bytesTolong</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] input, <span class="hljs-type">int</span> offset, Boolean littleEndian)</span> &#123;<br>	<span class="hljs-comment">// 将byte[] 封装为 ByteBuffer </span><br>	<span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(input,offset,<span class="hljs-number">8</span>);<br>	<span class="hljs-keyword">if</span>(littleEndian)&#123;<br>		<span class="hljs-comment">// ByteBuffer.order(ByteOrder) 方法指定字节序,即大小端模式(BIG_ENDIAN/LITTLE_ENDIAN)</span><br>		<span class="hljs-comment">// ByteBuffer 默认为大端(BIG_ENDIAN)模式 </span><br>		buffer.order(ByteOrder.LITTLE_ENDIAN);<br>	&#125;<br>	<span class="hljs-keyword">return</span> buffer.getlong();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>借助java.io.DataInputStream实现</strong></p><p>java.io.DataInputStream 同样提供了 readLong，readLong，readLong….方法，只要将byte[]转换为DataInputStream就可以实现所有primitive类型的数据读取,参见javadoc。</p><h2 id="105、我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？"><a href="#105、我们能将-int-强制转换为-byte-类型的变量吗？如果该值大于-byte-类型的范围，将会出现什么现象？" class="headerlink" title="105、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？"></a>105、我们能将 int 强制转换为 byte 类型的变量吗？如果该值大于 byte 类型的范围，将会出现什么现象？</h2><p>是的，我们可以做强制转换，但是 Java 中 int 是 32 位的，而 byte 是 8 位的，所以，如果强制转化是，int 类型的高 24 位将会被丢弃，byte 类型的范围是从 -128 到 127。</p><h2 id="106、存在两个类，B-继承-A，C-继承-B，我们能将-B-转换为C-么？如-C-x3D-C-B；"><a href="#106、存在两个类，B-继承-A，C-继承-B，我们能将-B-转换为C-么？如-C-x3D-C-B；" class="headerlink" title="106、存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为C 么？如 C &#x3D; (C) B；"></a>106、存在两个类，B 继承 A，C 继承 B，我们能将 B 转换为C 么？如 C &#x3D; (C) B；</h2><p>这属于强制类型转换，如果被转换的B实例不是C类型，会有异常</p><p>比如你的ABC分别对应动物，猫，黑猫。</p><p>向上转型就是比如</p><p>C c &#x3D; new C();</p><p>B b &#x3D; c;</p><p>你把c转型为B，黑猫是猫吗？是啊，所以这是ok的。</p><p>但是反过来</p><p>B b &#x3D; new B();</p><p>C c &#x3D; (C)b;</p><p>这就不ok了，只知道这个b是一只猫，他不一定是黑猫。</p><p>但如果这个b已经确定是一只黑猫了，那就可以转型了</p><p>B b &#x3D; new C();</p><p>C c &#x3D; (C)b;</p><p>这里的b本来就是黑猫啊。</p><h2 id="107、哪个类包含-clone-方法？是-Cloneable-还是-Object？"><a href="#107、哪个类包含-clone-方法？是-Cloneable-还是-Object？" class="headerlink" title="107、哪个类包含 clone 方法？是 Cloneable 还是 Object？"></a>107、哪个类包含 clone 方法？是 Cloneable 还是 Object？</h2><p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p><h2 id="108、Java-中-操作符是线程安全的吗？"><a href="#108、Java-中-操作符是线程安全的吗？" class="headerlink" title="108、Java 中 ++ 操作符是线程安全的吗？"></a>108、Java 中 ++ 操作符是线程安全的吗？</h2><p>不是线程安全的操作。它涉及到多个指令，如读取变量值，增加，然后存储回内存，这个过程可能会出现多个线程交差。</p><h2 id="109、a-x3D-a-b-与-a-x3D-b-的区别"><a href="#109、a-x3D-a-b-与-a-x3D-b-的区别" class="headerlink" title="109、a &#x3D; a + b 与 a +&#x3D; b 的区别"></a>109、a &#x3D; a + b 与 a +&#x3D; b 的区别</h2><p>+&#x3D; 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>b = a + b;<br><span class="hljs-comment">// error : cannot convert from int to byte</span><br>b += a;<br><span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>（译者注：这个地方应该表述的有误，其实无论 a+b 的值为多少，编译器都会报错，因为 a+b 操作会将 a、b 提升为 int 类型，所以将 int 类型赋值给 byte就会编译出错）</p><h2 id="110、我能在不进行强制转换的情况下将一个-double-值赋值给-long-类型的变量吗？"><a href="#110、我能在不进行强制转换的情况下将一个-double-值赋值给-long-类型的变量吗？" class="headerlink" title="110、我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？"></a>110、我能在不进行强制转换的情况下将一个 double 值赋值给 long 类型的变量吗？</h2><p>不行，你不能在没有强制类型转换的前提下将一个 double 值赋值给 long 类型的变量，因为 double 类型的范围比 long 类型更广，所以必须要进行强制转换。</p><h2 id="111、3-0-1-x3D-x3D-0-3-将会返回什么？true-还是-false？"><a href="#111、3-0-1-x3D-x3D-0-3-将会返回什么？true-还是-false？" class="headerlink" title="111、3 * 0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？"></a>111、3 * 0.1 &#x3D;&#x3D; 0.3 将会返回什么？true 还是 false？</h2><p>false，因为有些浮点数不能完全精确的表示出来。</p><h2 id="112、int-和-Integer-哪个会占用更多的内存？"><a href="#112、int-和-Integer-哪个会占用更多的内存？" class="headerlink" title="112、int 和 Integer 哪个会占用更多的内存？"></a>112、int 和 Integer 哪个会占用更多的内存？</h2><p>Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。但是 int 是一个原始类型的数据，所以占用的空间更少。</p><h2 id="113、为什么-Java-中的-String-是不可变的（Immutable）？"><a href="#113、为什么-Java-中的-String-是不可变的（Immutable）？" class="headerlink" title="113、为什么 Java 中的 String 是不可变的（Immutable）？"></a>113、为什么 Java 中的 String 是不可变的（Immutable）？</h2><p>Java 中的 String 不可变是因为 Java 的设计者认为字符串使用非常频繁，将字符串设置为不可变可以允许多个客户端之间共享相同的字符串。</p><h2 id="114、我们能在-Switch-中使用-String-吗？"><a href="#114、我们能在-Switch-中使用-String-吗？" class="headerlink" title="114、我们能在 Switch 中使用 String 吗？"></a>114、我们能在 Switch 中使用 String 吗？</h2><p>从 Java 7 开始，我们可以在 switch case 中使用字符串，但这仅仅是一个语法糖。内部实现在 switch 中使用字符串的 hash code。</p><h2 id="115、Java-中的构造器链是什么？"><a href="#115、Java-中的构造器链是什么？" class="headerlink" title="115、Java 中的构造器链是什么？"></a>115、Java 中的构造器链是什么？</h2><p>当你从一个构造器中调用另一个构造器，就是 Java 中的构造器链。这种情况只在重载了类的构造器的时候才会出现。</p><h2 id="116、64-位-JVM-中，int-的长度是多数？"><a href="#116、64-位-JVM-中，int-的长度是多数？" class="headerlink" title="116、64 位 JVM 中，int 的长度是多数？"></a>116、64 位 JVM 中，int 的长度是多数？</h2><p>Java 中，int 类型变量的长度是一个固定值，与平台无关，都是 32 位。意思就是说，在32位和64位的java虚拟机中，int 类型的长度是相同的。</p><h2 id="117、Serial-与-Parallel-GC-之间的不同之处？"><a href="#117、Serial-与-Parallel-GC-之间的不同之处？" class="headerlink" title="117、Serial 与 Parallel GC 之间的不同之处？"></a>117、Serial 与 Parallel GC 之间的不同之处？</h2><p>Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。</p><h2 id="118、32-位和-64-位的-JVM，int-类型变量的长度是多数？"><a href="#118、32-位和-64-位的-JVM，int-类型变量的长度是多数？" class="headerlink" title="118、32 位和 64 位的 JVM，int 类型变量的长度是多数？"></a>118、32 位和 64 位的 JVM，int 类型变量的长度是多数？</h2><p>32 位和 64 位的 JVM 中，int 类型变量的长度是相同的，都是 32 位或者 4个字节。</p><h2 id="119、Java-中-WeakReference-与-SoftReference-的区别？"><a href="#119、Java-中-WeakReference-与-SoftReference-的区别？" class="headerlink" title="119、Java 中 WeakReference 与 SoftReference 的区别？"></a>119、Java 中 WeakReference 与 SoftReference 的区别？</h2><p>虽然 WeakReference 与 SoftReference 都有利于提高 GC 和 内存的效率，但是 WeakReference ，一旦失去最后一个强引用，就会被 GC 回收，而软引用虽然不能阻止被回收，但是可以延迟到 JVM 内存不足的时候。</p><h2 id="120、WeakHashMap-是怎么工作的？"><a href="#120、WeakHashMap-是怎么工作的？" class="headerlink" title="120、WeakHashMap 是怎么工作的？"></a>120、WeakHashMap 是怎么工作的？</h2><p>WeakHashMap 的工作与正常的 HashMap 类似，但是使用弱引用作为 key，意思就是当 key 对象没有任何引用时，key&#x2F;value 将会被回收。</p><h2 id="121、JVM-选项-XX-UseCompressedOops-有什么作用？为什么要使用？"><a href="#121、JVM-选项-XX-UseCompressedOops-有什么作用？为什么要使用？" class="headerlink" title="121、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？"></a>121、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用？</h2><p>当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM主要动机在于可以指定最大堆大小，通过压缩 OOP 可以节省一定的内存。通过-XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。</p><h2 id="122、怎样通过-Java-程序来判断-JVM-是-32-位-还是-64位？"><a href="#122、怎样通过-Java-程序来判断-JVM-是-32-位-还是-64位？" class="headerlink" title="122、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？"></a>122、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？</h2><p>你可以检查某些系统属性如 sun.arch.data.model 或 os.arch 来获取该信息。</p><h2 id="123、32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？"><a href="#123、32-位-JVM-和-64-位-JVM-的最大堆内存分别是多数？" class="headerlink" title="123、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？"></a>123、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？</h2><p>理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5 GB，Solaris 大约3GB。64 位 JVM 允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。</p><h2 id="124、JRE、JDK、JVM-及-JIT-之间有什么不同？"><a href="#124、JRE、JDK、JVM-及-JIT-之间有什么不同？" class="headerlink" title="124、JRE、JDK、JVM 及 JIT 之间有什么不同？"></a>124、JRE、JDK、JVM 及 JIT 之间有什么不同？</h2><p>JRE 代表 Java 运行 时（Java run-time），是 运 行 Java 引用所必须的。</p><p>JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java编译器，它也包含 JRE。</p><p>JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。</p><p>JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。</p><h2 id="125、解释-Java-堆空间及-GC？"><a href="#125、解释-Java-堆空间及-GC？" class="headerlink" title="125、解释 Java 堆空间及 GC？"></a>125、解释 Java 堆空间及 GC？</h2><p>当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。</p><h2 id="126、你能保证-GC-执行吗？"><a href="#126、你能保证-GC-执行吗？" class="headerlink" title="126、你能保证 GC 执行吗？"></a>126、你能保证 GC 执行吗？</h2><p>不能，虽然你可以调用 System.gc() 或者 Runtime.gc()，但是没有办法保证 GC的执行。</p><h2 id="127、怎么获取-Java-程序使用的内存？堆使用的百分比？"><a href="#127、怎么获取-Java-程序使用的内存？堆使用的百分比？" class="headerlink" title="127、怎么获取 Java 程序使用的内存？堆使用的百分比？"></a>127、怎么获取 Java 程序使用的内存？堆使用的百分比？</h2><p>可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。<code>Runtime.freeMemory()</code> 方法返回剩余空间的字节数，<code>Runtime.totalMemory()</code>方法总内存的字节数，<code>Runtime.maxMemory()</code> 返回最大内存的字节数。</p><h2 id="128、Java-中堆和栈有什么区别？"><a href="#128、Java-中堆和栈有什么区别？" class="headerlink" title="128、Java 中堆和栈有什么区别？"></a>128、Java 中堆和栈有什么区别？</h2><p>JVM 中堆和栈属于不同的内存区域，使用目的也不同。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。</p><h2 id="129、“a-x3D-x3D-b”和”a-equals-b-”有什么区别？"><a href="#129、“a-x3D-x3D-b”和”a-equals-b-”有什么区别？" class="headerlink" title="129、“a &#x3D;&#x3D; b”和”a.equals(b)”有什么区别？"></a>129、“a &#x3D;&#x3D; b”和”a.equals(b)”有什么区别？</h2><p>如果 a 和 b 都是对象，则 a&#x3D;&#x3D;b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。</p><h2 id="130、a-hashCode-有什么用？与-a-equals-b-有什么关系？"><a href="#130、a-hashCode-有什么用？与-a-equals-b-有什么关系？" class="headerlink" title="130、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？"></a>130、a.hashCode() 有什么用？与 a.equals(b) 有什么关系？</h2><p>hashCode() 方法是相应对象整型的 hash 值。它常用于基于 hash 的集合类，如 Hashtable、HashMap、LinkedHashMap 等等。它与 equals() 方法关系特别紧密。根据 Java 规范，两个使用 equal() 方法来判断相等的对象，必须具有相同的 hash code。</p><h2 id="131、final、finalize-和-finally-的不同之处？"><a href="#131、final、finalize-和-finally-的不同之处？" class="headerlink" title="131、final、finalize 和 finally 的不同之处？"></a>131、final、finalize 和 finally 的不同之处？</h2><p>final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。</p><h2 id="132、Java-中的编译期常量是什么？使用它又什么风险？"><a href="#132、Java-中的编译期常量是什么？使用它又什么风险？" class="headerlink" title="132、Java 中的编译期常量是什么？使用它又什么风险？"></a>132、Java 中的编译期常量是什么？使用它又什么风险？</h2><p>公共静态不可变（public static final ）变量也就是我们所说的编译期常量，这里的 public 可选的。实际上这些变量在编译时会被替换掉，因为编译器知道这些变量的值，并且知道这些变量在运行时不能改变。这种方式存在的一个问题是你使用了一个内部的或第三方库中的公有编译时常量，但是这个值后面被其他人改变了，但是你的客户端仍然在使用老的值，甚至你已经部署了一个新的 jar。为了避免这种情况，当你在更新依赖 JAR 文件时，确保重新编译你的程序。</p><h2 id="133、poll-方法和-remove-方法的区别？"><a href="#133、poll-方法和-remove-方法的区别？" class="headerlink" title="133、poll() 方法和 remove() 方法的区别？"></a>133、poll() 方法和 remove() 方法的区别？</h2><p>poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。</p><h2 id="134、Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？"><a href="#134、Java-中-LinkedHashMap-和-PriorityQueue-的区别是什么？" class="headerlink" title="134、Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？"></a>134、Java 中 LinkedHashMap 和 PriorityQueue 的区别是什么？</h2><p>PriorityQueue 保证最高或者最低优先级的的元素总是在队列头部，但是LinkedHashMap 维持的顺序是元素插入的顺序。当遍历一个 PriorityQueue 时，没有任何顺序保证，但是 LinkedHashMap 课保证遍历顺序是元素插入的顺序。</p><h2 id="135、ArrayList-与-LinkedList-的区别？"><a href="#135、ArrayList-与-LinkedList-的区别？" class="headerlink" title="135、ArrayList 与 LinkedList 的区别？"></a>135、ArrayList 与 LinkedList 的区别？</h2><p>最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。</p><h2 id="136、用哪两种方式来实现集合的排序？"><a href="#136、用哪两种方式来实现集合的排序？" class="headerlink" title="136、用哪两种方式来实现集合的排序？"></a>136、用哪两种方式来实现集合的排序？</h2><p>你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。</p><h2 id="137、Java-中怎么打印数组？"><a href="#137、Java-中怎么打印数组？" class="headerlink" title="137、Java 中怎么打印数组？"></a>137、Java 中怎么打印数组？</h2><p>你可以使用 Arrays.toString() 和 Arrays.deepToString() 方法来打印数组。由于数组没有实现 toString() 方法，所以如果将数组传递给 System.out.println()方法，将无法打印出数组的内容，但是 Arrays.toString() 可以打印每个元素。</p><h2 id="138、Java-中的-LinkedList-是单向链表还是双向链表？"><a href="#138、Java-中的-LinkedList-是单向链表还是双向链表？" class="headerlink" title="138、Java 中的 LinkedList 是单向链表还是双向链表？"></a>138、Java 中的 LinkedList 是单向链表还是双向链表？</h2><p>是双向链表，你可以检查 JDK 的源码。</p><h2 id="139、Java-中的-TreeMap-是采用什么树实现的？"><a href="#139、Java-中的-TreeMap-是采用什么树实现的？" class="headerlink" title="139、Java 中的 TreeMap 是采用什么树实现的？"></a>139、Java 中的 TreeMap 是采用什么树实现的？</h2><p>Java 中的 TreeMap 是使用红黑树实现的。</p><h2 id="140、Hashtable-与-HashMap-有什么不同之处？"><a href="#140、Hashtable-与-HashMap-有什么不同之处？" class="headerlink" title="140、Hashtable 与 HashMap 有什么不同之处？"></a>140、Hashtable 与 HashMap 有什么不同之处？</h2><p>这两个类有许多不同的地方，下面列出了一部分：</p><p>a) Hashtable 是 JDK 1 遗留下来的类，而 HashMap 是后来增加的。</p><p>b）Hashtable 是同步的，比较慢，但 HashMap 没有同步策略，所以会更快。</p><p>c）Hashtable 不允许有个空的 key，但是 HashMap 允许出现一个 null key。</p><h2 id="141、Java-中的-HashSet，内部是如何工作的？"><a href="#141、Java-中的-HashSet，内部是如何工作的？" class="headerlink" title="141、Java 中的 HashSet，内部是如何工作的？"></a>141、Java 中的 HashSet，内部是如何工作的？</h2><p>HashSet 的内部采用 HashMap 来实现。由于 Map 需要 key 和 value，所以所有 key 的都有一个默认 value。类似于 HashMap，HashSet 不允许重复的key，只允许有一个 null key，意思就是 HashSet 中只允许存储一个 null 对象。</p><h2 id="142、写一段代码在遍历-ArrayList-时移除一个元素？"><a href="#142、写一段代码在遍历-ArrayList-时移除一个元素？" class="headerlink" title="142、写一段代码在遍历 ArrayList 时移除一个元素？"></a>142、写一段代码在遍历 ArrayList 时移除一个元素？</h2><p>该问题的关键在于面试者使用的是 ArrayList 的 remove() 还是 Iterator 的remove()方法。这有一段示例代码，是使用正确的方式来实现在遍历的过程中移除元素，而不会出现 ConcurrentModificationException 异常的示例代码。</p><h2 id="143、我们能自己写一个容器类，然后使用-for-each-循环码？"><a href="#143、我们能自己写一个容器类，然后使用-for-each-循环码？" class="headerlink" title="143、我们能自己写一个容器类，然后使用 for-each 循环码？"></a>143、我们能自己写一个容器类，然后使用 for-each 循环码？</h2><p>可以，你可以写一个自己的容器类。如果你想使用 Java 中增强的循环来遍历，你只需要实现 Iterable 接口。如果你实现 Collection 接口，默认就具有该属性。</p><h2 id="144、ArrayList-和-HashMap-的默认大小是多数？"><a href="#144、ArrayList-和-HashMap-的默认大小是多数？" class="headerlink" title="144、ArrayList 和 HashMap 的默认大小是多数？"></a>144、ArrayList 和 HashMap 的默认大小是多数？</h2><p>在 Java 7 中，ArrayList 的默认大小是 10 个元素，HashMap 的默认大小是16 个元素（必须是 2 的幂）。这就是 Java 7 中 ArrayList 和 HashMap 类的代码片段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// from ArrayList.java JDK 1.7</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//from HashMap.java JDK 7</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><span class="hljs-comment">// aka 16</span><br></code></pre></td></tr></table></figure><h2 id="145、有没有可能两个不相等的对象有有相同的-hashcode？"><a href="#145、有没有可能两个不相等的对象有有相同的-hashcode？" class="headerlink" title="145、有没有可能两个不相等的对象有有相同的 hashcode？"></a>145、有没有可能两个不相等的对象有有相同的 hashcode？</h2><p>有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的 hashcode 值，但是没有关于不相等对象的任何规定。</p><h2 id="146、两个相同的对象会有不同的的-hash-code-吗？"><a href="#146、两个相同的对象会有不同的的-hash-code-吗？" class="headerlink" title="146、两个相同的对象会有不同的的 hash code 吗？"></a>146、两个相同的对象会有不同的的 hash code 吗？</h2><p>不能，根据 hash code 的规定，这是不可能的。</p><h2 id="147、我们可以在-hashcode-中使用随机数字吗？"><a href="#147、我们可以在-hashcode-中使用随机数字吗？" class="headerlink" title="147、我们可以在 hashcode() 中使用随机数字吗？"></a>147、我们可以在 hashcode() 中使用随机数字吗？</h2><p>不行，因为对象的 hashcode 值必须是相同的。参见答案获取更多关于 Java 中重写 hashCode() 方法的知识。</p><h2 id="148、Java-中，Comparator-与-Comparable-有什么不同？"><a href="#148、Java-中，Comparator-与-Comparable-有什么不同？" class="headerlink" title="148、Java 中，Comparator 与 Comparable 有什么不同？"></a>148、Java 中，Comparator 与 Comparable 有什么不同？</h2><p>Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。</p><p>Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。</p><h2 id="149、为什么在重写-equals-方法的时候需要重写-hashCode-方法？"><a href="#149、为什么在重写-equals-方法的时候需要重写-hashCode-方法？" class="headerlink" title="149、为什么在重写 equals 方法的时候需要重写 hashCode 方法？"></a>149、为什么在重写 equals 方法的时候需要重写 hashCode 方法？</h2><p>因为有强制的规范指定需要同时重写 hashcode 与 equal 是方法，许多容器类，如 HashMap、HashSet 都依赖于 hashcode 与 equals 的规定。</p><h2 id="150、在我-Java-程序中，我有三个-socket，我需要多少个线程来处理？"><a href="#150、在我-Java-程序中，我有三个-socket，我需要多少个线程来处理？" class="headerlink" title="150、在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？"></a>150、在我 Java 程序中，我有三个 socket，我需要多少个线程来处理？</h2><p>这个需要看你是并行处理还是串行处理了。</p><h2 id="151、Java-中怎么创建-ByteBuffer？"><a href="#151、Java-中怎么创建-ByteBuffer？" class="headerlink" title="151、Java 中怎么创建 ByteBuffer？"></a>151、Java 中怎么创建 ByteBuffer？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">10</span>];<br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(bytes);<br></code></pre></td></tr></table></figure><h2 id="152、Java-中，怎么读写-ByteBuffer-？"><a href="#152、Java-中，怎么读写-ByteBuffer-？" class="headerlink" title="152、Java 中，怎么读写 ByteBuffer ？"></a>152、Java 中，怎么读写 ByteBuffer ？</h2><h2 id="153、Java-采用的是大端还是小端？"><a href="#153、Java-采用的是大端还是小端？" class="headerlink" title="153、Java 采用的是大端还是小端？"></a>153、Java 采用的是大端还是小端？</h2><h2 id="154、ByteBuffer-中的字节序是什么？"><a href="#154、ByteBuffer-中的字节序是什么？" class="headerlink" title="154、ByteBuffer 中的字节序是什么？"></a>154、ByteBuffer 中的字节序是什么？</h2><p>ByteBuffer类中的order(ByteOrder bo) 方法可以设置 ByteBuffer 的字节序。</p><p>其中的ByteOrder是枚举：</p><p>ByteOrder BIG_ENDIAN 代表大字节序的 ByteOrder 。</p><p>ByteOrder LITTLE_ENDIAN 代表小字节序的 ByteOrder 。</p><p>ByteOrder nativeOrder() 返回当前硬件平台的字节序。</p><h2 id="155、Java-中，直接缓冲区与非直接缓冲器有什么区别？"><a href="#155、Java-中，直接缓冲区与非直接缓冲器有什么区别？" class="headerlink" title="155、Java 中，直接缓冲区与非直接缓冲器有什么区别？"></a>155、Java 中，直接缓冲区与非直接缓冲器有什么区别？</h2><p>非直接缓冲区：通过allocate()分配缓冲区，将缓冲区建立在JVM的内存中</p><p>直接缓冲区：通过allocateDirect()分配直接缓冲区，将缓冲区建立在物理内存中，可以提高效率</p><h2 id="156、Java-中的内存映射缓存区是什么？"><a href="#156、Java-中的内存映射缓存区是什么？" class="headerlink" title="156、Java 中的内存映射缓存区是什么？"></a>156、Java 中的内存映射缓存区是什么？</h2><h2 id="157、socket-选项-TCP-NO-DELAY-是指什么？"><a href="#157、socket-选项-TCP-NO-DELAY-是指什么？" class="headerlink" title="157、socket 选项 TCP NO DELAY 是指什么？"></a>157、socket 选项 TCP NO DELAY 是指什么？</h2><h2 id="158、TCP-协议与-UDP-协议有什么区别？"><a href="#158、TCP-协议与-UDP-协议有什么区别？" class="headerlink" title="158、TCP 协议与 UDP 协议有什么区别？"></a>158、TCP 协议与 UDP 协议有什么区别？</h2><p>TCP协议和UDP协议特性区别总结：</p><ol><li><p>TCP协议在传送数据段的时候要给段标号；UDP协议不</p></li><li><p>TCP协议可靠；UDP协议不可靠</p></li><li><p>TCP协议是面向连接；UDP协议采用无连接</p></li><li><p>TCP协议负载较高，采用虚电路；UDP采用无连接</p></li><li><p>TCP协议的发送方要确认接收方是否收到数据段（3次握手协议）</p></li><li><p>TCP协议采用窗口技术和流控制</p></li></ol><h2 id="159、Java-中，ByteBuffer-与-StringBuffer-有什么区别？"><a href="#159、Java-中，ByteBuffer-与-StringBuffer-有什么区别？" class="headerlink" title="159、Java 中，ByteBuffer 与 StringBuffer 有什么区别？"></a>159、Java 中，ByteBuffer 与 StringBuffer 有什么区别？</h2><h2 id="160、Java-中，编写多线程程序的时候你会遵循哪些最佳实践？"><a href="#160、Java-中，编写多线程程序的时候你会遵循哪些最佳实践？" class="headerlink" title="160、Java 中，编写多线程程序的时候你会遵循哪些最佳实践？"></a>160、Java 中，编写多线程程序的时候你会遵循哪些最佳实践？</h2><p>a）给线程命名，这样可以帮助调试。</p><p>b）最小化同步的范围，而不是将整个方法同步，只对关键部分做同步。</p><p>c）如果可以，更偏向于使用 volatile 而不是 synchronized。</p><p>d）使用更高层次的并发工具，而不是使用 wait() 和 notify() 来实现线程间通信，如 BlockingQueue，CountDownLatch 及 Semaphore。</p><p>e）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。</p><h2 id="161、说出几点-Java-中使用-Collections-的最佳实践"><a href="#161、说出几点-Java-中使用-Collections-的最佳实践" class="headerlink" title="161、说出几点 Java 中使用 Collections 的最佳实践"></a>161、说出几点 Java 中使用 Collections 的最佳实践</h2><p>a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不是Vector。</p><p>b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。</p><p>c）使用接口代表和访问集合，如使用 List 存储 ArrayList，使用 Map 存储HashMap 等等。</p><p>d）使用迭代器来循环集合。</p><p>e）使用集合的时候使用泛型。</p><h2 id="162、说出至少-5-点在-Java-中使用线程的最佳实践。"><a href="#162、说出至少-5-点在-Java-中使用线程的最佳实践。" class="headerlink" title="162、说出至少 5 点在 Java 中使用线程的最佳实践。"></a>162、说出至少 5 点在 Java 中使用线程的最佳实践。</h2><p>这个问题与之前的问题类似，你可以使用上面的答案。对线程来说，你应该：</p><p>a）对线程命名</p><p>b）将线程和任务分离，使用线程池执行器来执行 Runnable 或 Callable。</p><p>c）使用线程池</p><h2 id="163、说出-5-条-IO-的最佳实践"><a href="#163、说出-5-条-IO-的最佳实践" class="headerlink" title="163、说出 5 条 IO 的最佳实践"></a>163、说出 5 条 IO 的最佳实践</h2><p>IO 对 Java 应用的性能非常重要。理想情况下，你不应该在你应用的关键路径上避免 IO 操作。下面是一些你应该遵循的 Java IO 最佳实践：</p><p>a）使用有缓冲区的 IO 类，而不要单独读取字节或字符。</p><p>b）使用 NIO 和 NIO2</p><p>c）在 finally 块中关闭流，或者使用 try-with-resource 语句。</p><p>d）使用内存映射文件获取更快的 IO。</p><h2 id="164、列出-5-个应该遵循的-JDBC-最佳实践"><a href="#164、列出-5-个应该遵循的-JDBC-最佳实践" class="headerlink" title="164、列出 5 个应该遵循的 JDBC 最佳实践"></a>164、列出 5 个应该遵循的 JDBC 最佳实践</h2><p>有很多的最佳实践，你可以根据你的喜好来例举。下面是一些更通用的原则：</p><p>a）使用批量的操作来插入和更新数据</p><p>b）使用 PreparedStatement 来避免 SQL 异常，并提高性能。</p><p>c）使用数据库连接池</p><p>d）通过列名来获取结果集，不要使用列的下标来获取。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E9%9D%A2%E8%AF%95/" class="category-chain-item">面试</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E9%9D%A2%E8%AF%95/">#面试</a></div></div><div class="license-box my-3"><div class="license-title"><div>面试单题</div><div>https://blog.yahyav2rayssr.top/posts/1f03d757/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Yahya</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年4月16日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,t=t.getElementById("subtitle");t&&e&&e(t.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>