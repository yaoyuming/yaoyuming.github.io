<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png"><link rel="icon" href="/img/fluid.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Yahya"><meta name="keywords" content=""><meta name="description" content="Java 基础final 注：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的  如果在静态方法的声明中加上final，则表示该方法不会被子类的方法隐藏。 final参数不可以赋值，因为在调用方法时，已经对其赋值了。 用final修饰的字符串就是在编译期可知的 1234567public class StringTest &amp;#123;    p"><meta property="og:type" content="article"><meta property="og:title" content="Java 基础"><meta property="og:url" content="https://blog.yahyav2rayssr.top/posts/a019e08c/index.html"><meta property="og:site_name" content="yahya的博客"><meta property="og:description" content="Java 基础final 注：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的  如果在静态方法的声明中加上final，则表示该方法不会被子类的方法隐藏。 final参数不可以赋值，因为在调用方法时，已经对其赋值了。 用final修饰的字符串就是在编译期可知的 1234567public class StringTest &amp;#123;    p"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/a019e08c/51.jpg"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/a019e08c/81.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/a019e08c/82.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/a019e08c/83.png"><meta property="og:image" content="https://blog.yahyav2rayssr.top/posts/a019e08c/120.png"><meta property="article:published_time" content="2023-04-18T15:31:27.693Z"><meta property="article:modified_time" content="2023-04-18T15:31:27.694Z"><meta property="article:author" content="Yahya"><meta property="article:tag" content="java"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://blog.yahyav2rayssr.top/posts/a019e08c/51.jpg"><title>Java 基础 - yahya的博客</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"blog.yahyav2rayssr.top",root:"/",version:"1.9.4",typing:{enable:!1,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!1,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!1,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:6},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="yahya的博客" type="application/atom+xml"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Yahya的博客</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle">Java 基础</span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-18 23:31" pubdate>2023年4月18日 晚上</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 22k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 182 分钟</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar category-bar" style="margin-right:-1rem"><div class="category-list"><div class="category row nomargin-x"><a class="category-item list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Java" id="heading-d52387880e1ea22817a72d3759213819" role="tab" data-toggle="collapse" href="#collapse-d52387880e1ea22817a72d3759213819" aria-expanded="true">Java <span class="list-group-count">(51)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-d52387880e1ea22817a72d3759213819" role="tabpanel" aria-labelledby="heading-d52387880e1ea22817a72d3759213819"><div class="category-post-list"><a href="/posts/a3b6ed09/" title="Java 常用命令" class="list-group-item list-group-item-action"><span class="category-post">Java 常用命令</span></a></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="JVM" id="heading-18b5a217c4dad25662d3a05edb0e39d7" role="tab" data-toggle="collapse" href="#collapse-18b5a217c4dad25662d3a05edb0e39d7" aria-expanded="false">JVM <span class="list-group-count">(5)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-18b5a217c4dad25662d3a05edb0e39d7" role="tabpanel" aria-labelledby="heading-18b5a217c4dad25662d3a05edb0e39d7"><div class="category-post-list"><a href="/posts/9e0bfe2e/" title="JVM 垃圾收集器" class="list-group-item list-group-item-action"><span class="category-post">JVM 垃圾收集器</span> </a><a href="/posts/5b44aded/" title="JVM 垃圾收集器与内存分配策略" class="list-group-item list-group-item-action"><span class="category-post">JVM 垃圾收集器与内存分配策略</span> </a><a href="/posts/7c42c21b/" title="JVM 指令大全" class="list-group-item list-group-item-action"><span class="category-post">JVM 指令大全</span> </a><a href="/posts/1b362162/" title="JVM 杂项" class="list-group-item list-group-item-action"><span class="category-post">JVM 杂项</span> </a><a href="/posts/703fe08b/" title="JVM 运行时数据区域" class="list-group-item list-group-item-action"><span class="category-post">JVM 运行时数据区域</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Java 基础" id="heading-3c457761d24c20abb3e9682a48e47df6" role="tab" data-toggle="collapse" href="#collapse-3c457761d24c20abb3e9682a48e47df6" aria-expanded="true">Java 基础 <span class="list-group-count">(6)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse show" id="collapse-3c457761d24c20abb3e9682a48e47df6" role="tabpanel" aria-labelledby="heading-3c457761d24c20abb3e9682a48e47df6"><div class="category-post-list"><a href="/posts/80d2509b/" title="Java IO 流详解" class="list-group-item list-group-item-action"><span class="category-post">Java IO 流详解</span> </a><a href="/posts/fa358471/" title="Java 反射" class="list-group-item list-group-item-action"><span class="category-post">Java 反射</span> </a><a href="/posts/a019e08c/" title="Java 基础" class="list-group-item list-group-item-action active"><span class="category-post">Java 基础</span> </a><a href="/posts/74a86a53/" title="Java 数学运算" class="list-group-item list-group-item-action"><span class="category-post">Java 数学运算</span> </a><a href="/posts/23a29293/" title="Java 时间运算" class="list-group-item list-group-item-action"><span class="category-post">Java 时间运算</span> </a><a href="/posts/3aa3d5b8/" title="lambda 表达式用法" class="list-group-item list-group-item-action"><span class="category-post">lambda 表达式用法</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="Spring" id="heading-38008dd81c2f4d7985ecf6e0ce8af1d1" role="tab" data-toggle="collapse" href="#collapse-38008dd81c2f4d7985ecf6e0ce8af1d1" aria-expanded="false">Spring <span class="list-group-count">(10)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-38008dd81c2f4d7985ecf6e0ce8af1d1" role="tabpanel" aria-labelledby="heading-38008dd81c2f4d7985ecf6e0ce8af1d1"><div class="category-post-list"><a href="/posts/2ed6c644/" title="Spring AOP 详解" class="list-group-item list-group-item-action"><span class="category-post">Spring AOP 详解</span> </a><a href="/posts/698a4e8e/" title="Spring Validation 校验" class="list-group-item list-group-item-action"><span class="category-post">Spring Validation 校验</span> </a><a href="/posts/940ce4f5/" title="Spring 全局属性转换配置" class="list-group-item list-group-item-action"><span class="category-post">Spring 全局属性转换配置</span> </a><a href="/posts/fac11a47/" title="Spring 单元测试" class="list-group-item list-group-item-action"><span class="category-post">Spring 单元测试</span> </a><a href="/posts/4e9ceea/" title="Spring 基础" class="list-group-item list-group-item-action"><span class="category-post">Spring 基础</span> </a><a href="/posts/70a6ebcd/" title="Spring 常用注解" class="list-group-item list-group-item-action"><span class="category-post">Spring 常用注解</span> </a><a href="/posts/7be9f3eb/" title="Spring 常见错误" class="list-group-item list-group-item-action"><span class="category-post">Spring 常见错误</span> </a><a href="/posts/b27a891c/" title="SpringCloud 组件概念" class="list-group-item list-group-item-action"><span class="category-post">SpringCloud 组件概念</span> </a><a href="/posts/2547f24d/" title="Springboot 启动流程" class="list-group-item list-group-item-action"><span class="category-post">Springboot 启动流程</span> </a><a href="/posts/fd57e58c/" title="Springboot 常用配置" class="list-group-item list-group-item-action"><span class="category-post">Springboot 常用配置</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="maven" id="heading-402c5d9af6b43711ea070bee5170f74d" role="tab" data-toggle="collapse" href="#collapse-402c5d9af6b43711ea070bee5170f74d" aria-expanded="false">maven <span class="list-group-count">(6)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-402c5d9af6b43711ea070bee5170f74d" role="tabpanel" aria-labelledby="heading-402c5d9af6b43711ea070bee5170f74d"><div class="category-post-list"><a href="/posts/25549297/" title="Maven mvnw 详解" class="list-group-item list-group-item-action"><span class="category-post">Maven mvnw 详解</span> </a><a href="/posts/5c907e7a/" title="Maven 基本安装（windows）" class="list-group-item list-group-item-action"><span class="category-post">Maven 基本安装（windows）</span> </a><a href="/posts/6ff6dc3c/" title="Maven 基础概念" class="list-group-item list-group-item-action"><span class="category-post">Maven 基础概念</span> </a><a href="/posts/c718cdb9/" title="Maven 常用命令" class="list-group-item list-group-item-action"><span class="category-post">Maven 常用命令</span> </a><a href="/posts/615834e0/" title="Maven 常用配置" class="list-group-item list-group-item-action"><span class="category-post">Maven 常用配置</span> </a><a href="/posts/4f5fa1df/" title="Maven 常见问题" class="list-group-item list-group-item-action"><span class="category-post">Maven 常见问题</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="mybatis" id="heading-f0d71b77ac2ea991f39f9dfdd5e985b5" role="tab" data-toggle="collapse" href="#collapse-f0d71b77ac2ea991f39f9dfdd5e985b5" aria-expanded="false">mybatis <span class="list-group-count">(3)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-f0d71b77ac2ea991f39f9dfdd5e985b5" role="tabpanel" aria-labelledby="heading-f0d71b77ac2ea991f39f9dfdd5e985b5"><div class="category-post-list"><a href="/posts/2f2b0963/" title="Mybatis-plus XML 标签用法" class="list-group-item list-group-item-action"><span class="category-post">Mybatis-plus XML 标签用法</span> </a><a href="/posts/f384c0b1/" title="Mybatis-plus 代码用法" class="list-group-item list-group-item-action"><span class="category-post">Mybatis-plus 代码用法</span> </a><a href="/posts/3080fe57/" title="Mybatis-plus 基本配置" class="list-group-item list-group-item-action"><span class="category-post">Mybatis-plus 基本配置</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="多线程" id="heading-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7" role="tab" data-toggle="collapse" href="#collapse-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7" aria-expanded="false">多线程 <span class="list-group-count">(11)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7" role="tabpanel" aria-labelledby="heading-c9daf4ad6b1b7a1a3e1f2eb57d4d2fc7"><div class="category-post-list"><a href="/posts/9784837e/" title="AQS 原理" class="list-group-item list-group-item-action"><span class="category-post">AQS 原理</span> </a><a href="/posts/18ad812a/" title="CountDownLatch 应用" class="list-group-item list-group-item-action"><span class="category-post">CountDownLatch 应用</span> </a><a href="/posts/27d2027c/" title="CyclicBarrier 应用" class="list-group-item list-group-item-action"><span class="category-post">CyclicBarrier 应用</span> </a><a href="/posts/e5b78a2e/" title="Java 多线程入门" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程入门</span> </a><a href="/posts/71aa5641/" title="Java 多线程基础" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程基础</span> </a><a href="/posts/ff94c717/" title="Java 多线程基础集合体系概述" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程基础集合体系概述</span> </a><a href="/posts/7c5551ea/" title="Java 多线程常用 API" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程常用 API</span> </a><a href="/posts/4b405cfc/" title="Java 多线程设计模式" class="list-group-item list-group-item-action"><span class="category-post">Java 多线程设计模式</span> </a><a href="/posts/cf2a801/" title="Java 线程池详解" class="list-group-item list-group-item-action"><span class="category-post">Java 线程池详解</span> </a><a href="/posts/bcd2abf0/" title="Semaphore 应用" class="list-group-item list-group-item-action"><span class="category-post">Semaphore 应用</span> </a><a href="/posts/61ccd33e/" title="StampedLock 应用" class="list-group-item list-group-item-action"><span class="category-post">StampedLock 应用</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="工具库" id="heading-de33723f9f63fa412b6071def21565ce" role="tab" data-toggle="collapse" href="#collapse-de33723f9f63fa412b6071def21565ce" aria-expanded="false">工具库 <span class="list-group-count">(5)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-de33723f9f63fa412b6071def21565ce" role="tabpanel" aria-labelledby="heading-de33723f9f63fa412b6071def21565ce"><div class="category-post-list"><a href="/posts/86e940c9/" title="fastjson 常用 API" class="list-group-item list-group-item-action"><span class="category-post">fastjson 常用 API</span> </a><a href="/posts/4e9562ed/" title="fastjson 常见问题" class="list-group-item list-group-item-action"><span class="category-post">fastjson 常见问题</span> </a><a href="/posts/df564e8b/" title="lombok 基础" class="list-group-item list-group-item-action"><span class="category-post">lombok 基础</span> </a><a href="/posts/34954977/" title="swagger 常用注解" class="list-group-item list-group-item-action"><span class="category-post">swagger 常用注解</span> </a><a href="/posts/f5eac37d/" title="工具库杂项" class="list-group-item list-group-item-action"><span class="category-post">工具库杂项</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="数据结构" id="heading-0fea7c47d93da5689f31820ee525b367" role="tab" data-toggle="collapse" href="#collapse-0fea7c47d93da5689f31820ee525b367" aria-expanded="false">数据结构 <span class="list-group-count">(3)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-0fea7c47d93da5689f31820ee525b367" role="tabpanel" aria-labelledby="heading-0fea7c47d93da5689f31820ee525b367"><div class="category-post-list"><a href="/posts/39a12d12/" title="ConcurrentHashMap 详解" class="list-group-item list-group-item-action"><span class="category-post">ConcurrentHashMap 详解</span> </a><a href="/posts/e344884c/" title="HashMap 详解" class="list-group-item list-group-item-action"><span class="category-post">HashMap 详解</span> </a><a href="/posts/c9844e82/" title="Java 数据结构基础" class="list-group-item list-group-item-action"><span class="category-post">Java 数据结构基础</span></a></div></div></div><div class="category-sub row nomargin-x"><a class="category-subitem collapsed list-group-item category-item-action col-10 col-md-11 col-xm-11" title="设计模式" id="heading-301a19970448f8e4f27ddae7a7d415fe" role="tab" data-toggle="collapse" href="#collapse-301a19970448f8e4f27ddae7a7d415fe" aria-expanded="false">设计模式 <span class="list-group-count">(1)</span> <i class="iconfont icon-arrowright"></i></a><div class="category-collapse collapse" id="collapse-301a19970448f8e4f27ddae7a7d415fe" role="tabpanel" aria-labelledby="heading-301a19970448f8e4f27ddae7a7d415fe"><div class="category-post-list"><a href="/posts/fa3d1251/" title="Java 设计模式" class="list-group-item list-group-item-action"><span class="category-post">Java 设计模式</span></a></div></div></div></div></div></div></aside></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Java 基础</h1><p class="note note-info">本文最后更新于：2023年4月18日 晚上</p><div class="markdown-body"><h1 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h1><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote><p>注：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的</p></blockquote><p>如果在静态方法的声明中加上final，则表示该方法不会被子类的方法隐藏。</p><p>final参数不可以赋值，因为在调用方法时，已经对其赋值了。</p><p><strong>用final修饰的字符串就是在编译期可知的</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lan&quot;</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;tao&quot;</span>;<br>      	<span class="hljs-type">String</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b + <span class="hljs-string">&quot;2019&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面即使是引用拼接，由于编译期可知，执行效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lantao2019&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>static方法：</p><ol><li>不可被子类重写（如果子类含有相同静态方法则与父类的静态方法无关）；</li><li>直接以类名调用，也可以使用实例调用(避免)；</li><li>没有this，因为不依赖于任何实例对象；</li><li>不能访问非静态成员变量与非静态成员方法；</li><li>static方法必须实现，也就是说他不能是抽象方法abstract；</li></ol><blockquote><p>使用情景：方法不需要访问对象状态，其所需参数均显示参数提供；只需要访问静态域；</p></blockquote><h2 id="List线程安全化"><a href="#List线程安全化" class="headerlink" title="List线程安全化"></a>List线程安全化</h2><h3 id="Collections-synchronizedList"><a href="#Collections-synchronizedList" class="headerlink" title="Collections.synchronizedList"></a>Collections.synchronizedList</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">List</span> <span class="hljs-variable">list</span> <span class="hljs-operator">=</span> Collections.synchronizedList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>());<br>      ...<br>  <span class="hljs-keyword">synchronized</span> (list) &#123;<br>      <span class="hljs-type">Iterator</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> list.iterator(); <span class="hljs-comment">// Must be in synchronized block</span><br>      <span class="hljs-keyword">while</span> (i.hasNext())<br>          foo(i.next());<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>既然封装类内部已经加了对象锁，为什么外部还要加一层对象锁？</strong></p><p>看源码可知，Collections.synchronizedList中很多方法，比如equals,hasCode,get,set,add,remove,indexOf,lastIndexOf……</p><p>都添加了锁，但是List中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CopyIterator&lt;E&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>这个方法没有加锁，不是线程安全的，所以如果要遍历，还是必须要在外面加一层锁。</p><p><strong>SynchronizedList和Vector最主要的区别</strong></p><ol><li>Vector扩容为原来的2倍长度，ArrayList扩容为原来1.5倍</li><li>SynchronizedList有很好的扩展和兼容功能。他可以将所有的List的子类转成线程安全的类。</li><li><strong>使用SynchronizedList的时候，进行遍历时要手动进行同步处理 。</strong></li><li>SynchronizedList可以指定锁定的对象。</li></ol><h3 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h3><p>CopyOnWriteArrayList是ArrayList的线程安全版本，从他的名字可以推测，CopyOnWriteArrayList是在有写操作的时候会copy一份数据，然后写完再设置成新的数据。CopyOnWriteArrayList适用于读多写少的并发场景。</p><blockquote><h5 id="写时复制"><a href="#写时复制" class="headerlink" title="写时复制"></a>写时复制</h5><p>所谓写时复制（copy-on-write），是在对集合进行“写”操作时，在内部将数据结构全部复制一份的机制。使用这种机制后，即使在多个线程发生读写冲突时ConcurrentModificationException异常也不会被抛出。</p></blockquote><h2 id="Queue集合"><a href="#Queue集合" class="headerlink" title="Queue集合"></a>Queue集合</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列与栈是相对的一种数据结构。只允许在一端进行插入操作，而在另一端进行删除操作的线性表。栈的特点是后进先出，而队列的特点是先进先出。队列的用处很大，但大多都是在其他的数据结构中，比如，树的按层遍历，图的广度优先搜索等都需要使用队列做为辅助数据结构。</p><h4 id="单向队列"><a href="#单向队列" class="headerlink" title="单向队列"></a>单向队列</h4><p>  单向队列比较简单，只能向队尾添加元素，从队头删除元素。</p><h4 id="双向队列"><a href="#双向队列" class="headerlink" title="双向队列"></a>双向队列</h4><p>  如果一个队列的头和尾都支持元素入队，出队，那么这种队列就称为双向队列，英文是Deque。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Queue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Collection</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">//插入（抛出异常）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-comment">//插入（返回特殊值）</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span>;<br>    <span class="hljs-comment">//移除（抛出异常）</span><br>    E <span class="hljs-title function_">remove</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//移除（返回特殊值）</span><br>    E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//检查（抛出异常）</span><br>    E <span class="hljs-title function_">element</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">//检查（返回特殊值）</span><br>    E <span class="hljs-title function_">peek</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h3><p>PriorityQueue又叫做优先级队列，保存队列元素的顺序不是按照及加入队列的顺序，而是按照队列元素的大小进行重新排序。一句话概括，PriorityQueue使用了一个高效的数据结构：堆。底层是使用数组保存数据。还会进行排序，优先将元素的最小值存到队头。</p><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p>Deque接口是Queue接口子接口。它代表一个双端队列。</p><h3 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h3><p>ArrayDeque使用数组实现的Deque;底层是数组，也是可以指定它的capacity,当然也可以不指定，默认长度是16，根据添加的元素个数，动态扩容。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是一种队列，一种可以在多线程环境下使用，并且支持阻塞等待的队列。也就是说，阻塞队列和一般的队列的区别就在于：</p><ol><li>多线程环境支持，多个线程可以安全的访问队列</li><li>支持生产和消费等待，多个线程之间互相配合，当队列为空的时候，消费线程会阻塞等待队列不为空；当队列满了的时候，生产线程就会阻塞直到队列不满。</li></ol><p>根据插入和取出两种类型的操作，具体分为下面一些类型：</p><table><thead><tr><th>操作类型</th><th>Throws Exception</th><th>Special Value</th><th>Timed out</th><th>Blocked</th></tr></thead><tbody><tr><td>插入</td><td>add(o)</td><td>offer(o)</td><td>offer(o, timeout, unit)</td><td>put(o)</td></tr><tr><td>取出(删除)</td><td>remove(o)</td><td>poll()</td><td>poll(timeout, unit)</td><td>take()</td></tr></tbody></table><ul><li>Throws Exception 类型的插入和取出在不能立即被执行的时候就会抛出异常。</li><li>Special Value 类型的插入和取出在不能被立即执行的情况下会返回一个特殊的值（true 或者 false）。</li><li>Blocked 类型的插入和取出操作在不能被立即执行的时候会阻塞线程直到可以操作的时候会被其他线程唤醒。</li><li>Timed out 类型的插入和取出操作在不能立即执行的时候会被阻塞一定的时候，如果在指定的时间内没有被执行，那么会返回一个特殊值。</li></ul><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><img src="/posts/a019e08c/51.jpg" srcset="/img/loading.gif" lazyload><p>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。</p><p><strong>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行</strong>，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。</p><p><strong>ArrayBlockingQueue和LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例</strong>，<strong>而后者则会生成一个额外的Node对象</strong>。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</p><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其 <strong>对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能</strong>。 作为开发者，我们需要注意的是，如果构造一个LinkedBlockingQueue对象，而没有指定其容量大小，LinkedBlockingQueue会默认一个类似无限大小的容量（Integer.MAX_VALUE），这样的话，如果生产者的速度一旦大于消费者的速度，也许还没有等到队列满阻塞产生，系统内存就有可能已被消耗殆尽了。</p><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>PriorityBlockingQueue是一个优先阻塞队列。所谓优先队列，就是每次从队队列里面获取到的都是队列中优先级最高的，对于优先级，PriorityBlockingQueue需要你为插入其中的元素类型提供一个Comparator，PriorityBlockingQueue使用这个Comparator来确定元素之间的优先级关系。</p><p>但需要注意的是<strong>PriorityBlockingQueue并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者</strong>。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p><h4 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h4><p>DelayQueue是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素。只有在延迟期满时才能从队列中提取元素。</p><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>SynchronousQueue和前面分析的阻塞队列都不同，因为SynchronousQueue不存在容量的说法，任何插入操作都需要等待其他线程来消费，否则就会阻塞等待，也就是说，生产线程生产出一条数据之后就要等待消费者线程来将其消费掉，才能继续生产数据，否则就会阻塞等待消费。</p><h5 id="TransferQueue（公平模式）"><a href="#TransferQueue（公平模式）" class="headerlink" title="TransferQueue（公平模式）"></a>TransferQueue（公平模式）</h5><p>该队列可以创建生产者和消费者程序并协调消息从生产者传输到消费者。</p><p>该实现类似于<a target="_blank" rel="noopener" href="https://blog.csdn.net/neweastsun/article/details/87907890">BlockingQueue</a>类，但其可以实现反压形式传输，即当生产者利用transfer()方法发送消息给消费者时，生产者将一直被阻塞，直到消息被使用为止。</p><h5 id="TransferStack（非公平模式）"><a href="#TransferStack（非公平模式）" class="headerlink" title="TransferStack（非公平模式）"></a>TransferStack（非公平模式）</h5><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><h4 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>并编程中，一般需要用到安全的队列，如果要自己实现安全队列，可以使用2种方式：</p><ul><li>加锁，这种实现方式就是我们常说的阻塞队列。</li><li>使用循环CAS算法实现，这种方式实现队列称之为非阻塞队列。</li></ul><p>ConcurrentLinkedQueue 是一个基于链接节点的<strong>无界线</strong>程安全的队列，按照先进先出原则对元素进行排序。新元素从队列尾部插入，而获取队列元素，则需要从队列头部获取；内部的数据结构是分开的，线程之间互不影响，所以也就无需执行互斥处理。</p><h5 id="ConcurrentLinkedQueue使用约定："><a href="#ConcurrentLinkedQueue使用约定：" class="headerlink" title="ConcurrentLinkedQueue使用约定："></a>ConcurrentLinkedQueue使用约定：</h5><ul><li>不允许null入列</li><li>在入队的最后一个元素的next为null</li><li>队列中所有未删除的节点的item都不能为null且都能从head节点遍历到</li><li>删除节点是将item设置为null, 队列迭代时跳过item为null节点</li><li>head节点跟tail不一定指向头节点或尾节点，可能存在滞后性</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ol><li>入列出列线程安全，遍历不安全</li><li>不允许添加null元素</li><li>底层使用列表与CAS算法保证入列出列安全</li></ol><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>java.util.concurrent.Exchanger 类用于让两个线程安全的交换对象。</p><h2 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h2><h3 id="Executors-newFixedThreadPool方法"><a href="#Executors-newFixedThreadPool方法" class="headerlink" title="Executors.newFixedThreadPool方法"></a>Executors.newFixedThreadPool方法</h3><p>Executors.newFixedThreadPool方法会创建一个线程池，该线程池会创建个数由参数指定的工人线程，而且创建出的线程会被重复利用。如果在这个方法的参数中加上ThreadFactory对象，则线程池会使用该ThreadFactory来创建新的工人线程。</p><h3 id="Executors-newCachedThreadPool方法"><a href="#Executors-newCachedThreadPool方法" class="headerlink" title="Executors.newCachedThreadPool方法"></a>Executors.newCachedThreadPool方法</h3><p>Executors.newCachedThreadPool方法会创建一个线城市，该线程池可以根据需要自动创建工人线程，而且创建的工人线程会被重复利用。没有工作的工人线程会在缓存约60秒后自动终止。如果像这个方法的参数中传入ThreadFactory对象，则线程池会使用这个ThreadFactory来创建新的工人线程。</p><h3 id="Executors-newScheduledThreadPool方法"><a href="#Executors-newScheduledThreadPool方法" class="headerlink" title="Executors.newScheduledThreadPool方法"></a>Executors.newScheduledThreadPool方法</h3><blockquote><p>推荐使用<code>newScheduledThreadPool</code>代替 <code>Timer</code>对象</p><p>因为不会收到异常中断的影响</p></blockquote><p>Executors.newScheduledThreadPool方法会创建一个线程池，该线程池可以在一定时间后执行请求或是反复执行请求。即使在没有请求时也需要保存的线程数量可以通过参数指定。此外，如果在这个方法的参数中加上ThreadFactory对象，则线程池会使用这个ThreadFactory来创建新的工人线程。</p><h2 id="5种创建对象的方法："><a href="#5种创建对象的方法：" class="headerlink" title="5种创建对象的方法："></a>5种创建对象的方法：</h2><ol><li>使用new关键字</li><li>Class对象的newInstance()方法</li><li>构造函数对象的newInstance()方法</li><li>对象反序列化</li><li>Object对象的clone()方法</li></ol><h3 id="1-使用new关键字"><a href="#1-使用new关键字" class="headerlink" title="1. 使用new关键字"></a><strong>1. 使用new关键字</strong></h3><p>这是最常用也最简单的方式，看看下面这个例子就知道了。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_ invoke__">Test</span>() &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_ invoke__">Test</span>(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_ invoke__">getName</span>() &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">setName</span>(String name) &#123;<br>        this.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_ invoke__">main</span>(String[] args) &#123;<br>        Test t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>        Test t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Class对象的newInstance-方法"><a href="#2-Class对象的newInstance-方法" class="headerlink" title="2. Class对象的newInstance()方法"></a><strong>2. Class对象的newInstance()方法</strong></h3><p>还是上面的Test对象，首先我们通过Class.forName()动态的加载类的Class对象，然后通过newInstance()方法获得Test类的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;org.b3log.solo.util.Test&quot;</span>;<br>    <span class="hljs-type">Class</span> <span class="hljs-variable">clasz</span> <span class="hljs-operator">=</span> Class.forName(className);<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (Test) clasz.newInstance();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-构造函数对象的newInstance-方法"><a href="#3-构造函数对象的newInstance-方法" class="headerlink" title="3. 构造函数对象的newInstance()方法"></a><strong>3. 构造函数对象的newInstance()方法</strong></h3><p>类Constructor也有newInstance方法，这一点和Class有点像。从它的名字可以看出它与Class的不同，Class是通过类来创建对象，而Constructor则是通过构造器。我们依然使用第一个例子中的Test类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Constructor&lt;Test&gt; constructor;<br>   <span class="hljs-keyword">try</span> &#123;<br>        constructor = Test.class.getConstructor();<br>       <span class="hljs-type">Test</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> constructor.newInstance();<br>   &#125; <span class="hljs-keyword">catch</span> (InstantiationException |<br>        IllegalAccessException |<br>        IllegalArgumentException |<br>        InvocationTargetException |<br>        NoSuchMethodException |<br>        SecurityException e) &#123;<br>        e.printStackTrace();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-对象反序列化"><a href="#4-对象反序列化" class="headerlink" title="4. 对象反序列化"></a><strong>4. 对象反序列化</strong></h3><p>使用反序列化来获得类的对象，那么这里必然要用到序列化Serializable接口，所以这里我们将第一个例子中的Test作出一点改变，那就是实现序列化接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Test</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">filePath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;sample.txt&quot;</span>;<br>     <span class="hljs-type">Test</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>     <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath);<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(fileOutputStream);<br>        outputStream.writeObject(t1);<br>        outputStream.flush();<br>        outputStream.close();<br><br>        <span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fileInputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span><br>               <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(fileInputStream);<br>        <span class="hljs-type">Test</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> (Test) inputStream.readObject();<br>        inputStream.close();<br>        System.out.println(t2.getName());<br>     &#125; <span class="hljs-keyword">catch</span> (Exception ee) &#123;<br>           ee.printStackTrace();<br>     &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-Object对象的clone-方法"><a href="#5-Object对象的clone-方法" class="headerlink" title="5. Object对象的clone()方法"></a><strong>5. Object对象的clone()方法</strong></h3><p>Object对象中存在clone方法，它的作用是创建一个对象的副本。看下面的例子，这里我们依然使用第一个例子的Test类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>    <span class="hljs-type">Test</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> (Test) t1.clone();<br>    System.out.println(t2.getName());<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a><strong>happens-before原则</strong></h2><p>　　Java内存模型中定义的两项操作之间的次序关系，如果说操作A先行发生于操作B，操作A产生的影响能被操作B观察到，“影响”包含了修改了内存中共享变量的值、发送了消息、调用了方法等。</p><p>　　下面是Java内存模型下一些”天然的“happens-before关系，这些happens-before关系无须任何同步器协助就已经存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，它们就没有顺序性保障，虚拟机可以对它们进行随意地重排序。</p><p>　　a. 程序次序规则(Pragram Order Rule)：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环结构。</p><p>　　b. 管程锁定规则(Monitor Lock Rule)：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而”后面“是指时间上的先后顺序。</p><p>　　c. volatile变量规则(Volatile Variable Rule)：对一个volatile变量的写操作先行发生于后面对这个变量的读取操作，这里的”后面“同样指时间上的先后顺序。</p><p>　　d. 线程启动规则(Thread Start Rule)：Thread对象的start()方法先行发生于此线程的每一个动作。</p><p>　　e. 线程终止规则(Thread Termination Rule)：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束，Thread.isAlive()的返回值等作段检测到线程已经终止执行。</p><p>　　f. 线程中断规则(Thread Interruption Rule)：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测是否有中断发生。</p><p>　　g. 对象终结规则(Finalizer Rule)：一个对象初始化完成(构造方法执行完成)先行发生于它的finalize()方法的开始。</p><p>　　h. 传递性(Transitivity)：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</p><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>CAS，是 compare and swap 的缩写，即比较并交换。它是一种基于乐观锁的操作。它有三个操作数，内存值V，预期值A，更新值B。当且仅当A和V相同时，才会把V修改成B，否则什么都不做。之前说到AtomicInteger用到了CAS，那么先从这个类说起。看如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">atomicInteger</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">5</span>);<br>        System.out.println(atomicInteger.compareAndSet(<span class="hljs-number">5</span>,<span class="hljs-number">50</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>AtomicInteger有一个compareAndSet方法，有两个操作数，第一个是期望值，第二个是希望修改成的值。首先初始值是5，第一次调用compareAndSet方法的时候，将5拷贝回自己的工作空间，然后改成50，写回到主内存中的时候，它期望主内存中的值是5，而这时确实也是5，所以可以修改成功，主内存中的值也变成了50，输出true。第二次调用compareAndSet的时候，在自己的工作内存将值修改成100，写回去的时候，希望主内存中的值是5，但是此时是50，所以set失败，输出false。这就是比较并交换，也即CAS。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>简而言之，CAS工作原理就是<strong>UnSafe类</strong>和<strong>自旋锁</strong>。</p><p><strong>1、UnSafe类：</strong><br>UnSafe类在jdk的rt.jar下面的一个类，全包名是sun.misc.UnSafe。这个类大多数方法都是native方法。由于Java不能操作计算机系统，所以设计之初就留了一个UnSafe类。通过UnSafe类，Java就可以操作指定内存地址的数据。调用UnSafe类的CAS，JVM会帮我们实现出汇编指令，从而实现原子操作。现在就来分析一下AtomicInteger的getAndIncrement方法是怎么工作的。看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> U.getAndAddInt(<span class="hljs-built_in">this</span>, VALUE, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-meta">@HotSpotIntrinsicCandidate</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object o, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(o, offset);<br>    &#125; <span class="hljs-keyword">while</span> (!weakCompareAndSetInt(o, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的o就是当前对象，offset是内存地址，delta是1，也就是自增步伐。首先把当前对象主内存中的值赋给v，然后进入while循环。判断当前对象此刻主内存中的值是否等于v，如果是，就自增，否则继续循环，重新获取v的值。这里的compareAndSwapInt方法就是一个native方法，这个方法汇编之后是CPU原语指令，原语指令是连续执行不会被打断的，所以可以保证原子性。</p><p><strong>2、自旋锁：</strong><br>所谓的自旋，其实就是上面getAndAddInt方法中的do while循环操作。当预期值和主内存中的值不等时，就重新获取主内存中的值，这就是自旋。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><strong>1、循环时间长，开销大。</strong><br>synchronized是加锁，同一时间只能一个线程访问，并发性不好。而CAS并发性提高了，但是由于CAS存在自旋操作，即do while循环，如果CAS失败，会一直进行尝试。如果CAS长时间不成功，会给CPU带来很大的开销。</p><p><strong>2、只能保证一个共享变量的原子性。</strong><br>上面也看到了，getAndAddInt方法的o是代表当前对象，所以它也就是能保证这一个共享变量的原子性。如果要保证多个，那只能加锁了。</p><p><strong>3、引来的ABA问题。</strong></p><ul><li><strong>什么是ABA问题？</strong></li></ul><p>假设现在主内存中的值是A，现有t1和t2两个线程去对其进行操作。t1和t2先将A拷贝回自己的工作内存。这个时候t2线程将A改成B，刷回到主内存。此刻主内存和t2的工作内存中的值都是B。接下来还是t2线程抢到执行权，t2又把B改回A，并刷回到主内存。这时t1终于抢到执行权了，自己工作内存中的值的A，主内存也是A，因此它认为没人修改过，就在工作内存中把A改成了X，然后刷回主内存。也就是说，在t1线程执行前，t2将主内存中的值由A改成B再改回A。这便是ABA问题。看下面的代码演示(代码涉及到原子引用，请参考下面的原子引用的介绍)：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">ABADemo</span> &#123;<br>   <span class="hljs-keyword">static</span> AtomicReference&lt;String&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>);<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span>&#123;<br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>              atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>);<br>              atomicReference.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;A&quot;</span>);<br>              &#125;,<span class="hljs-string">&quot;t2&quot;</span>).start();<br>          <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>              <span class="hljs-keyword">try</span> &#123; <br>                   TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>              &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   e.printStackTrace(); <br>              &#125;<br>              System.<span class="hljs-keyword">out</span>.println(atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>) <br>                                           + <span class="hljs-string">&quot;\t&quot;</span> + atomicReference.<span class="hljs-keyword">get</span>());<br>              &#125;,<span class="hljs-string">&quot;t1&quot;</span>).start();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码执行结果是”true C”，这就证明了ABA问题的存在。如果一个业务只管开头和结果，不管这个A中间是否变过，那么出现了ABA问题也没事。如果需要A还是最开始的那个A，中间不许别人动手脚，那么就要规避ABA问题。要解决ABA问题，先看下面的原子引用的介绍。</p><ul><li><strong>原子引用：</strong></li></ul><p>JUC包下给我们提供了原子包装类，像AtomicInteger。如果我不仅仅想要原子包装类，我自己定义的User类也想具有原子操作，怎么办呢？JUC为我们提供了AtomicReference<v>，即原子引用。看下面的代码：</v></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-built_in">int</span> age;<br>    <span class="hljs-built_in">String</span> name;<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-built_in">String</span>[] args)&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">20</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        AtomicReference&lt;User&gt; atomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;();<br>        atomicReference.<span class="hljs-keyword">set</span>(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像这样，就把User类变成了原子User类了。</p><ul><li><strong>解决ABA问题思路：</strong></li></ul><p>我们可以这个共享变量带上一个版本号。比如现在主内存中的是A，版本号是1，然后t1和t2线程拷贝一份到自己工作内存。t2将A改为B，刷回主内存。此时主内存中的是B，版本号为2。然后再t2再改回A，此时主内存中的是A，版本号为3。这个时候t1线程终于来了，自己工作内存是A，版本号是1，主内存中是A，但是版本号为3，它就知道已经有人动过手脚了。那么这个版本号从何而来，这就要说说AtomicStampedReference这个类了。</p><ul><li><strong>带时间戳的原子引用(AtomicStampedReference)：</strong><br>这个时间戳就理解为版本号就行了。看如下代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ABADemo</span> &#123;<br>    <span class="hljs-keyword">static</span> AtomicStampedReference&lt;String&gt; atomicReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>); <span class="hljs-comment">// 睡一秒，让t1线程拿到最初的版本号</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, atomicReference.getStamp(), atomicReference.getStamp() + <span class="hljs-number">1</span>);<br>            atomicReference.compareAndSet(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, atomicReference.getStamp(), atomicReference.getStamp() + <span class="hljs-number">1</span>);<br>        &#125;, <span class="hljs-string">&quot;t2&quot;</span>).start();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> atomicReference.getStamp(); <span class="hljs-comment">// 拿到最开始的版本号</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">3</span>); <span class="hljs-comment">// 睡3秒，让t2线程的ABA操作执行完</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(atomicReference.compareAndSet(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, stamp, stamp + <span class="hljs-number">1</span>));<br>        &#125;, <span class="hljs-string">&quot;t1&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>初始版本号为1，t2线程每执行一次版本号加。等t1线程执行的时候，发现当前版本号不是自己一开始拿到的1了，所以set失败，输出false。这就解决了ABA问题。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ol><li>什么是CAS? —— 比较并交换，主内存值和工作内存值相同，就set为更新值。</li><li>CAS原理是什么？ —— UnSafe类和自旋锁。理解那个do while循环。</li><li>CAS缺点是什么？ —— 循环时间长会消耗大量CPU资源；只能保证一个共享变量的原子性操作；造成ABA问题。</li><li>什么是ABA问题？ —— t2线程先将A改成B，再改回A，此时t1线程以为没人修改过。</li><li>如何解决ABA问题？—— 使用带时间戳的原子引用。</li></ol><h2 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>所谓的重排序，英文记作Reorder，是指编译器和Java虚拟机通过改变程序的处理顺序来优化程序。虽然重排序被广泛用于提高性能，不过开发人员几乎不会意识到这一点。实际上，在运行单线程程序时我们无法判断是否进行了重排序。这是因为，虽然处理顺序改变了，但是规范上有很多限制可以避免程序出现运行错误。</p><blockquote><p>没有同步的状态为“存在数据竞争”。</p></blockquote><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><img src="/posts/a019e08c/81.png" srcset="/img/loading.gif" lazyload alt="image-20200709205146965" style="zoom:50%"><p>重排序可能导致x&lt;y</p><img src="/posts/a019e08c/82.png" srcset="/img/loading.gif" lazyload alt="image-20200709205234341" style="zoom:50%"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Something</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">()</span> &#123;<br>        x = <span class="hljs-number">100</span>;<br>        y = <span class="hljs-number">50</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (x &lt; y) &#123;<br>            System.out.println(<span class="hljs-string">&quot;x &lt; y&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;x &gt; y&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Something</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Something</span>();<br><br>        <span class="hljs-comment">// 写数据的线程A</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                obj.write();<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 读数据的线程B</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                obj.read();<br>            &#125;<br>        &#125;).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>假设线程A将某个值写入了字段X中，而线程B读取到了该值。我们称其为“线程A向X的写值对线程B是可见的（visible）”。“是否是可见的”这个性质就成为可见性，英文记作visibility。</p><h2 id="共享内存（堆）"><a href="#共享内存（堆）" class="headerlink" title="共享内存（堆）"></a>共享内存（堆）</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>共享内存是所有线程共享的存储空间，也被称为堆内存（heap memory）。因为实例会被全部保存在共享内存中，所以实例中的字段也存在于共享内存中。此外，<strong>数据的元素</strong>也被保存在共享内存中。也就是说，可以使用new在共享内存中分配存储空间。</p><p>局部变量不会被保存在共享内存中。通常，除局部变量外，方法的形参，catch语句块中编写的异常处理器的参数等也不会被保存在共享内存中，而是被保存在各个线程特有的栈中。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized（lock&#x2F;unlock操作）并不仅仅进行线程的互斥处理。<strong>Java内存模型确保了某个线程在进行unlockM操作前进行的所有写入操作对进行lockM操作的线程都是可见的。</strong></p><img src="/posts/a019e08c/83.png" srcset="/img/loading.gif" lazyload alt="image-20200709213538876" style="zoom:50%"><ul><li>进行unlock操作后，写入缓存中的内容会被强制地写入共享内存中</li><li>进行lock操作后，缓存中的内容会先失效，然后共享内存中的最新内存会被强制重新读取到缓存中</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile write操作时是一种release，而volatile read操作是一种acquire。</p><table><thead><tr><th>release</th><th>acquire</th></tr></thead><tbody><tr><td>volatile write</td><td>volatile read</td></tr><tr><td>unlock</td><td>lock</td></tr><tr><td>线程的启动（start）</td><td>线程启动后的第一个操作</td></tr><tr><td>线程终止前的最后一个操作</td><td>检测线程的终止（join、isAlive）</td></tr><tr><td>中断（interrupt）</td><td>检测中断（isInterrupted、Thread.interrupted、InterruptException）</td></tr><tr><td>向字段写入默认值</td><td>线程的第一个操作</td></tr></tbody></table><ul><li><p>volatile字段的赋值语句的位置很重要</p><p>volatile字段放在最后才可以保证上面声明的变量的值能够被写入主内存。</p></li><li><p>volatile不会进行线程的互斥处理</p><p>访问volatile字段的线程不会进入等待队列。</p></li><li><p>访问volatile字段会产生性能开销</p><p>访问volatile字段与synchronized的处理耗费的时间几乎相同。</p></li></ul><blockquote><p>对long和double的原子操作</p><p>Java规范无法确保对long和double的赋值操作的原子性。但是，即使是long和double的字段，只要它是volatile字段，就可以确保赋值操作的原子性。</p></blockquote><h2 id="final-1"><a href="#final-1" class="headerlink" title="final"></a>final</h2><p>使用final关键字声明的字段（final字段）只能被初始化一次。</p><p>final字段的初始化只能在“字段声明时”或是“构造函数中”进行。那么，当final字段的初始化结束后，无论在任何时候，它的值对其他线程都是可见的（变成visible）。Java内存模型可以确保被初始化后的final字段在构造函数的处理结束后是可见的。</p><p>Java内存模型可以确保final字段在构造函数执行结束后可以正确的被看到。这样就不再需要通过synchronized和volatile进行同步了。</p><h2 id="位移"><a href="#位移" class="headerlink" title="位移"></a>位移</h2><table><thead><tr><th align="left">操作符</th><th align="left">补齐方式</th><th align="left">结果符号</th></tr></thead><tbody><tr><td align="left">&lt;&lt;</td><td align="left">右边用 0 补齐</td><td align="left">和原操作数没有绝对关系，取决于左移后符号位。</td></tr><tr><td align="left">&gt;&gt;</td><td align="left">左边有原符号位补齐</td><td align="left">和原操作数有相同符号。</td></tr><tr><td align="left">&gt;&gt;&gt;</td><td align="left">左边用 0 补齐</td><td align="left">和原操作数无关，一直为正数。</td></tr></tbody></table><h2 id="Java-常见的七大设计原则"><a href="#Java-常见的七大设计原则" class="headerlink" title="Java 常见的七大设计原则"></a>Java 常见的七大设计原则</h2><p>Java常见的设计开发原则，能够帮助我们更好的理解软件设计的方式方法，更方便进行代码的维护以及写出高质量的代码。</p><h3 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1. 开闭原则"></a>1. 开闭原则</h3><p>对扩展开放，对修改关闭。尽量不要修改已有的能够稳定运行的代码，在原有的基础上进行拓展，增加新的功能，避免影响原有功能。</p><h3 id="2-单一职责原则"><a href="#2-单一职责原则" class="headerlink" title="2. 单一职责原则"></a>2. 单一职责原则</h3><p>一个类尽量实现一种功能或者提供一种服务。如果类里包含的功能特别多，在后面需要扩展或者修改的时候就要重新修改该类，容易影响代码的稳定性，维护起来也不方便。</p><h3 id="3-迪米特原则"><a href="#3-迪米特原则" class="headerlink" title="3. 迪米特原则"></a>3. 迪米特原则</h3><p>也叫最小知道原则，即如果某类A与类B可以没有直接的联系，尽量不要在A中出现B类。这样能够减少代码的耦合度，提高代码的健壮性。</p><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><p>客户端尽量不要依赖它不需要的接口，在设计接口的时候尽量方法少一些，不要建立非常臃肿的接口。接口功能越细化，系统的灵活性就越高，但是也不能越少越好，尽量细化接口及其方法即可。</p><h3 id="5-里氏替换原则"><a href="#5-里氏替换原则" class="headerlink" title="5. 里氏替换原则"></a>5. 里氏替换原则</h3><p>即在任何出现父类的地方，都可以用自子类替代。只有这样，基类才能够被复用，这也是开闭原则的补充。子类可以在父类的基础上扩展新的功能。反过来，在使用子类的地方不能使用父类，因为父类不一定具有子类的新功能。</p><h3 id="6-依赖倒置原则"><a href="#6-依赖倒置原则" class="headerlink" title="6. 依赖倒置原则"></a>6. 依赖倒置原则</h3><p>即程序要依赖抽象，而不是依赖实现。<br>这要去我们的在代码方法的参数或者对象关联时，尽量用高层次的抽象类，而不是具体的实现类。其本质就是面向接口编程。</p><h3 id="7-聚合-x2F-组合复用原则"><a href="#7-聚合-x2F-组合复用原则" class="headerlink" title="7. 聚合&#x2F;组合复用原则"></a>7. 聚合&#x2F;组合复用原则</h3><p>即尽量用聚合&#x2F;组合的方式去复用功能，尽量不要通过继承来达到复用的功能。因为继承关系中，如果基类的功能需要修改，那么子类的功能也可能受到影响。如果使用聚合&#x2F;组合的关系，类的关系不像继承那样耦合度那么高，而且聚合&#x2F;组合可以在运行时动态的进行，新对象可以动态的引用与原有类同样功能的其他对象。</p><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><p>对于一个类而言，按照如下顺序执行：</p><ol><li>执行静态代码块</li><li>执行构造代码块</li><li>执行构造函数</li></ol><p>对于静态变量、静态初始化块、变量、初始化块、构造器，它们的初始化顺序依次是（静态变量、静态初始化块）&gt;（变量、初始化块）&gt; 构造器</p><p>当涉及到继承时，按照如下顺序执行：</p><ol><li>执行父类的静态代码块，并初始化父类静态成员变量</li><li>执行子类的静态代码块，并初始化子类静态成员变量</li><li>执行父类的构造代码块，执行父类的构造函数，并初始化父类普通成员变量</li><li>执行子类的构造代码块， 执行子类的构造函数，并初始化子类普通成员变量</li></ol><img src="/posts/a019e08c/120.png" srcset="/img/loading.gif" lazyload><h2 id="生成实例的方法"><a href="#生成实例的方法" class="headerlink" title="生成实例的方法"></a>生成实例的方法</h2><ul><li>new</li><li>clone</li><li>newInstance</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th>运算符</th><th>含义</th></tr></thead><tbody><tr><td>&amp;（按位与）</td><td>1&amp;1&#x3D;1 , 1&amp;0&#x3D;0 , 0&amp;1&#x3D;0 , 0&amp;0&#x3D;0</td></tr><tr><td>|（按位或）</td><td>1|1&#x3D;1 , 1|0&#x3D;1 , 0|1&#x3D;1 , 0|0&#x3D;0</td></tr><tr><td>^（异或运算符）</td><td>1^0 &#x3D; 1 , 1^1 &#x3D; 0 , 0^1 &#x3D; 1 , 0^0 &#x3D; 0</td></tr></tbody></table><h2 id="CRLF和LF"><a href="#CRLF和LF" class="headerlink" title="CRLF和LF"></a>CRLF和LF</h2><p>Windows 系统使用的是CRLF，Unix系统(包括Linux, MacOS近些年的版本) 使用的是LF。</p><h2 id="泛型原则"><a href="#泛型原则" class="headerlink" title="泛型原则"></a>泛型原则</h2><p>Java中Override的规则有一个好记的口诀，叫“两同两小一大”（其实叫“两同两窄一宽”我觉得更好），说的是子类方法与父类方法的异同：</p><ul><li>- 子类方法的方法名&amp;参数列表与父类方法的相同。</li><li>- 子类方法的返回类型是父类方法返回类型的子类（协变返回类型，范围更窄）；</li><li>- 子类方法抛出的异常少于父类方法抛出的异常（范围更窄）；</li><li>- 子类方法的访问控制权限大于父类方法（访问范围更宽）。</li></ul><p><strong>泛型可修饰范围</strong></p><ul><li>T是成员变量的类型</li><li>T是泛型变量（无论成员变量还是局部变量）的类型参数，常见如Class<t>，List<t>。</t></t></li><li>T是方法抛出的Exception（要求<t extends exception>）</t></li><li>T是方法的返回值</li><li>T是方法的参数</li></ul><blockquote><ul><li>如果你想从一个数据类型里获取数据，使用 ? extends 通配符</li><li>如果你想把对象写入一个数据结构里，使用 ? super 通配符</li><li>如果你既想存，又想取，那就别用通配符。</li></ul><p>“这就是Maurice Naftalin在他的《Java Generics and Collections》这本书中所说的存取原则，以及Joshua Bloch在他的《Effective Java》这本书中所说的PECS法则。”[4]“即 PECS 原则 (producser-extends, consumer-super) 或者也叫 Get and Put 原则”[5]。</p></blockquote><h2 id="Java中布尔类型操作-amp-x3D-，-x3D-与-x3D-的使用"><a href="#Java中布尔类型操作-amp-x3D-，-x3D-与-x3D-的使用" class="headerlink" title="Java中布尔类型操作&amp;&#x3D;，|&#x3D;与^&#x3D;的使用"></a>Java中布尔类型操作&amp;&#x3D;，|&#x3D;与^&#x3D;的使用</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-literal">true</span>    &amp;=    <span class="hljs-literal">true</span>    ==&gt;    <span class="hljs-literal">true</span><br><span class="hljs-literal">true</span>    &amp;=    <span class="hljs-literal">false</span>    ==&gt;    <span class="hljs-literal">false</span><br><span class="hljs-literal">false</span>    &amp;=    <span class="hljs-literal">true</span>    ==&gt;    <span class="hljs-literal">false</span><br><span class="hljs-literal">false</span>    &amp;=    <span class="hljs-literal">false</span>    ==&gt;    <span class="hljs-literal">false</span><br><span class="hljs-literal">true</span>    |=    <span class="hljs-literal">true</span>    ==&gt;    <span class="hljs-literal">true</span><br><span class="hljs-literal">true</span>    |=    <span class="hljs-literal">false</span>    ==&gt;    <span class="hljs-literal">true</span><br><span class="hljs-literal">false</span>    |=    <span class="hljs-literal">true</span>    ==&gt;    <span class="hljs-literal">true</span><br><span class="hljs-literal">false</span>    |=    <span class="hljs-literal">false</span>    ==&gt;    <span class="hljs-literal">false</span><br>^=  相同为假，不同为真<br><span class="hljs-literal">true</span>    ^=    <span class="hljs-literal">true</span>    ==&gt;    <span class="hljs-literal">false</span><br><span class="hljs-literal">true</span>    ^=    <span class="hljs-literal">false</span>    ==&gt;    <span class="hljs-literal">true</span><br><span class="hljs-literal">false</span>    ^=    <span class="hljs-literal">true</span>    ==&gt;    <span class="hljs-literal">true</span><br><span class="hljs-literal">false</span>    ^=    <span class="hljs-literal">false</span>    ==&gt;    <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h2 id="double类型比较大小或相等的方法"><a href="#double类型比较大小或相等的方法" class="headerlink" title="double类型比较大小或相等的方法"></a>double类型比较大小或相等的方法</h2><h3 id="1、转换成字符串"><a href="#1、转换成字符串" class="headerlink" title="1、转换成字符串"></a>1、转换成字符串</h3><p>如果要比较的两个double数据的字符串精度相等，可以将数据转换成string然后借助string的equals方法来间接实现比较两个double数据是否相等。注意这种方法只适用于比较精度相同的数据，并且是只用用于比较是否相等的情况下，不能用来判断大小。</p><h3 id="2、使用sun提供的Double-doubleToLongBits-方法"><a href="#2、使用sun提供的Double-doubleToLongBits-方法" class="headerlink" title="2、使用sun提供的Double.doubleToLongBits()方法"></a>2、使用sun提供的<code>Double.doubleToLongBits()</code>方法</h3><p>该方法可以将double转换成long型数据，从而可以使double按照long的方法（&lt;, &gt;, &#x3D;&#x3D;）判断是否大小和是否相等。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Double.doubleToLongBits(<span class="hljs-number">0.01</span>) == Double.doubleToLongBits(<span class="hljs-number">0.01</span>) <br>Double.doubleToLongBits(<span class="hljs-number">0.02</span>) &gt; Double.doubleToLongBits(<span class="hljs-number">0.01</span>) <br>Double.doubleToLongBits(<span class="hljs-number">0.02</span>) &lt; Double.doubleToLongBits(<span class="hljs-number">0.01</span>)<br></code></pre></td></tr></table></figure><h2 id="java泛型中extends-和-super的区别"><a href="#java泛型中extends-和-super的区别" class="headerlink" title="java泛型中extends 和 super的区别"></a>java泛型中extends 和 super的区别</h2><h3 id="关键字说明"><a href="#关键字说明" class="headerlink" title="关键字说明"></a>关键字说明</h3><ul><li>? 通配符类型</li><li><? extends T> 表示类型的上界，表示参数化类型的可能是T 或是 T的子类</li><li><code>&lt;? super T&gt;</code> 表示类型下界（Java Core中叫超类型限定），表示参数化类型是此类型的超类型（父类型），直至Object</li></ul><p>换句话说：</p><ol><li><p><code>List&lt;? extends T&gt;</code> 是说 这个list放的是T或者T的子类型的对象，但是不能确定具体是什么类型，所以可以<code>get()</code>，不能<code>add()</code>（可以add null值）</p><p><strong>示例代码：</strong></p><p>add不允许</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&gt; flist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Apple&gt;();<br>    <span class="hljs-comment">// 编译错误</span><br>    flist.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>());<br>    flist.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>());<br>    flist.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br>   <br>    <br>    flist.add(<span class="hljs-literal">null</span>); <span class="hljs-comment">// only work for null</span><br>&#125;<br>   <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Food</span> &#123;<br>&#125;<br>   <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Food</span> &#123;<br>&#125;<br>   <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123;<br>&#125;<br>   <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedApple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Apple</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>get允许</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Fruit</span> <span class="hljs-variable">fruit</span> <span class="hljs-operator">=</span> flist.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><p><code>List&lt;? super T&gt;</code> 是说这个list放的是至少是T类型的对象，所以我可以add T或者T的子类型，但是get得到的类型不确定，所以不能get</p><p><strong>示例代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;? <span class="hljs-built_in">super</span> Fruit&gt; flist = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>flist.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>());<br>flist.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>());<br>flist.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RedApple</span>());<br>      <br><span class="hljs-comment">// 编译错误:</span><br><span class="hljs-type">Fruit</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> flist.get(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>带有super超类型限定的通配符可以向泛型对易用写入，带有extends子类型限定的通配符可以向泛型对象读取。</p></blockquote><p>extends 可用于返回类型限定，不能用于参数类型限定。</p><p>super 可用于参数类型限定，不能用于返回类型限定。</p><p>如果要从集合中读取类型T的数据，并且不能写入，可以使用 <code>? extends</code> 通配符；(Producer Extends)<br>如果要从集合中写入类型T的数据，并且不需要读取，可以使用 <code>? super</code> 通配符；(Consumer Super)</p><h2 id="优雅的关闭资源-try-with-resources"><a href="#优雅的关闭资源-try-with-resources" class="headerlink" title="优雅的关闭资源 try-with-resources"></a>优雅的关闭资源 try-with-resources</h2><blockquote><p>并不是所有资源都可以被 try-with-resources 自动关闭的，只有实现了 <code>java.lang.AutoCloseable</code> 接口的类，才可以被自动关闭。如果没有实现 <code>java.lang.AutoCloseable</code> 的类定义在try的括号内，则会在编译器就报错。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\head.jpg&quot;</span>)) &#123;<br>        <span class="hljs-type">byte</span>[] bytes = inputStream.readAllBytes();<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义可以被自动关闭的类"><a href="#自定义可以被自动关闭的类" class="headerlink" title="自定义可以被自动关闭的类"></a>自定义可以被自动关闭的类</h3><p>我们也可以把自己的类编写为可以被try-with-resources自动关闭的类，只需要我们去实现java.lang.AutoCloseable接口即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyResource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.lang.AutoCloseable &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;调用了close方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;D:\\head.jpg&quot;</span>);<br>         <span class="hljs-type">MyResource</span> <span class="hljs-variable">myResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyResource</span>()) &#123;<br>        <span class="hljs-type">byte</span>[] bytes = inputStream.readAllBytes();<br>        <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><h2 id="抽象类的使用限制"><a href="#抽象类的使用限制" class="headerlink" title="抽象类的使用限制"></a>抽象类的使用限制</h2><h3 id="抽象类可以有构造方法"><a href="#抽象类可以有构造方法" class="headerlink" title="抽象类可以有构造方法"></a>抽象类可以有构造方法</h3><p>由于抽象类里会存在一些属性，那么抽象类中一定存在构造方法，其存在目的是为了属性的初始化。</p><p>并且子类对象实例化的时候，依然满足先执行父类构造，再执行子类构造的顺序。</p><h3 id="抽象类不能使用-final-声明"><a href="#抽象类不能使用-final-声明" class="headerlink" title="抽象类不能使用 final 声明"></a><strong>抽象类不能使用 final 声明</strong></h3><p>因为抽象类必须有子类，而final定义的类不能有子类。</p><h3 id="抽象类能否使用-static-声明"><a href="#抽象类能否使用-static-声明" class="headerlink" title="抽象类能否使用 static 声明?"></a>抽象类能否使用 static 声明?</h3><p><strong>外部抽象类不允许使用static声明，而内部的抽象类可以使用static声明。</strong></p><p>使用static声明的内部抽象类相当于一个外部抽象类，继承的时候使用“外部类.内部类”的形式表示类名称。</p><p>内部抽象类示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-comment">//static定义的内部类属于外部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>.B &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;**********&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//向上转型</span><br>        A.<span class="hljs-type">B</span> <span class="hljs-variable">ab</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">C</span>();<br>        ab.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="抽象类中的-static-方法可以直接调用"><a href="#抽象类中的-static-方法可以直接调用" class="headerlink" title="抽象类中的 static 方法可以直接调用"></a>抽象类中的 static 方法可以直接调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World !&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        A.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有时候由于抽象类中只需要一个特定的系统子类操作，所以可以忽略掉外部子类。这样的设计在系统类库中会比较常见，目的是对用户隐藏不需要知道的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//内部抽象类子类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">A</span>&#123;<br>        <span class="hljs-comment">//覆写抽象类的方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">print</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;Hello World !&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//这个方法不受实例化对象的控制</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> A <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">B</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//此时取得抽象类对象的时候完全不需要知道B类这个子类的存在</span><br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> A.getInstance();<br>        a.print();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/Java/" class="category-chain-item">Java</a> <span>></span> <a href="/categories/Java/Java-%E5%9F%BA%E7%A1%80/" class="category-chain-item">Java 基础</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/java/">#java</a></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/posts/e1b46314/" title="kubernete 常用命令"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">kubernete 常用命令</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/posts/57a66083/" title="apollo 基本概念"><span class="hidden-mobile">apollo 基本概念</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"></div></footer><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>